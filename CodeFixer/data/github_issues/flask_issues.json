[
  {
    "title": "404 Flask cannot find /security/login API",
    "body": "We are using airflow 2.8.4, and recently we upgrade it to 2.10.5\n\n### Environment for Airflow 2.8.4\n\n- Python version: 3.10\n- Flask version: \n\n```\nFlask-AppBuilder==4.3.11\nFlask-Babel==2.0.0\nFlask-Bcrypt==1.0.1\nFlask-Caching==2.1.0\nFlask-JWT-Extended==4.6.0\nFlask-Limiter==3.5.1\nFlask-Login==0.6.3\nFlask-SQLAlchemy==2.5.1\nFlask-Session==0.5.0\nFlask-WTF==1.2.1\nFlask==2.2.5\n```\n\nCall /security/login API:\n\n<img width=\"1541\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/ef976819-1ac1-4bd6-b84b-3ceab844a998\" />\n\n\n### Environment for Airflow 2.10.5\n\n- Python version: 3.10\n- Flask version: \n\n```\nFlask-AppBuilder==4.5.2\nFlask-Babel==2.0.0\nFlask-Bcrypt==1.0.1\nFlask-Caching==2.3.0\nFlask-JWT-Extended==4.7.1\nFlask-Limiter==3.10.1\nFlask-Login==0.6.3\nFlask-SQLAlchemy==2.5.1\nFlask-Session==0.5.0\nFlask-WTF==1.2.2\nFlask==2.2.5\n```\n\nCall /security/login API:\n\n<img width=\"1552\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/e6ca32db-cb56-49e6-a266-8edb82e8d0b2\" />\n\n\nError Log:\n```\n{\n  \"detail\": \"The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.\",\n  \"status\": 404,\n  \"title\": \"Not Found\",\n  \"type\": \"about:blank\"\n}\n```\n\n/security/login API in  Flask-AppBuilder==4.5.2\n\nhttps://github.com/dpgaspar/Flask-AppBuilder/blob/v4.5.2/flask_appbuilder/security/api.py#L32\n\n/security/login API in  Flask-AppBuilder==4.3.11\n\nhttps://github.com/dpgaspar/Flask-AppBuilder/blob/v4.3.11/flask_appbuilder/security/api.py#L32",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5756",
    "comments": [
      "This appears to be an issue report for Airflow, not for Flask."
    ]
  },
  {
    "title": "Flask cannot find /security/logic API",
    "body": "We are using airflow 2.8.4, and recently we upgrade it to 2.10.5\n\nEnvironment for Airflow 2.8.4\n\n- Python version: 3.10\n- Flask version: \n\n```\nFlask-AppBuilder==4.5.2\nFlask-Babel==2.0.0\nFlask-Bcrypt==1.0.1\nFlask-Caching==2.3.0\nFlask-JWT-Extended==4.7.1\nFlask-Limiter==3.10.1\nFlask-Login==0.6.3\nFlask-SQLAlchemy==2.5.1\nFlask-Session==0.5.0\nFlask-WTF==1.2.2\nFlask==2.2.5\n```\n\nCall /security/logic API:\n\n<img width=\"1541\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/ef976819-1ac1-4bd6-b84b-3ceab844a998\" />\n\n\nEnvironment for Airflow 2.10.5\n\n- Python version: 3.10\n- Flask version: \n\n```\nFlask-AppBuilder==4.3.11\nFlask-Babel==2.0.0\nFlask-Bcrypt==1.0.1\nFlask-Caching==2.1.0\nFlask-JWT-Extended==4.6.0\nFlask-Limiter==3.5.1\nFlask-Login==0.6.3\nFlask-SQLAlchemy==2.5.1\nFlask-Session==0.5.0\nFlask-WTF==1.2.1\nFlask==2.2.5\n```\n\nCall /security/logic API:\n\n<img width=\"1552\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/e6ca32db-cb56-49e6-a266-8edb82e8d0b2\" />\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5755",
    "comments": [
      "Be sure to follow the issue template and [guide](https://palletsprojects.com/contributing/issues) when submitting an issue."
    ]
  },
  {
    "title": "Typing mismatch between Flask and Werkzeug \"Response\" objects",
    "body": "There is an odd typing issue where Werkzeug `Response` != Flask `Response`. Please see below:\n\n```python\nfrom flask import Response, redirect, url_for\n\ndef foo() -> Response:\n    return redirect(url_for(\"some.route\"))\n```\n\nThis example returns:\n\n```\nbasedpyright: Type \"Response\" is not assignable to return type \"Response\"                                \n\u00a0\u00a0\"werkzeug.wrappers.response.Response\" is not assignable to \"flask.wrappers.Response\" [reportReturnType]\n```\n\nEnvironment:\n\n- Python version: 3.13\n- Flask version: 3.1.1\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5751",
    "comments": [
      "You'll want to use `werkzeug.Response` for most annotations. Specificially for `redirect`, that's what it returns. `flask.Response` is a subclass, meaning it's not valid in that typing context. This is in general impossible to solve, we've gone back and forth before and it causes issues in user code no matter whether we use Flask's or Werkzeug's `Response` in our own annotations."
    ]
  },
  {
    "title": "MAX_FORM_MEMORY_SIZE not being picked up correctly",
    "body": "## ISSUE\nSetting app.config[\"MAX_FORM_MEMORY_SIZE\"] = VALUE\ndoes not have any effect on the actual configuration and the default 500000 bytes from werkzeug request is stilled used\n\n\n## REPLICATION\nSetup a minimum flask project\n\napp = Flask(__name__)\napp.config[\"MAX_FORM_MEMORY_SIZE\"] = 1024 * 1024 * 1024\n\nprint(app.request_class.max_form_memory_size)\n\n## MISSBEHAVIOUR\nI would expect if I set the MAX FORM MEMORY SIZE in my config it is properly applied and I can send requests with a content length appropriate to the setting but flask defaults to 500kb\n\nEnvironment:\n\n- Python version:  3.11\n- Flask version: 2.3.3\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5746",
    "comments": [
      "I can't reproduce this issue with the information provided. The following shows that the property picks up the config during a request.\n\n```python\nfrom flask import Flask, request\n\napp = Flask(__name__)\napp.config[\"MAX_FORM_MEMORY_SIZE\"] = 1234\n\n\nwith app.test_request_context():\n    print(request.max_form_memory_size)\n```"
    ]
  },
  {
    "title": "Model Context Protocol (MCP) Support for Flask",
    "body": "## Feature Request: Model Context Protocol (MCP) Support for Flask\n\n### Description\n\nThis feature request proposes adding native support for the Model Context Protocol (MCP) to Flask. MCP is an open protocol that enables secure connections between host applications and AI model providers, allowing for standardized communication patterns in AI-powered applications.\n\n**Key aspects of MCP integration would include:**\n- Built-in MCP server capabilities for Flask applications\n- Middleware for handling MCP message routing\n- Authentication and authorization mechanisms for MCP connections\n- WebSocket and HTTP transport support as per MCP specification\n- Integration with Flask's existing request/response cycle\n\n**Relevant links:**\n- [Model Context Protocol Specification](https://modelcontextprotocol.io/introduction)\n- [MCP GitHub Repository](https://github.com/modelcontextprotocol/python-sdk)\n\n### Problem Statement\n\nCurrently, developers who want to build AI-powered Flask applications that communicate via MCP must implement the protocol manually or rely on third-party libraries. This creates several challenges:\n\n1. **Boilerplate Code**: Developers need to write significant boilerplate to handle MCP message formatting, routing, and transport\n2. **Inconsistent Implementation**: Without standardized Flask integration, different projects implement MCP differently\n3. **Security Concerns**: Manual implementation may miss important security considerations built into the MCP spec\n4. **Maintenance Overhead**: Keeping custom MCP implementations up-to-date with protocol changes\n\n**Example use case:**\nA Flask application serving as an AI assistant backend needs to:\n- Accept MCP connections from client applications\n- Handle tool calls and resource requests\n- Maintain secure, authenticated sessions\n- Process streaming responses\n\nCurrently, this requires extensive custom code that could be standardized.\n\n### Proposed Solution\n\nAdd Flask-MCP as either a core extension or built-in functionality that provides:\n\n```python\nfrom flask import Flask\nfrom flask_mcp import MCPServer\n\napp = Flask(__name__)\nmcp = MCPServer(app)\n\n@mcp.tool(\"get_weather\")\ndef get_weather(location: str) -> str:\n    # Tool implementation\n    return f\"Weather in {location}\"\n\n@mcp.resource(\"user_preferences\")\ndef get_user_prefs():\n    # Resource implementation\n    return {\"theme\": \"dark\"}\n```\n\nThis would make Flask a first-class citizen in the MCP ecosystem alongside other frameworks.\n\n### Alternative Approaches\n\nWhile this could be implemented as a third-party extension (and some exist), native Flask support would:\n- Ensure better integration with Flask's ecosystem\n- Provide official maintenance and security updates  \n- Encourage broader MCP adoption in Python web development\n- Offer performance optimizations through deeper Flask integration\n\nWhat do you think?  \ud83d\ude80\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5745",
    "comments": [
      "A custom semi async jsonrpc2 protocol thats practically foreign to http is best placed in a extension or a focussed framework\n\n The aibros really did a number with it ",
      "This would be appropriate as an extension you or someone else develops and maintains. It doesn't appear to require anything from Flask itself that is not already possible. ",
      "> Ensure better integration with Flask's ecosystem\n\nA well maintained extension would accomplish the same thing.\n\n> Provide official maintenance and security updates\n\nI have no desire to take on this work. A main goal of Flask is to be a framework which others extend, without core maintainers needing to do everything. \n\n> Encourage broader MCP adoption in Python web development\n\nI do not want to encourage this. \n\n> Offer performance optimizations through deeper Flask integration\n\nThere is nothing deep in Flask that would affect performance meaningfully and that is not accessible to any extension already. "
    ]
  },
  {
    "title": "Allow multiple template folders for large projects",
    "body": "\nJinja2 supports multiple search paths for templates so Flask should do the same. This will allow template inheriting without copying files.\n\n\nhttps://github.com/pallets/jinja/blob/main/src/jinja2/loaders.py#L190\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5738",
    "comments": [
      "already possible, typically with blueprints...",
      "@ThiefMaster Do you mean by setting different blueprints to different templates? \nI believe this has its limitations if so",
      "Also already possible by specifying your own Jinja loader rather than the default, if you want some other layout. "
    ]
  },
  {
    "title": "Adding Architecture Diagram Contribution",
    "body": "Hello maintainers!\nI've created an architecture diagram that visualizes Flask's core components and their relationships. This visualization could help new contributors understand the codebase structure and assist users in grasping Flask's high-level architecture.\n\n![Image](https://github.com/user-attachments/assets/143025cf-6094-4c19-93f5-ac06bfa59738)\n\n[Flask Architecture Diagram on Kloudfarm.io](https://app.kloudfarm.io/share/379c2674f0b240c387a5135690c8f01c8c18a988878e99846fb36ea18ad7e1ef)\nThe diagram shows:\n- Core Flask classes and relationships\n- Request/response lifecycle\n- Extension integration points\n- Blueprint organization\n\nI'd be happy to:\n\n1. Submit a PR to add this to documentation\n2. Provide different file formats\n3. Create more focused diagrams of specific subsystems\n\nWould this be a helpful addition to the project? Open to any feedback or suggestions.\nThanks!",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5726",
    "comments": [
      "Personally I don't see much benefit in adding this to the project..."
    ]
  },
  {
    "title": "Ihmuukin_ai",
    "body": "<!--\nThis issue tracker is a tool to address bugs in Flask itself. Please use\nGitHub Discussions or the Pallets Discord for questions about your own code.\n\nReplace this comment with a clear outline of what the bug is.\n-->\n\n<!--\nDescribe how to replicate the bug.\n\nInclude a minimal reproducible example that demonstrates the bug.\nInclude the full traceback if there was an exception.\n-->\n\n<!--\nDescribe the expected behavior that should have happened but didn't.\n-->\n\nEnvironment:\n\n- Python version:\n- Flask version:\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5721",
    "comments": []
  },
  {
    "title": "close resources before reload (option --reload)",
    "body": "I have a Flask application that establishes connections to multiple SQLite databases.  When the local development server (werkzeug) is started with option ``--reload`` the connections are not closed on reload, since Python 3.13 this is also logged with a [ResourceWarning](https://docs.python.org/3/whatsnew/3.13.html#sqlite3):\n\n    ResourceWarning: unclosed database in <sqlite3.Connection object at ...>\n\nSince the application (since each thread) establishes various DB connections, the (debug) log is flooded with such warnings during development.\n\nI am aware that the DB connectors can be closed when the context is [torn down](https://flask.palletsprojects.com/en/stable/patterns/sqlite3/), but this is not desired. The DB connections should be open over the entire lifetime of the server (thread).\n\nAnd the problem is not limited to sqlite3, in general, it would be better to close resources before reloading the modules.\n\nIs there perhaps a hook or another chance with which it would be possible to close open resources?\n\n\n-----\n\n*I placed it here as a feature-request .. may we better move this issue to werkzeug?*",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5711",
    "comments": [
      "Use [atexit](https://docs.python.org/3/library/atexit.html) to clean up global resources when the process ends."
    ]
  },
  {
    "title": "Reference cycle caused by exception handling",
    "body": "A reference cycle is introduced by Flask's exception handling mechanism. Specifically, the exception object retains a reference to the stack frame, which in turn holds a reference back to the exception. This creates a reference cycle between the traceback and the exception instance.\n\nThis becomes particularly problematic in applications where the garbage collector is disabled (gc.disable()). Even when the GC is enabled, this cycle puts unnecessary pressure on memory management.\n\nThe issue originates from the following line in the Flask source code: https://github.com/pallets/flask/blob/9225f8bb28d291b1610c8a58e3233aa6bbdc1808/src/flask/app.py#L1507\n\nThe fix is simple: the reference to the exception object should be explicitly released once it is no longer needed.\n\nA minimal reproducible example demonstrating this issue can be found here:\n\ud83d\udc49 https://github.com/tomasz-pankowski/exception-memory-leak/tree/main\n\nEnvironment:\n\n- Python version: any\n- Flask version: 3.1.0 (earlier ones too)\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5709",
    "comments": []
  },
  {
    "title": "Jija2 security vulnerability",
    "body": "There is a security vulnerability reported for Jinja2 https://github.com/advisories/GHSA-cpwx-vrp4-4pq7\n\nSolution is to update the Jinja2 version to 3.1.6\n\n\nEnvironment:\n\n- Python version: latest\n- Flask version: latest\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5707",
    "comments": [
      "We're not pinning an upper version, so nothing stops you from doing just that."
    ]
  },
  {
    "title": "'pkgutil.get_loader' is removed from Python 3.14",
    "body": "Per What's new in Python 3.14:\n> Remove deprecated pkgutil.get_loader() and pkgutil.find_loader(). These had previously raised a DeprecationWarning since Python 3.12. (Contributed by B\u00e9n\u00e9dikt Tran in gh-97850.)\n\nIt manifests in flask's tests: \n\n```\n______________ ERROR at setup of test_prefix_package_paths[True] _______________\n\nrequest = <SubRequest 'limit_loader' for <Function test_prefix_package_paths[True]>>\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f1fe6cb9b70>\n\n    @pytest.fixture(params=(True, False))\n    def limit_loader(request, monkeypatch):\n        \"\"\"Patch pkgutil.get_loader to give loader without get_filename or archive.\n    \n        This provides for tests where a system has custom loaders, e.g. Google App\n        Engine's HardenedModulesHook, which have neither the `get_filename` method\n        nor the `archive` attribute.\n    \n        This fixture will run the testcase twice, once with and once without the\n        limitation/mock.\n        \"\"\"\n        if not request.param:\n            return\n    \n        class LimitedLoader:\n            def __init__(self, loader):\n                self.loader = loader\n    \n            def __getattr__(self, name):\n                if name in {\"archive\", \"get_filename\"}:\n                    raise AttributeError(f\"Mocking a loader which does not have {name!r}.\")\n                return getattr(self.loader, name)\n    \n>       old_get_loader = pkgutil.get_loader\nE       AttributeError: module 'pkgutil' has no attribute 'get_loader'\n\nERROR tests/test_instance_config.py::test_installed_module_paths[True] - Attr...\nERROR tests/test_instance_config.py::test_installed_package_paths[True] - Att...\nERROR tests/test_instance_config.py::test_prefix_package_paths[True] - Attrib...\n```\n\nRun the tests with Python 3.14\n\nEnvironment:\n\n- Python version: 3.14.0a6\n- Flask version: 3.1.0\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5692",
    "comments": [
      "Is there a specific reason why you need to use an alpha build of Python?\n\nAlso, see:\n\nhttps://peps.python.org/pep-0745/\nhttps://palletsprojects.com/releases",
      "Sorry, I see now that you are bringing it to attention. Apologise.",
      "I should have been more verbose in justification. Yes, my intention is to make you aware of the issue coming soon - there will only be one more alpha release in ~month. In Fedora, we're testing from the 1st alpha of a new Python release, to make sure the ecosystem is gradually ready from the day of release.",
      "I'm pretty sure these tests can be removed. The search code being tested was changed to use `importlib` a long time ago, does not access `archive`, and tests access to `get_filename` but handles it missing."
    ]
  },
  {
    "title": "flask.__init__.__getattr__ can hide typing errors",
    "body": "admittedly this is a bit of an edge case -- but perhaps if the `__getattr__` pattern is implemented next time for deprecations this can be taken into consideration!\n\nI have an unfortunately-named bit in my webapp called \"flash\" and I've used flask for years and my fingers tend to typo one as the other.\n\nI had a file like this (simplified!):\n\n```python\nimport flask\n\nflask.FlashMessage\n```\n\nwhich is obviously wrong -- flask doesn't have a `FlashMessage`!  but it was passing mypy due to `def __getattr__(name: str) -> t.Any:` in `__init__.py`\n\nit _might_ be better to guard that behind a `if not t.TYPE_CHECKING: ...` block such that mypy doesn't pick that up and lead to misleading results\n\nnot a big deal though and I see that the `__getattr__`  is already removed in mainline\n\nanother idea would be to use `@overload` on `__getattr__` such that it only allows the particular Literals? but it looks like mypy doesn't even support that so nevermind! https://github.com/python/mypy/issues/8203#issuecomment-1670344931\n\n\nEnvironment:\n\n- Python version: 3.13.1\n- Flask version: 3.1.0\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5691",
    "comments": [
      "I've subscribed to that MyPy issue, so when it's fixed I'll use overloads with literals in the future. Until then, not much to be done. `__getattr__` makes it much easier (or possible at all) to deprecate module-level names. Anything not caught by type checks would fail at runtime or in tests.",
      "Another reason I went with `__getattr__` is that IDE completion doesn't see such dynamic attributes, so new projects are less likely to import them through autocomplete during the deprecation period. If `if not t.TYPE_CHECKING` has the same result, I'll try that next time.",
      "Looks like the `if not TYPE_CHECKING` block fixes this."
    ]
  },
  {
    "title": "Error using sample code in favicon documentation",
    "body": "The code sample gives the assert `view_func is not None, \"expected view func if endpoint is not provided.\"`.\n\nDocumentation in question: https://flask.palletsprojects.com/en/stable/patterns/favicon/\n\nSample code in question:\n```\napp.add_url_rule('/favicon.ico',\n                 redirect_to=url_for('static', filename='favicon.ico'))\n```",
    "labels": [
      "docs"
    ],
    "url": "https://github.com/pallets/flask/issues/5688",
    "comments": [
      "Issue is resolved by adding an endpoint parameter to the add_url_rule call.\n\nPerhaps the documentation needs to be updated. Or there is something else wrong with my test case."
    ]
  },
  {
    "title": "Inaccurate documentation for adding a favicon redirect",
    "body": "The code sample in the existing documentation on how to redirect a favicon request assumes that add_url_rule takes a parameter named redirect_to. It does not.\n\nDocumentation in question: https://flask.palletsprojects.com/en/stable/patterns/favicon/\n\nSample code in question:\n```\napp.add_url_rule('/favicon.ico',\n                 redirect_to=url_for('static', filename='favicon.ico'))\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5686",
    "comments": [
      "Did you encounter an error? It takes all rule arguments https://werkzeug.palletsprojects.com/en/stable/routing/#werkzeug.routing.Rule",
      "I did, but I misenterpretted the error. Apologies.\n\nThe error is `view_func is not None, \"expected view func if endpoint is not provided.\"`.\n\nAdding an endpoint to the add_url_rule resolves the error. Perhaps the documentation should be updated to include the endpoint parameter.",
      "I'll open a new ticket."
    ]
  },
  {
    "title": "How to solve",
    "body": "```python\nresponse = {\n        \"status\": \"ok\",\n        \"message\": \"Success\",\n        \"response\": url\n    }\n    return jsonify(response)\n```\n\nIn this getting output like this \n\n```json\n{\"message\": \"success\", \"response\": url, \"status\": \"old\"}\n```\n\nHow to solve that getting incorrect output\n\nI need this like\n\n```\n{\n        \"status\": \"ok\",\n        \"message\": \"Success\",\n        \"response\": url\n    }\n```\n\nHow to solve ",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5679",
    "comments": [
      "what exactly is your problem? the order? if yes, there's a flask setting  to disable sorting of json keys"
    ]
  },
  {
    "title": "Admin endpoint seems to be reserved",
    "body": "```python\n@app.route(\"/admin/<password>/<int:page>\", methods=[\"GET\"])\ndef admin(password: str, page: int = 1) -> Any:\n    print(page)\n    files, total = [], 2\n    return render_template(\"admin.html\", files=files, password=password, total=total)\n```\n\nThis fails when page is 1,2,3 or 8.\n\nAt least. it might fail in more cases.\n\nIf page is 4 or 5, 9,  etc, it works.\n\nBy works I mean, it uses the actual argument instead of the default: 1\n\nI'm guessing the admin endpoint is being reserved in some way, but should it?\n\nIf I replace 'admin' to 'pok' for example:\n\n`@app.route(\"/pok/<password>/<int:page>\", methods=[\"GET\"])`\n\nThen it works as expected.\n\n\nEnvironment:\n\n- Python version: 3.13.1\n- Flask version: 3.1.0",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5676",
    "comments": [
      "Flask does not reserve any routes. You're probably using an extension that does. ",
      "Just to add some information. Whatever is reserving it only messes up when the password is `change_me`."
    ]
  },
  {
    "title": "Custom commands not listed",
    "body": "When I run the `flask` command by itself I get help output with all of my custom commands listed. But when I run `flask --help` I get the help output with only the built-in flask commands (`routes`, `run`, `shell`). I am using the `FLASK_APP` environment variable to load the app.\n\nI would think I should get the same help output (showing my custom commands) whether or not I add the `--help` parameter?\n\nEnvironment:\n\n- Python 3.12.2\n- Flask 3.1.0",
    "labels": [
      "cli"
    ],
    "url": "https://github.com/pallets/flask/issues/5673",
    "comments": [
      "I don't think there's anything from Flask's side that can be done. The `--app` option is marked eager, and the eager `--help` option is added automatically by Click to the end of the param list. The problem is, Click orders param evaluation by command line presence and position first, then by list order. Since `--help` is the only option present _on the command line_ in this case, it takes precedence. This could be something more general to report to Click, but I don't see how it can be addressed here.",
      "I understand, thanks for that explanation @davidism.",
      "@davidism I looked at the code that handles making a bare `flask` command correctly find the app and tried this slight change, which works. Not sure if there would be any unintended consequences I'm not thinking of, but I thought I'd share this to see if you think its a good idea/are open to it.\n\nFrom [cli.py L686-L694](https://github.com/pallets/flask/blob/f61172b8dd3f962d33f25c50b2f5405e90ceffa5/src/flask/cli.py#L686-L694):\n```diff\n    def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:\n-       if not args and self.no_args_is_help:\n+       if (\n+           (not args and self.no_args_is_help)\n+           or (len(args) == 1 and args[0] in self.get_help_option_names(ctx))\n+       ):\n            # Attempt to load --env-file and --app early in case they\n            # were given as env vars. Otherwise no_args_is_help will not\n            # see commands from app.cli.\n            _env_file_option.handle_parse_result(ctx, {}, [])\n            _app_option.handle_parse_result(ctx, {}, [])\n\n\n        return super().parse_args(ctx, args)\n```",
      "Hmm, that probably won't work in all cases, but I think it's fine for this where people probably won't be overriding it. Can you create a PR?",
      "@davidism No rush, but just wondering if you have had a chance to look at #5674?",
      "Looks fine, but it will be a while before I have time to merge it and make a release.",
      "Hey! \ud83d\udc4b I\u2019ve encountered similar issues when working with Flask-SQLAlchemy. Have you tried using app.app_context() explicitly to manage the request context? It might help clarify if the issue is related to how Flask handles request lifecycle. Let me know if you need help testing this! \ud83d\ude80"
    ]
  },
  {
    "title": "int route converters are actually uint, but not documented as such",
    "body": "In #2643, a user noted that flask routes with an `int` converter only accepts unsigned integers.\r\n\r\nI'll summarize a few different opinions and options in that thread:\r\n1. a user can create their own converter that accepts unsigned integers, or modifies the existing converter (but only on their codebase). An example code snippet was provided in the issue.\r\n2. The user's report could be treated as a bug in the `int` converter, so the fix would be to modify the flask `int` converter to accept the other ~50% of legitimate integers. Assumptions were made about which part of the integer space most people would use. Concerns were raised about how users may be relying on this bug, and that it should not be fixed for fear of breaking said users.\r\n3. The user's report could be treated as a bug in the documentation, so a presumed fix would be to amend [the documentation](https://flask.palletsprojects.com/en/stable/api/#url-route-registrations) which currently states \"The following converters are available: [...] `int`: accepts integers\"; it could be changed to \"`int`: accepts _unsigned_ integers\".\r\n\r\nMy expectation would have been that either option 2 or 3 would be selected, but instead it appears that the issue was locked to further comment and no further action was taken. So, the documentation is still at odds with the behavior of flask vs the math and computer science definition of integer. I'm not wedded to either solution, but would the pallets team be open to implementing a fix in either direction?\r\n\r\nThank you,\r\n-Andrew\r\n\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5670",
    "comments": [
      "The converter takes arguments: https://werkzeug.palletsprojects.com/en/stable/routing/#werkzeug.routing.IntegerConverter for example: `/add/<int(signed=True):amount>`",
      "I'm glad to see this. Would you be willing to update #2643 to indicate as much (since there, comments are closed), along with adding linkage from the flask documentation on this topic to the werkzeug documentation you've linked to? I assert that since this is a flask bug report, not a werkzeug bug report, that \"but not documented as such\" still holds at the flask level.\r\n\r\nThank you!\r\n-Andrew"
    ]
  },
  {
    "title": "ok",
    "body": "<!--\r\nReplace this comment with a description of what the feature should do.\r\nInclude details such as links to relevant specs or previous discussions.\r\n-->\r\n\r\n<!--\r\nReplace this comment with an example of the problem which this feature\r\nwould resolve. Is this problem solvable without changes to Flask, such\r\nas by subclassing or using an extension?\r\n-->\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5669",
    "comments": []
  },
  {
    "title": "Consider supporting HOT reload with `hmr`?",
    "body": "Hot Module Replacement has been existed in JavaScript ecosystem for a long time, but Python web applications are still using full reloads by default.\r\n\r\nTo solve this situation, I implemented the `hmr` package, which does the fine-grained dependency tracking, on-demand reloading jobs. Here is a demo of what the results look like:\r\n\r\nhttps://github.com/user-attachments/assets/7937d1c2-ed41-4f38-be18-9cc29b9961a1\r\n\r\nObviously the `a.py` runs everytime in `flask run --reload` but reloads only when needed in `hmr app.py`. But everything else works fine (at least for this small demo)\r\n\r\nYou may say that user should use lazy imports and cache expensive calculations themselves, but in fact not every function can be cached, and lazy imports may lead to ugly code style. This can be solved with on-demand hot reloading without overhead. So I believe this is the future.\r\n\r\nAlthough this is just a minimal demo, but I value hmr's potential in the Python ecosystem, and believe that with our efforts this is a reachable goal.\r\n\r\n> [!TIP]\r\n> You can try the example above [here](https://github.com/promplate/hmr/tree/readme/examples/flask) with `hmr app.py`\r\n\r\n---\r\n\r\nAbout `hmr`, you can refer to its [README](https://github.com/promplate/hmr) for details.\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5667",
    "comments": [
      "IMHO this adds a huge risk of weird bugs. People can add something like this themselves in their app if they want that.",
      "I really understand that this may never become a default behavior, and I can see your concern regarding potential risks that could arise.\r\nHowever, I feel it would be a bit of a pity to close this issue so quickly. Would it be possible to move it to a discussion instead? I'd love to explore whether there might be others in the community who are interested in trying it out and contributing ideas.\r\n\r\nThanks again for considering! \ud83d\ude0a",
      "Closed issues don't prevent discussions, it's not locked :)"
    ]
  },
  {
    "title": "intersphinx broken for flask.Flask.cli",
    "body": "https://flask.palletsprojects.com/en/stable/api/#flask.Flask.cli has a type of `Group`, but it doesn't link to further docs.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5666",
    "comments": [
      "This isn't the only instance of this. I don't know why it happens. As far as I can tell, our docs config is simple but not missing anything. I'd guess it's something to do with Sphinx and the complexity of type annotations. I'm not sure what could be done. ",
      "If you have a suggestion for what Flask could do here, I'm happy to consider it or review a PR, but otherwise I think this needs to be brought to Sphinx."
    ]
  },
  {
    "title": "Containerization",
    "body": "Hello  team I am planning to containerized the entire flask framework using docker so whenever user needs to work on the project they can able to run entire framework just by running docker container so can i work on this feature. ",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5662",
    "comments": [
      "There's nothing that need to be done for this. You can already run a Flask app inside a container. Just use your favorite wsgi container (like uwsgi or gunicorn) in the container to run it.",
      "PS: After seeing you open almost the same issue in multiple repos of various projects: Please don't do this. It's annoying for maintainers, since those issues are more noise than helpful.\r\n\r\nFind ONE project you are actually interested in, e.g. because you use it yourself, and contribute to that. And maybe look at their open issues for things they are actually interested in.\r\n\r\nDocker-based development workflows are probably no the lower end of interest for many projects, since especially for Python applications it's easy enough to just have a virtualenv with the dev dependencies, so there's no need at all for a docker container that's likely lacking all the tooling etc. someone may want to use.",
      "ok @ThiefMaster "
    ]
  },
  {
    "title": "Design Enhancement",
    "body": "Hello team, planning to develop flask documentation with web interface with great and clean UI, also trying to make the concept more simple and understandable can you assign me this task.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5661",
    "comments": [
      "I think we are happy with our current documentation, and if we were to change it, we'd go for an already established sphinx theme instead of something custom (which we'd need to maintain ourselves)..."
    ]
  },
  {
    "title": "app.run(debug=True)\uff0c\u4f1a\u5bfc\u81f4flask_sqlalchemy\u9519\u8bef!",
    "body": "\u5f00\u542fdebug\u6a21\u5f0f\u540e\uff0cdebug=Ture\u7684\u65f6\u5019\uff0cflask_sqlalchemy\u7684with self.app.app_context()\u4f1a\u91cd\u590d\u6267\u884c\u3002\r\n\u4f8b\u5982\u6211\u5199\u5165\u4e00\u6761\u6570\u636e {user:\"123\",name:\"youname\"}, \u5728debug\u6a21\u5f0f\u4e0b with self.app.app_context() \u4f1a\u6267\u884c\u5b8c\u5199\u5165\u5b8c\u6bd5\u540e\uff0c\u4f1a\u91cd\u65b0\u6267\u884c\u4e00\u6b21\uff0c\u5bfc\u81f4\u7a0b\u5e8f\u9000\u51fa\uff0c\u63d0\u793a\u91cd\u590d\u5199\u5165\uff01\r\n\u6211\u4ee5\u4e3a\u662f\u6211\u4ee3\u7801\u95ee\u9898\uff0c\u6211\u68c0\u67e5\u4e86\u65e0\u6570\u6b21\uff0c\u90fd\u65e0\u6cd5\u627e\u5230\u6211\u4ee3\u7801\u95ee\u9898\uff0c\u6700\u540e\u5173\u95eddebug\u6a21\u5f0f\u540e\uff0c\u5c31\u53ef\u4ee5\u6b63\u5e38\u4f7f\u7528\u3002\r\n\r\n\u590d\u73b0\u529e\u6cd5\uff1a\r\napp.py:\r\napp.run(debug=True)\r\n\r\nmodel.py\uff1a\r\npass\r\n\r\nuserdb.py:\r\n        with self.app.app_context():\r\n            new_user = userdbmodel(userdb)(user='11eee',\r\n                                           name=input(\"input\")\r\n                                           )\r\n            userdb.session.add(new_user)\r\n            userdb.session.commit()\r\n\r\n\u4f1a\u51fa\u73b0\u4e24\u6b21input\u8f93\u5165\uff0c\u4e4b\u540e\u4f1a\u63d0\u793a\u91cd\u590d\u540e\u7a0b\u5e8f\u505c\u6b62\u3002\r\n\r\n\r\n\r\n\r\n\r\n\u76ee\u524d\u53ea\u8981\u628aapp.run(debug=True)\u6539\u4e3aapp.run(debug=False)\uff0c\u4f8b\u5982\uff1a\r\napp.py:\r\napp.run(debug=False)\r\n\u5c31\u53ea\u4f1a\u6267\u884c\u4e00\u6b21\uff0c\u4e0d\u4f1a\u62a5\u9519\u3002",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5655",
    "comments": []
  },
  {
    "title": "Mypy error when accessing flask.request.json",
    "body": "I use mypy to validate my project, I upgraded from flask 2 to flask 3 and now I see plenty of errors when I try to access the json property or flask.request\r\n\r\nI just have a top level\r\n\r\nimport flask\r\n\r\nThen:\r\n\r\nj = flask.request.json  # \"Request\" has no attribute \"json\"\r\n\r\nMypy: \"Request\" has no attribute \"json\" [attr-defined]\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.13.0\r\n- Flask version: 3.1.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5654",
    "comments": [
      "I can't reproduce this issue with the information provided. Creating a file with the given content does pass when running `mypy --strict`.",
      "We found the actual problem; in case someone else bumps into this: we still had `types-Werkzeug` in our requirements.txt, like `types-Flask` it is outdated for Flask 3 and must be removed."
    ]
  },
  {
    "title": "Flash message with Markup fails",
    "body": "Upgrading my platform from Python 3.8 + Flask 3.0.3 +  Flask-Session 0.8.0 with redis backend, to Python 3.11 + Flask 3.1.0 +  Flask-Session 0.8.0 with redis backend. Same user code.\r\n\r\nIssue: fancy flash message breaks on the new platform (work fine on the old platform).\r\n\r\nFlash message:\r\n`flash(Markup('press the play button <i class=\"bi-play-btn-fill black\"></i> below'), 'info')`\r\n\r\nError:\r\n```\r\n[2024-12-10 19:01:28,998] ERROR in base: Failed to serialize session data: Encoding objects of type Markup is unsupported\r\n[2024-12-10 19:01:28,998] ERROR in app: Exception on / [POST]\r\nTraceback (most recent call last):\r\n  File \"/var/www/lib/python3.11/site-packages/flask/app.py\", line 1511, in wsgi_app\r\n    response = self.full_dispatch_request()\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/var/www/lib/python3.11/site-packages/flask/app.py\", line 920, in full_dispatch_request\r\n    return self.finalize_request(rv)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/var/www/lib/python3.11/site-packages/flask/app.py\", line 941, in finalize_request\r\n    response = self.process_response(response)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/var/www/lib/python3.11/site-packages/flask/app.py\", line 1322, in process_response\r\n    self.session_interface.save_session(self, ctx.session, response)\r\n  File \"/var/www/lib/python3.11/site-packages/flask_session/base.py\", line 305, in save_session\r\n    self._upsert_session(app.permanent_session_lifetime, session, store_id)\r\n  File \"/var/www/lib/python3.11/site-packages/flask_session/redis/redis.py\", line 78, in _upsert_session\r\n    serialized_session_data = self.serializer.encode(session)\r\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/var/www/lib/python3.11/site-packages/flask_session/base.py\", line 132, in encode\r\n    return self.encoder.encode(dict(session))\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nTypeError: Encoding objects of type Markup is unsupported\r\n[2024-12-10 19:01:29,002] ERROR in base: Failed to serialize session data: Encoding objects of type Markup is unsupported\r\n[2024-12-10 19:01:29,002] ERROR in app: Request finalizing failed with an error while handling an error\r\nTraceback (most recent call last):\r\n  File \"/var/www/lib/python3.11/site-packages/flask/app.py\", line 1511, in wsgi_app\r\n    response = self.full_dispatch_request()\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/var/www/lib/python3.11/site-packages/flask/app.py\", line 920, in full_dispatch_request\r\n    return self.finalize_request(rv)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/var/www/lib/python3.11/site-packages/flask/app.py\", line 941, in finalize_request\r\n    response = self.process_response(response)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/var/www/lib/python3.11/site-packages/flask/app.py\", line 1322, in process_response\r\n    self.session_interface.save_session(self, ctx.session, response)\r\n  File \"/var/www/lib/python3.11/site-packages/flask_session/base.py\", line 305, in save_session\r\n    self._upsert_session(app.permanent_session_lifetime, session, store_id)\r\n  File \"/var/www/lib/python3.11/site-packages/flask_session/redis/redis.py\", line 78, in _upsert_session\r\n    serialized_session_data = self.serializer.encode(session)\r\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/var/www/lib/python3.11/site-packages/flask_session/base.py\", line 132, in encode\r\n    return self.encoder.encode(dict(session))\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nTypeError: Encoding objects of type Markup is unsupported\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/var/www/lib/python3.11/site-packages/flask/app.py\", line 941, in finalize_request\r\n    response = self.process_response(response)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/var/www/lib/python3.11/site-packages/flask/app.py\", line 1322, in process_response\r\n    self.session_interface.save_session(self, ctx.session, response)\r\n  File \"/var/www/lib/python3.11/site-packages/flask_session/base.py\", line 305, in save_session\r\n    self._upsert_session(app.permanent_session_lifetime, session, store_id)\r\n  File \"/var/www/lib/python3.11/site-packages/flask_session/redis/redis.py\", line 78, in _upsert_session\r\n    serialized_session_data = self.serializer.encode(session)\r\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/var/www/lib/python3.11/site-packages/flask_session/base.py\", line 132, in encode\r\n    return self.encoder.encode(dict(session))\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nTypeError: Encoding objects of type Markup is unsupported\r\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5653",
    "comments": [
      "Looks like that error is coming from Flask-Session, you'll need to report that there. I can't reproduce the issue in Flask itself, flashing a `Markup` instance works correctly."
    ]
  },
  {
    "title": "flask==2.2.4 incompatible with werkzeug==3.1.3",
    "body": "I use flask==2.2.4 for my project and when I install flask, it pulls **any** werkzeug>=2.2.2 (which is the default behaviour). After [werkzeug==3.1.3](https://pypi.org/project/Werkzeug/3.1.3/) got released on 8 Nov, 2024, flask pulls the latest version of it. With this new version of werkzeug, while executing unit tests, I get an error saying `module 'werkzeug' has no attribute '__version__'`\r\n\r\n**A small example to reproduce the issue:**\r\n(myenv) root@6426d8424cca:~# python3\r\nPython 3.9.16 (main, Sep  2 2024, 12:46:28) \r\n[GCC 10.2.1 20210110] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n **\">>> from flask import Flask\r\n \">>> app = Flask(__name__)\r\n \">>> my_test_client = app.test_client()\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/root/myenv/lib/python3.9/site-packages/flask/app.py\", line 1252, in test_client\r\n    return cls(  # type: ignore\r\n  File \"/root/myenv/lib/python3.9/site-packages/flask/testing.py\", line 116, in __init__\r\n    \"HTTP_USER_AGENT\": f\"werkzeug/{werkzeug.__version__}\",\r\n**AttributeError: module 'werkzeug' has no attribute '__version__'****\r\n\r\n\r\nI shouldn't be seeing any error like above.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.9.16\r\n- Flask version: 2.2.4\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5652",
    "comments": [
      "You are using an unsupported version of Flask, please update to the latest version (3.1.0) if possible.\r\n\r\nWhen writing an application, you _must_ use a tool like [pip-tools](https://pypi.org/project/pip-tools/) to pin your application's full dependency tree. This gives you reproducible deployments, allowing you to control when you get updates.\r\n\r\nPlease review any of the following for more information:\r\n\r\n* https://hynek.me/articles/semver-will-not-save-you/\r\n* https://www.youtube.com/watch?v=WSVFw-3ssXM&t\r\n* https://snarky.ca/why-i-dont-like-semver/\r\n* https://caremad.io/posts/2016/02/versioning-software/\r\n* https://bernat.tech/posts/version-numbers/\r\n* https://iscinumpy.dev/post/bound-version-constraints/\r\n\r\nYou can use `uv pip install --exclude-newer \"date\"` to install packages published before a certain date, so newer packages aren't pulled in. You can also do the same with `uv pip compile` to produce a lock in case you didn't previously."
    ]
  },
  {
    "title": "Remove unnecessary whitespace in slice notation to align with PEP 8 and Black standards",
    "body": "File: flask/src/flask/cli.py\r\nLine: 701\r\n\r\nThe return statement in the _path_is_ancestor function can be updated to improve readability and align with PEP 8 and Black formatting standards for slice notation. Currently, there is unnecessary whitespace around the colon (:) in the slice, which is inconsistent with these guidelines.\r\n\r\nCurrent Code:\r\n```return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other```\r\n\r\nSuggested Change:\r\nRemove the unnecessary whitespace around the colon (:) in the slice notation to improve readability:\r\n```return os.path.join(path, other[len(path):].lstrip(os.sep)) == other```\r\n\r\nThis change ensures compliance with PEP 8 and Black standards, contributing to cleaner and more consistent formatting across the codebase.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5646",
    "comments": [
      "Please don't open issues/PRs related to formatting."
    ]
  },
  {
    "title": "Type hint for FlaskCliRunner.invoke is not specific",
    "body": "The type hint of the return type of `FlaskCliRunner.invoke` ist `typing.Any` but should use `click.testing.Result`. This leads to missing auto completions in the IDE as well as errors from the type checker if not additional type narrowing is done.\r\n\r\nThe Problem is here: https://github.com/pallets/flask/blob/main/src/flask/testing.py#L276\r\n\r\nTo fix this `Result` must be imported from `click.testing` and used as a return type annotation.\r\n\r\nThe documentation already specifies `click.testing.Result` as return type.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.12.2\r\n- Flask version: 3.1.0 but is also present in current main branch.\r\n",
    "labels": [
      "typing"
    ],
    "url": "https://github.com/pallets/flask/issues/5645",
    "comments": [
      "@davidism @pgjones @tachyondecay @carc1n0gen @ThiefMaster @jab @greyli  Can I work on this issue as I had been working for it for quite a while and think I got lead to the solution for this issue you wanted !"
    ]
  },
  {
    "title": "PROVIDE_AUTOMATIC_OPTIONS causes KeyError if not set",
    "body": "https://github.com/pallets/flask/blob/bc098406af9537aacc436cb2ea777fbc9ff4c5aa/src/flask/sansio/app.py#L641C12-L641C86\r\n\r\nSimply changing this to : `self.config.get(\"PROVIDE_AUTOMATIC_OPTIONS\", False)` should resolve the problem.\r\n\r\nThis change now released is causing upstream trouble in other packages such as Quart:\r\nhttps://github.com/pallets/quart/issues/371\r\n\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5642",
    "comments": [
      "Duplicate of pallets/quart#371",
      "This is not a duplicate as this is a separate project.\r\n\r\nAnything that doesn't pin to flask 3.0.* will be broken by this change.\r\n\r\nThe fix is simple, as far as I am aware",
      "Quart 0.19.9 is now available on PyPI."
    ]
  },
  {
    "title": "configure and check `request.trusted_hosts`",
    "body": "If `request.trusted_hosts` is set, it will be checked when accessing `request.host`/`url`/etc. Add `TRUSTED_HOSTS` config, and check it during routing.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5636",
    "comments": [
      "`Map.bind_to_environ` is called when creating the request context, and `MapAdapter.match` is called when the context is pushed. Both of these places catch routing exceptions, which are then raised during dispatch after `before_request` and before the view. I think it makes sense to check this in `Flask.create_url_adapter`, as then no matching be attempted if the host is invalid.",
      "This should be moved up into `Map.bind_to_environ`, but can be implemented in Flask until Werkzeug 3.2. See pallets/werkzeug#3007"
    ]
  },
  {
    "title": "dotenv file arg should take precedence over default dotenv files",
    "body": "As pointed out in #5532, `-e file` is loaded after the default `.env` and `.flaskenv` files, which means it won't override env vars that are set by the defaults. It will be a little tricky to track during CLI startup, but I think it should be possible to fix this so that precedence is: `os.environ` > `-e path` > `.env` > `.flaskenv`.",
    "labels": [
      "cli"
    ],
    "url": "https://github.com/pallets/flask/issues/5628",
    "comments": []
  },
  {
    "title": "extend config for Request form memory settings",
    "body": "Werkzeug provides three settings on `Request` to control form parsing: `max_content_length`, `max_form_memory_size`, and `max_form_parts`. Only `max_content_length` is exposed as a Flask config right now, and the way it's implemented means it can only be set for the whole application, not per-request. Fix all that. Document these in the security page as well as the config page.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5625",
    "comments": []
  },
  {
    "title": "Rotating secret keys",
    "body": "I'd like to have a couple of secret keys available, like so\r\n```\r\napp.secret_keys = [\r\n   'key-1',\r\n   'key-2',\r\n]\r\n```\r\nTo allow them to rotate.\r\n\r\nI've seen this issue which seems to have auto-closed\r\nhttps://github.com/pallets/flask/issues/1574\r\n\r\nIt seems like itsdangerous now supports this\r\nhttps://github.com/pallets/itsdangerous/pull/141\r\n\r\nThis would allow secret keys to be rotated regularly without sessions being invalidated.\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5621",
    "comments": [
      "Yeah, I think we could do something similar to itsdangerous here, with a new `OLD_SECRET_KEYS` config. Then `app.secret_key` remains a single value, and additional values can be added to the new config, and they can be sent to the itsdangerous mechanism. Note that `app.config` can't be mutated after startup (as it won't sync across each worker depending on how it's deployed), so updating the keys would require restarting the application.\r\n\r\n(Note: The previous issue was not auto closed, a maintainer closed it after deciding not to implement it at the time.)",
      "I'm uncertain about whether my suggested `SECRET_KEY` and `OLD_SECRET_KEYS` is a good interface. I don't have experience with key rotation systems. Can the way they return data be split into these two configs? Is restarting after rotation acceptable? Otherwise, users may be better served by implementing key rotation based on their own needs.",
      "https://adamj.eu/tech/2024/08/30/django-rotate-secret-key/ looks like Django uses a similar scheme, so I guess I'll go with that."
    ]
  },
  {
    "title": "Error: No such command 'db'.",
    "body": "\r\n[OJ.zip](https://github.com/user-attachments/files/17025798/OJ.zip)\r\n```\r\n(onlinejudge_env) kimi@KimideMacBook-Air OJ % flask db init\r\n\r\nError: While importing 'run', an ImportError was raised:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/kimi/OJ/onlinejudge_env/lib/python3.9/site-packages/flask/cli.py\", line 218, in locate_app\r\n    __import__(module_name)\r\n  File \"/Users/kimi/OJ/run.py\", line 3, in <module>\r\n    app = create_app()\r\n  File \"/Users/kimi/OJ/app/__init__.py\", line 25, in create_app\r\n    from app.auth import auth as auth_blueprint\r\n  File \"/Users/kimi/OJ/app/auth.py\", line 6, in <module>\r\n    from werkzeug.urls import url_parse\r\nImportError: cannot import name 'url_parse' from 'werkzeug.urls' (/Users/kimi/OJ/onlinejudge_env/lib/python3.9/site-packages/werkzeug/urls.py)\r\n\r\n\r\nUsage: flask [OPTIONS] COMMAND [ARGS]...\r\nTry 'flask --help' for help.\r\n\r\nError: No such command 'db'.\r\n(onlinejudge_env) kimi@KimideMacBook-Air OJ % \r\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5605",
    "comments": []
  },
  {
    "title": "Allow choice of reloader type",
    "body": "I know it was closed in #5007, but would it be possible to reconsider this? I'm having a lot of trouble with `watchdog` despite following all the fixes proposed  such as #2603. The reloader constantly detects spurious file changes, whereas I've never experienced such issues with `stat`. If you really dislike the idea of a new flag, maybe an environment variable would be an option?\r\n\r\nThanks a lot for the work on this awesome package!",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5598",
    "comments": [
      "My comment in https://github.com/pallets/flask/issues/5007#issuecomment-1450877246 still applies. The solution is to fix the reloader, not to provide a toggle that users shouldn't need. If you have an issue with the reloader, create a minimal reproducible example and report that to Werkzeug or Watchdog."
    ]
  },
  {
    "title": "`Config` `type: ignore` causing downstream error reports",
    "body": "The `# type: ignore` in the code here https://github.com/pallets/flask/blob/8a6cdf1e2a5efa81c30f6166602064ceefb0a35b/src/flask/config.py#L50\r\nis causing type errors to be reported in user code with pyright strict settings.\r\n\r\n```python\r\nfrom flask import Flask\r\n\r\n\r\nFlask(\"x\").config.update({\"A\": \"3\"})  # 'Type of \"update\" is partially unknown - reportUnknownMemberType'\r\n```\r\n\r\nBased on other typing in the same class, it looks like it could be:\r\n```python\r\nclass Config(dict[str, t.Any]):\r\n```\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.12\r\n- Flask version: 3.0.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5557",
    "comments": [
      "From what I've seen it's pretty much impossible for most libraries to support Pyright in strict mode, therefore it's not a goal. We pass MyPy in strict mode and Pyright in basic mode. That said, we're always open to PRs that improve the typing in a clear and maintainable way.\r\n\r\n`dict[]` is not valid at runtime until Python 3.9. We support Python 3.8 at minimum right now, until it goes EOL. So we'll be able to fix this in a few months, and will automatically know to do so when we run pyupgrade or bump the version checked by the tools.",
      "`class Config(t.Dict[str, t.Any]):`\r\nwould work in Python 3.8",
      "I don't think it's worth the churn if it will be changed again the release after. "
    ]
  },
  {
    "title": "Test failures in tutorial with python3.12",
    "body": "The tests runned with `pytest` works with python3.11 and not in 3.12:\r\n\r\nHow to reproduce:\r\n```\r\ngit clone git@github.com:pallets/flask.git\r\ncd flask/examples/tutorial\r\npython3.11 -m venv venv3.11\r\npython3.12 -m venv venv3.12\r\n# install dependencies\r\n# setup db\r\n```\r\nIn both cases, the webservice runs properly with `./venv3.1x/bin/flask --app flaskr run --debug`.\r\n\r\nHowever, running the tests show different results. In `venv3.11`, the 24 tests are green. In `venv3.12` virtualenv, there is 6 failures (and 18 green). The failures are due to a `DeprecationWarning` which becomes an error:\r\n```\r\nDeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes\r\n```\r\n\r\nThe full output is provided at the end of the bug report.\r\n\r\nThe `DeprecationWarning` is documented in the [3.12 release](https://docs.python.org/3/whatsnew/3.12.html): '[default adapters and converters](https://docs.python.org/3/library/sqlite3.html#sqlite3-default-converters) are now deprecated. Instead, use the [Adapter and converter recipes](https://docs.python.org/3/library/sqlite3.html#sqlite3-adapter-converter-recipes) and tailor them to your needs.' Copy-pasting blindly the recipes in `tests/conftest.py`, `flaskr/__init__.py` and `flaskr/db.py` does not fix the errors.\r\n\r\nThe errors can be fixed by adding thoses lines in conftest.py:\r\n```python\r\ndef convert_timestamp(val):\r\n    \"\"\"Convert Unix epoch timestamp to datetime.datetime object.\"\"\"\r\n    return datetime.datetime.strptime(val.decode(\"utf-8\"), \"%Y-%m-%d %H:%M:%S\").replace(tzinfo=datetime.timezone.utc)\r\n\r\nsqlite3.register_converter(\"timestamp\", convert_timestamp)\r\n```\r\n\r\nIt's probably not the best fix but it's a start.\r\n\r\n\r\nPytest output:\r\n\r\n```\r\n(venv3.12) $ ./venv3.12/bin/pytest\r\n========================================= test session starts ==========================================\r\nplatform linux -- Python 3.12.4, pytest-8.3.2, pluggy-1.5.0\r\nrootdir: /home/stephane/src/flasktuto/flask/examples/tutorial\r\nconfigfile: pyproject.toml\r\ntestpaths: tests\r\ncollected 24 items                                                                                     \r\n\r\ntests/test_auth.py ....F...                                                                      [ 33%]\r\ntests/test_blog.py F...F...F.FF                                                                  [ 83%]\r\ntests/test_db.py ..                                                                              [ 91%]\r\ntests/test_factory.py ..                                                                         [100%]\r\n\r\n=============================================== FAILURES ===============================================\r\n______________________________________________ test_login ______________________________________________\r\n\r\nclient = <FlaskClient <Flask 'flaskr'>>, auth = <conftest.AuthActions object at 0x7f297abc6900>\r\n\r\n    def test_login(client, auth):\r\n        # test that viewing the page renders without template errors\r\n        assert client.get(\"/auth/login\").status_code == 200\r\n    \r\n        # test that successful login redirects to the index page\r\n        response = auth.login()\r\n        assert response.headers[\"Location\"] == \"/\"\r\n    \r\n        # login request set the user_id in the session\r\n        # check that the user is loaded from the session\r\n        with client:\r\n>           client.get(\"/\")\r\n\r\ntests/test_auth.py:50: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1162: in get\r\n    return self.open(*args, **kw)\r\nvenv3.12/lib/python3.12/site-packages/flask/testing.py:235: in open\r\n    response = super().open(\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1116: in open\r\n    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app\r\n    rv = run_wsgi_app(self.application, environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app\r\n    app_rv = app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1498: in __call__\r\n    return self.wsgi_app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1476: in wsgi_app\r\n    response = self.handle_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1473: in wsgi_app\r\n    response = self.full_dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:882: in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:880: in full_dispatch_request\r\n    rv = self.dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:865: in dispatch_request\r\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\r\nflaskr/blog.py:24: in index\r\n    ).fetchall()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nval = b'2018-01-01 00:00:00'\r\n\r\n    def convert_timestamp(val):\r\n>       warn(msg.format(what=\"timestamp converter\"), DeprecationWarning, stacklevel=2)\r\nE       DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes\r\n\r\n/usr/lib/python3.12/sqlite3/dbapi2.py:76: DeprecationWarning\r\n______________________________________________ test_index ______________________________________________\r\n\r\nclient = <FlaskClient <Flask 'flaskr'>>, auth = <conftest.AuthActions object at 0x7f297ad26390>\r\n\r\n    def test_index(client, auth):\r\n>       response = client.get(\"/\")\r\n\r\ntests/test_blog.py:7: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1162: in get\r\n    return self.open(*args, **kw)\r\nvenv3.12/lib/python3.12/site-packages/flask/testing.py:235: in open\r\n    response = super().open(\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1116: in open\r\n    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app\r\n    rv = run_wsgi_app(self.application, environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app\r\n    app_rv = app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1498: in __call__\r\n    return self.wsgi_app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1476: in wsgi_app\r\n    response = self.handle_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1473: in wsgi_app\r\n    response = self.full_dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:882: in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:880: in full_dispatch_request\r\n    rv = self.dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:865: in dispatch_request\r\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\r\nflaskr/blog.py:24: in index\r\n    ).fetchall()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nval = b'2018-01-01 00:00:00'\r\n\r\n    def convert_timestamp(val):\r\n>       warn(msg.format(what=\"timestamp converter\"), DeprecationWarning, stacklevel=2)\r\nE       DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes\r\n\r\n/usr/lib/python3.12/sqlite3/dbapi2.py:76: DeprecationWarning\r\n_________________________________________ test_author_required _________________________________________\r\n\r\napp = <Flask 'flaskr'>, client = <FlaskClient <Flask 'flaskr'>>\r\nauth = <conftest.AuthActions object at 0x7f297ad3e210>\r\n\r\n    def test_author_required(app, client, auth):\r\n        # change the post author to another user\r\n        with app.app_context():\r\n            db = get_db()\r\n            db.execute(\"UPDATE post SET author_id = 2 WHERE id = 1\")\r\n            db.commit()\r\n    \r\n        auth.login()\r\n        # current user can't modify other user's post\r\n>       assert client.post(\"/1/update\").status_code == 403\r\n\r\ntests/test_blog.py:34: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1167: in post\r\n    return self.open(*args, **kw)\r\nvenv3.12/lib/python3.12/site-packages/flask/testing.py:235: in open\r\n    response = super().open(\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1116: in open\r\n    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app\r\n    rv = run_wsgi_app(self.application, environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app\r\n    app_rv = app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1498: in __call__\r\n    return self.wsgi_app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1476: in wsgi_app\r\n    response = self.handle_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1473: in wsgi_app\r\n    response = self.full_dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:882: in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:880: in full_dispatch_request\r\n    rv = self.dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:865: in dispatch_request\r\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\r\nflaskr/auth.py:27: in wrapped_view\r\n    return view(**kwargs)\r\nflaskr/blog.py:90: in update\r\n    post = get_post(id)\r\nflaskr/blog.py:48: in get_post\r\n    .fetchone()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nval = b'2018-01-01 00:00:00'\r\n\r\n    def convert_timestamp(val):\r\n>       warn(msg.format(what=\"timestamp converter\"), DeprecationWarning, stacklevel=2)\r\nE       DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes\r\n\r\n/usr/lib/python3.12/sqlite3/dbapi2.py:76: DeprecationWarning\r\n_____________________________________________ test_update ______________________________________________\r\n\r\nclient = <FlaskClient <Flask 'flaskr'>>, auth = <conftest.AuthActions object at 0x7f297abc7920>\r\napp = <Flask 'flaskr'>\r\n\r\n    def test_update(client, auth, app):\r\n        auth.login()\r\n>       assert client.get(\"/1/update\").status_code == 200\r\n\r\ntests/test_blog.py:59: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1162: in get\r\n    return self.open(*args, **kw)\r\nvenv3.12/lib/python3.12/site-packages/flask/testing.py:235: in open\r\n    response = super().open(\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1116: in open\r\n    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app\r\n    rv = run_wsgi_app(self.application, environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app\r\n    app_rv = app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1498: in __call__\r\n    return self.wsgi_app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1476: in wsgi_app\r\n    response = self.handle_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1473: in wsgi_app\r\n    response = self.full_dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:882: in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:880: in full_dispatch_request\r\n    rv = self.dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:865: in dispatch_request\r\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\r\nflaskr/auth.py:27: in wrapped_view\r\n    return view(**kwargs)\r\nflaskr/blog.py:90: in update\r\n    post = get_post(id)\r\nflaskr/blog.py:48: in get_post\r\n    .fetchone()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nval = b'2018-01-01 00:00:00'\r\n\r\n    def convert_timestamp(val):\r\n>       warn(msg.format(what=\"timestamp converter\"), DeprecationWarning, stacklevel=2)\r\nE       DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes\r\n\r\n/usr/lib/python3.12/sqlite3/dbapi2.py:76: DeprecationWarning\r\n________________________________ test_create_update_validate[/1/update] ________________________________\r\n\r\nclient = <FlaskClient <Flask 'flaskr'>>, auth = <conftest.AuthActions object at 0x7f297ace5160>\r\npath = '/1/update'\r\n\r\n    @pytest.mark.parametrize(\"path\", (\"/create\", \"/1/update\"))\r\n    def test_create_update_validate(client, auth, path):\r\n        auth.login()\r\n>       response = client.post(path, data={\"title\": \"\", \"body\": \"\"})\r\n\r\ntests/test_blog.py:71: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1167: in post\r\n    return self.open(*args, **kw)\r\nvenv3.12/lib/python3.12/site-packages/flask/testing.py:235: in open\r\n    response = super().open(\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1116: in open\r\n    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app\r\n    rv = run_wsgi_app(self.application, environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app\r\n    app_rv = app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1498: in __call__\r\n    return self.wsgi_app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1476: in wsgi_app\r\n    response = self.handle_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1473: in wsgi_app\r\n    response = self.full_dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:882: in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:880: in full_dispatch_request\r\n    rv = self.dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:865: in dispatch_request\r\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\r\nflaskr/auth.py:27: in wrapped_view\r\n    return view(**kwargs)\r\nflaskr/blog.py:90: in update\r\n    post = get_post(id)\r\nflaskr/blog.py:48: in get_post\r\n    .fetchone()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nval = b'2018-01-01 00:00:00'\r\n\r\n    def convert_timestamp(val):\r\n>       warn(msg.format(what=\"timestamp converter\"), DeprecationWarning, stacklevel=2)\r\nE       DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes\r\n\r\n/usr/lib/python3.12/sqlite3/dbapi2.py:76: DeprecationWarning\r\n_____________________________________________ test_delete ______________________________________________\r\n\r\nclient = <FlaskClient <Flask 'flaskr'>>, auth = <conftest.AuthActions object at 0x7f297ada5610>\r\napp = <Flask 'flaskr'>\r\n\r\n    def test_delete(client, auth, app):\r\n        auth.login()\r\n>       response = client.post(\"/1/delete\")\r\n\r\ntests/test_blog.py:77: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1167: in post\r\n    return self.open(*args, **kw)\r\nvenv3.12/lib/python3.12/site-packages/flask/testing.py:235: in open\r\n    response = super().open(\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1116: in open\r\n    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app\r\n    rv = run_wsgi_app(self.application, environ, buffered=buffered)\r\nvenv3.12/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app\r\n    app_rv = app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1498: in __call__\r\n    return self.wsgi_app(environ, start_response)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1476: in wsgi_app\r\n    response = self.handle_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:1473: in wsgi_app\r\n    response = self.full_dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:882: in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:880: in full_dispatch_request\r\n    rv = self.dispatch_request()\r\nvenv3.12/lib/python3.12/site-packages/flask/app.py:865: in dispatch_request\r\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\r\nflaskr/auth.py:27: in wrapped_view\r\n    return view(**kwargs)\r\nflaskr/blog.py:121: in delete\r\n    get_post(id)\r\nflaskr/blog.py:48: in get_post\r\n    .fetchone()\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nval = b'2018-01-01 00:00:00'\r\n\r\n    def convert_timestamp(val):\r\n>       warn(msg.format(what=\"timestamp converter\"), DeprecationWarning, stacklevel=2)\r\nE       DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes\r\n\r\n/usr/lib/python3.12/sqlite3/dbapi2.py:76: DeprecationWarning\r\n======================================= short test summary info ========================================\r\nFAILED tests/test_auth.py::test_login - DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite...\r\nFAILED tests/test_blog.py::test_index - DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite...\r\nFAILED tests/test_blog.py::test_author_required - DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite...\r\nFAILED tests/test_blog.py::test_update - DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite...\r\nFAILED tests/test_blog.py::test_create_update_validate[/1/update] - DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite...\r\nFAILED tests/test_blog.py::test_delete - DeprecationWarning: The default timestamp converter is deprecated as of Python 3.12; see the sqlite...\r\n===================================== 6 failed, 18 passed in 8.05s =====================================\r\n\r\n``\r\n\r\n",
    "labels": [
      "docs"
    ],
    "url": "https://github.com/pallets/flask/issues/5556",
    "comments": [
      "For info, the tests with python3.11 are still green with the dirty patch.",
      "Trying to write aware datetime by converting the datetime inside the SQL request fails. For example, in [`blog.index()` function](https://github.com/pallets/flask/blob/f93dd6e826a9bf00bf9e08d9bb3a03abcb1e974c/examples/tutorial/flaskr/blog.py#L17):\r\n\r\n```python\r\n    posts = db.execute(\r\n        \"SELECT p.id, title, body, datetime(p.created, 'localtime'), author_id, username\"\r\n        \" FROM post p JOIN user u ON p.author_id = u.id\"\r\n        \" ORDER BY datetime(p.created, 'localtime') DESC\"\r\n    ).fetchall()\r\n```\r\n\r\nit fails because the key `created` in `post` items is replaced by the key `datetime(p.created, 'localtime')`.\r\n\r\nI think the right way is to use a convert function like in the first post (and in the documentation). However, it would be better to reuse the local time instead of forcing to UTC.",
      "I see you've been working on this issue, and I\u2019d like to contribute if there's any part I can help with. Have you made any progress, or is there a specific task I can assist with?",
      "I think the next step is to write a PR with a convert function providing the local timezone.\r\nFeel free to do it if you want: I'm currently on another topic so, perhaps you can do it before I will be back on this issue.",
      "By adding a default converter in the `db.py`, based on initial example and linked recipes, all tests pass in both venv3.11 venv3.12 using the following:\r\n```\r\ndef convert_timestamp(val):\r\n    return datetime.datetime.fromisoformat(val.decode())\r\n\r\ndef  get_db():\r\n    if \"db\" not in g:\r\n        sqlite3.register_converter(\"timestamp\", convert_timestamp)\r\n        ...\r\n```\r\nThe `convert_timestamp` could apply `astimezone(tz)` with an optional `tz=None` but figured that may be out of scope for the tutorial. Otherwise, it works with `fromisoformat(val.decode())`",
      "```\r\nthis small code change fix my issue :\r\nfile one change: /examples/tutorial/run_tests.py\r\n@@ -0,0 +1,5 @@\r\n+import unittest\r\n\r\n+if __name__ == \"__main__\":\r\n+    testsuite = unittest.TestLoader().discover('tests')\r\n+    unittest.TextTestRunner(verbosity=1).run(testsuite)\r\n\r\nfile two  change: /examples/tutorial/tests/conftest.py\r\n@@ -1,13 +1,22 @@\r\n import os\r\n import tempfile\r\n-\r\n import pytest\r\n+import sqlite3\r\n+import datetime\r\n \r\n from flaskr import create_app\r\n from flaskr.db import get_db\r\n from flaskr.db import init_db\r\n \r\n+# Register a custom converter for timestamps\r\n+def convert_timestamp(val):\r\n+    \"\"\"Convert Unix epoch timestamp to datetime.datetime object.\"\"\"\r\n+    return datetime.datetime.strptime(val.decode(\"utf-8\"), \"%Y-%m-%d %H:%M:%S\").replace(tzinfo=datetime.timezone.utc)\r\n+\r\n+sqlite3.register_converter(\"timestamp\", convert_timestamp)\r\n+\r\n # read in SQL for populating test data\r\n+\r\n with open(os.path.join(os.path.dirname(__file__), \"data.sql\"), \"rb\") as f:\r\n     _data_sql = f.read().decode(\"utf8\")\r\n```\r\n\r\n\r\n\r\n",
      "I suggest you to send a PR so the maintainers can check it and accept it directly if they agree with the patch.\r\nI advise you to add a link to this issue so they can read the analysis."
    ]
  },
  {
    "title": "test_helpers.py.test_open_resource_with_encoding function attribute error",
    "body": "the function test_open_resource_with_encoding, sends encoding arguemnt to app.open_resource() function. the open_resource function doesnt has any enoding parameter in it's signature.\r\n\r\n- Python version: 3.11.5\r\n\r\n- Flask version: current\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5554",
    "comments": [
      "All test pass locally for me and in CI.",
      "To further elaborate \n\nhttps://github.com/pallets/flask/blob/main/src%2Fflask%2Fapp.py#L323-L325\n\nHas the parameters"
    ]
  },
  {
    "title": "Revisit SERVER_NAME's impact on routing and external URL generation",
    "body": "#998 was a discussion regarding the impact the `SERVER_NAME` setting has on an application.  IMO, there was consensus in that issue, including by @mitsuhiko, that `SERVER_NAME` being used both in routing and in URL generation was problematic.  \r\n\r\nThat issue was closed by https://github.com/pallets/flask/pull/2635, which made a change regarding subdomain matching.  However, IMO, it did not address the fundamental problem of `SERVER_NAME` impacting two disparate mechanisms in Flask.\r\n\r\nI found two additional issues since #998 that have attempted to point out the problem with `SERVER_NAME`: #2813, #3465\r\n\r\nIn #2813, a minimal, complete, and verifiable example was requested and I have therefore prepared an [example gist that demonstrates the problem](https://gist.github.com/rsyring/c50a500a5d35787ef45c1ff1e78d8898).\r\n\r\nThe gist's third \"currently impossible\" test demonstrates that it's currently impossible to:\r\n\r\n* Set `SERVER_NAME` so external URL generation works outside a request context with only an app context; and\r\n* Have the app respond properly to multiple host names. \r\n\r\nMy particular use case currently is that I need `SERVER_NAME` set so external URLs will be created accurately in distributed tasks where no web request is present.  Additionally, I need the app to respond to multiple host names 1) the canonical URL the public uses; and 2) the IP address based URL our load balancer uses for health checks.\r\n\r\nIMO, `SERVER_NAME` should be deprecated and two new settings should be created.  One which affects external URL generation and a second that affects routing resolution.\r\n\r\nThe setting for the URL generation could be `CANONICAL_URL` and, because its a URL, it could eliminate the need for `url_for()`'s `_scheme` arg.\r\n\r\nThanks for your consideration.\r\n\r\n- Python version: 3.12\r\n- Flask version: 3.0.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5553",
    "comments": [
      "We should expose Werkzeug's trusted host checking, with a new `ALLOWED_HOSTS = []` config to match [Django's](https://docs.djangoproject.com/en/5.0/ref/settings/#allowed-hosts). This is similar to what we recently did for the dev server debugger.\r\n\r\nI don't think we need to deprecate `SERVER_NAME`. If it's set, it's added to `ALLOWED_HOSTS`, otherwise behavior stays the same.\r\n\r\n> it could eliminate the need for `url_for()`'s `_scheme` arg.\r\n\r\nThis is already covered by `PREFERRED_URL_SCHEME`. If we were to deprecate `SERVER_NAME`, I'd rename it to `PREFERRED_URL_HOST` or something, but I think it's fine to leave it.",
      "David, thanks for chiming in.  \r\n\r\nI think `SERVER_NAME` still remains problematic:\r\n\r\n1. `SERVER_NAME` still affects two disparate parts of the system.  If all I want to do is configure the external URL used by `url_for()`, I can't do that without affecting routing or host checking.  I should be able to set them separately.  This becomes a practical problem in the case of...\r\n2. What if I don't know all of the hosts that I want to allow?  Maybe I'm serving up marketing content on multiple domains and non-technical people are creating names for SSO reasons.  Maybe, as is my case, the load balancer is going to use different IPs every time I deploy the app (aws copilot/cloud formation).  Or, if I have multiple processes/containers running, there will be multiple IPs that need to be valid but I don't know what they are. \r\n\r\nDjango doesn't seem to handle the unkown IP case natively: [SO discussion ](https://stackoverflow.com/questions/37031749/django-allowed-hosts-ips-range)and https://pypi.org/project/django-allow-cidr/\r\n\r\nI don't know much about how Flask handles subodmains but noting it here in case it should impact the discussion.\r\n\r\nThanks.",
      "I'm hesitant to deprecate/rename `SERVER_NAME`. Adjusting what I suggested above, if `SERVER_NAME` is set and `ALLOWED_HOSTS` is empty, then behavior remains the same by setting `ALLOWED_HOSTS = [SERVER_NAME]` automatically. But if `ALLOWED_HOSTS` is set, `SERVER_NAME` is not automatically added. So you can get the new behavior by setting both config keys, but nothing changes if you keep your config the same. Does that sound reasonable?",
      "That would at least facilitate my objective of setting the external URL without affecting `ALLOWED_HOSTS` as, presumably, I can use `ALLOWED_HOSTS = ['*']`.\r\n\r\nBut I'd point out that someone who just wants to set `SERVER_NAME` for the external URL is also getting a completely separate functionality applied, by default.  In a way that is implicit rather than explicit.  They then have to go explicitly \"undo\" that implicit application of allowed hosts.  At the very least, the documentation should be really clear about how `SERVER_URL` impacts `ALLOWED_HOSTS` and how to undo that if desired.\r\n\r\n`PREFERRED_URL_SCHEME` also seems problematic TBH.  Unless I'm misunderstanding, it's a workaround for `SERVER_NAME` doing double-duty.  If we had two separate settings, then one should just be `EXTERNAL_HOST_URL` (or whatever you want to name it) and then you don't need `PREFERRED_URL_SCHEME`?\r\n\r\nCreating two separate configs, one for each purpose, still makes the most sense to me.  There is already consensus in #998 that the one setting is problematic.  Why not fix the root cause?\r\n\r\nRegardless, I'd be happy for any way to fix this in the Flask config as the workaround I use is ugly. \r\n\r\nThanks.  :)",
      "Regarding a combined single config key:\r\n\r\nWe have three configs that affect routing and URL generation.\r\n\r\n- `PREFERRED_URL_SCHEME` defaults to `http`.\r\n- `SERVER_NAME` is unset.\r\n- `APPLICATION_ROOT` defaults to `/`.\r\n\r\nAll three are needed to generate URLs outside a request. `APPLICATION_ROOT` is needed during requests as well, to know what part of the path is the prefix from the server and what part is handled by the app.\r\n\r\nWe could have a `DEFAULT_BASE_URL` like `https://example.com:56374/root`. The problem is `APPLICATION_ROOT`, for WSGI there's no way to know when app setup is finished and when requests handling will start, so there's no way to say \"now we know all config has been loaded, set `APPLICATION_ROOT` from `DEFAULT_BASE_URL` if needed, then pass the app on to start serving\". We would want to split it during config though, otherwise we'd need to call `urlsplit(DEFAULT_BASE_URL).path` for every request, which would be expensive. The other parts only need to be split when generating URLs outside a request, so that expense isn't important then.",
      "To recap, with the `ALLOWED_HOSTS` proposal, here are the configuration items that are present in this discussion:\r\n\r\n- `PREFERRED_URL_SCHEME`\r\n  - Only used for external URL generation\r\n- `SERVER_NAME`\r\n  - For external URL generation\r\n  - For sub-domain route matching\r\n  - Sets a default for `ALLOWED_HOSTS`\r\n- `APPLICATION_ROOT`\r\n- `ALLOWED_HOSTS`\r\n  - Presumably defaults to `['*']` \r\n  - Might be set implicitly by `SERVER_NAME`\r\n\r\nAs a thought experiment, if starting from scratch, it seems more intuitive to me if this was broken out as:\r\n\r\n- Note: proposed config names are only representative\r\n- `HOST_URL`: it's purpose is to impact request routing, although reasonable defaults can be inferred for non-routing functionality\r\n  - Defaults to `/` which would keep the current Flask behavior for a non-configured application\r\n  - The path portion (`/` or `/foo`) is used for what is now `APPLICATION_ROOT`\r\n  - If more than a path, then it must be a full URL, `https://www.foo.com/bar` and impacts:\r\n    - Sub-domain route matching presuming that, in the example above, `www.foo.name` is the base if a subdomain is given by a route or blueprint.  In most typical cases, the app would likely use `https://foo.name/` if using subdomains.\r\n    - Sets a default for `HOST_URL_EXTERNAL`\r\n    - Maybe sets a default for `ALLOWED_HOSTS`?   IMO, this is determined by whether or not we want to encourage it being used for security reasons.\r\n- `HOST_URL_EXTERNAL` (or maybe `APPLICATION_URL`): it's only purpose is external URL generation\r\n  - Defaults to `None`, must be a full URL, `https://www.baz.com/bar`\r\n  - Can be set when `HOST_URL` isn't to configure only how external URLs are generated and not impact request routing\r\n  - Can also be set if, for some reason, the default from `HOST_URL` is not accurate.  As in the case that started this issue for me where the internal host name is different from the external URL.\r\n- `HOSTS_ALLOWED`: same as `ALLOWED_HOSTS` but, by naming, keeps these three configs  named similar since they are related(ish)\r\n  - Django requires this value to be explicitly set, presumably for security reasons.\r\n  - Would Flask do similar or keep the default of no limitations?  IMO, that impacts whether or not `HOST_URL` impacts the default of this config item.\r\n\r\nWe obviously are not starting from scratch, but that is still, IMO, the way the functionality most obviously groups together when thinking through the configuration.\r\n\r\nFrom an implementation perspective, I don't know if it's better to keep all the old settings as individual config items or deprecate them.  I'd likely lean in favor of the latter since I think the current ones grew over time into a bit of an ugly knot.    But, if not wanting to deprecate as you've seemed to indicate, then you could arguably split `HOST_URL` into the various components and set the existing config values from it.  Although, in that case, I'd adjust external URL generation to solely pull from `HOST_URL_EXTERNAL` instead of being pieced together from the configuration items that should only affect request routing, IMO.\r\n\r\nCould also not set any defaults from `HOST_URL` and make everything more explicit.  I think that just depends on how Flask leans in terms of \"user friendly\" vs \"explicit is better than implicit.\"  Given that it's very easy to do:\r\n\r\n```\r\nHOST_URL = 'https://foo.bar/baz'\r\napp = Flask()\r\napp.config['HOST_URL'] = HOST_URL\r\napp.config['HOST_URL_EXTERNAL'] = HOST_URL\r\napp.config['HOSTS_ALLOWED'] = ['foo.bar']\r\n```\r\n\r\nAnd that doesn't require any parsing of the URL to get the bare host for `HOSTS_ALLOWED`, I'd lean towards everything being explicit.\r\n\r\n> We could have a DEFAULT_BASE_URL like https://example.com:56374/root. The problem is APPLICATION_ROOT, for WSGI there's no way to know when app setup is finished and when requests handling will start...\r\n\r\nTwo options I see:\r\n\r\n- Customize the config to parse `HOST_URL`  any time it's set and distribute the values to other configuration items immediately.  It would be a special handling of that one value which may or may not be that big of a deal.\r\n- Make it a keyword arg of `Flask` instead of a configuration value, just like some of the other \"core\" params that get set that way.  Parse it out during init and apply to the configuration as defaults.\r\n",
      "Thanks for the analysis and writeup, I was trying to do something similar and ran out of steam. I'll think about the exact path forward, but I'm marking it for 3.1.",
      "I'm struggling to figure out why Werkzeug's [`Map.bind_to_environ`](https://werkzeug.palletsprojects.com/en/stable/routing/#werkzeug.routing.Map.bind_to_environ) handles `server_name` the way it does.\r\n\r\n> Note that because of limitations in the protocol there is no way to get the current subdomain and real `server_name` from the environment. If you don\u2019t provide it, Werkzeug will use `SERVER_NAME` and `SERVER_PORT` (or `HTTP_HOST` if provided) as used `server_name` with disabled subdomain feature.\r\n> \r\n> If `subdomain` is `None` but an environment and a server name is provided it will calculate the current subdomain automatically. Example: `server_name` is `'example.com'` and the `SERVER_NAME` in the wsgi `environ` is `'staging.dev.example.com'` the calculated subdomain will be `'staging.dev'`.\r\n\r\nThe end of the first paragraph has a confusing grammatical typo (\"will use ... as used\"), so I can't be sure of the intention. Not sure what \"as\" was supposed to say.\r\n\r\nhttps://github.com/pallets/werkzeug/blob/7868bef5d978093a8baa0784464ebe5d775ae92a/src/werkzeug/routing/map.py#L321-L339\r\n\r\nLooking at the way Flask calls this, `subdomain` is always `None`, and `host_matching` is not used by default. So if `SERVER_NAME` is set, it will always be required to match, otherwise a warning is shown and a 404 is returned. The quick answer here is to never pass `server_name`, but why is that even a behavior? Why is that not handled by `allowed_hosts` later on?\r\n\r\nIt seems to be saying \"if the subdomain wasn't given, try to get it from the host header as a prefix of the name the WSGI server is bound to\", which does make sense. But also \"if I can't get a prefix, then don't even try to route\", but routing would still work fine if it assumed the empty prefix, as if the host exactly matched the server's name.",
      "There's also the `subdomain_matching` parameter to `Flask`, which defaults to `False`. And the `app.url_map.default_subdomain` value, which is unset by default. For some reason, Werkzeug's `Map` doesn't account for `default_subdomain` in `bind_to_environ`, only `bind`. And Flask sets `subdomain = self.url_map.default_subdomain or None`, so only if it's truthy. But `\"\"` as the default subdomain totally works. If I remove the `or None` and set `url_map.default_subdomain = '\"` and `SERVER_NAME = \"abc.localhost:5000`, URL generation works and any domain or IP works. It's still a problem that there's this many parts, many undocumented, but it can work today.\r\n\r\n```python\r\nfrom flask import Flask, request, url_for\r\n\r\napp = Flask(__name__)\r\napp.config[\"SERVER_NAME\"] = \"example.com:5000\"\r\napp.url_map.default_subdomain = \"\"  # and patch out the `or None`\r\n\r\n@app.get(\"/\")\r\ndef index() -> str:\r\n    return url_for(\"index\", _external=True)\r\n```",
      "`SERVER_NAME` does have a routing purpose in this case, without interfering: it allows determining the subdomain by comparing `Host` to `SERVER_NAME`. For example, if `Host = \"a.b.example.com\"` and `SERVER_NAME = \"example.com\"`, remove `SERVER_NAME` as a suffix and you get `subdomain = \"a.b\"`. If you wanted to route beyond that, you'd either need to enable full `host_matching` instead of subdomain matching, and/or redirect alias domains to the configured default name.",
      "Yeah, I'm starting to see how this makes sense now. I think the entire problem is the `or None` here: https://github.com/pallets/flask/blob/07c7d5730a2685ef2281cc635e289685e5c3d478/src/flask/app.py#L442-L451\r\n\r\nIf that's fixed, then:\r\n\r\n* With `subdomain_matching` and `host_matching` disabled (the default), all hosts are accepted and don't affect routing.\r\n* `SERVER_NAME` doesn't affect routing unless it's a suffix of the host for determining the subdomain.\r\n* If `subdomain_matching` is enabled, it makes sense that hosts that didn't have `SERVER_NAME` as a suffix wouldn't route, there's no subdomain to determine.\r\n    * Or Werkzeug could also be changed to use `default_subdomain` in that case, although the correctness of that is debatable.\r\n* If `host_matching` is enabled, the subdomain doesn't matter and none of this applies anyway.\r\n\r\nSo I think `Flask.__init__` needs:\r\n\r\n```python\r\nif not subdomain_matching:\r\n    url_map.default_subdomain = \"\"\r\n```\r\n\r\nAnd `Flask.create_url_adapter` removes the `or None`. And we also expose a new `ALLOWED_HOSTS` config so that we _can_ restrict the hosts still.\r\n\r\nLonger term, Werkzeug 3.2 can add `Map.subdomain_matching` and adjust the behavior of `Map.bind_to_environ` a bit. But 3.1 just came out, so that will have to wait a bit.",
      "The change was slightly different than what I guessed above, but after some more testing, I'm convinced that's the right fix now. It seems to be what was intended in #2635. This whole thing, `host_matching`, `subdomain_matching`, and `SERVER_NAME` is really not easy to keep track of, and I clearly was misinterpreting it over the years.\r\n\r\nIt's not helped by the number of configurations in Werkzeug's routing:\r\n\r\n* `host_matching` and `subdomain_matching` can both be enabled (`subdomain_matching` is implemented in Flask, not Werkzeug), but `host_matching` takes priority in `MapAdapter`.\r\n* Passing `subdomain` to `Map.bind` when `host_matching` is enabled is an error. So it doesn't matter that `host_matching` takes priority in `MapAdapter`.\r\n* `Rule` (from `@route` or `add_url_rule`) can take both a `subdomain` and `host` pattern. Neither is used unless the corresponding `x_matching` is enabled, so they just invisibly don't work if you don't remember to set it in both places, or if you set the wrong one. And again, `host_matching` takes priority in case both are set, again invisibly.\r\n\r\nI'm not clear what of this can be fixed or warned about, or even if it should be. Something to think about when moving `subdomain_matching` out of Flask and into Werkzeug 3.2 eventually."
    ]
  },
  {
    "title": "Pyright Type Errors",
    "body": "We have a number of various Pyright typing errors.\r\n\r\nEnvironment:\r\n\r\n- Python version: `3.12`\r\n- Flask version: `3.1.0`\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5549",
    "comments": [
      "fixed in #5620 "
    ]
  },
  {
    "title": "Pyright type errors: `src/flask/helpers.py`",
    "body": "Pyright reports type errors for `src/flask/helpers.py`:\r\n\r\n```\r\nflask/src/flask/helpers.py\r\n  flask/src/flask/helpers.py:590:27 - error: Cannot access attribute \"get_filename\" for class \"Loader\"\r\n  \u00a0\u00a0Attribute \"get_filename\" is unknown (reportAttributeAccessIssue)\r\n```\r\n\r\nCommand which was run:\r\n\r\n```shell\r\n.venv/bin/pyright --pythonpath .venv/bin/python3 --project pyproject.toml\r\n```\r\n\r\nEnvironment:\r\n\r\n- Python version: `3.12`\r\n- Flask version: `3.1.0`\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5547",
    "comments": []
  },
  {
    "title": "Pyright type errors: `src/flask/blueprint.py`",
    "body": "Pyright reports type errors for `src/flask/blueprint.py`:\r\n\r\n```\r\nflask/src/flask/blueprints.py\r\n  flask/src/flask/blueprints.py:126:20 - error: Expression of type \"BufferedReader\" is incompatible with return type \"IO[AnyStr@open_resource]\"\r\n  \u00a0\u00a0\"BufferedReader\" is incompatible with \"IO[AnyStr@open_resource]\"\r\n  \u00a0\u00a0\u00a0\u00a0Type parameter \"AnyStr@IO\" is invariant, but \"bytes\" is not the same as \"AnyStr@open_resource\" (reportReturnType)\r\n```\r\n\r\nCommand which was run:\r\n\r\n```shell\r\n.venv/bin/pyright --pythonpath .venv/bin/python3 --project pyproject.toml\r\n```\r\n\r\nEnvironment:\r\n\r\n- Python version: `3.12`\r\n- Flask version: `3.1.0`\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5545",
    "comments": []
  },
  {
    "title": "Pyright type errors: `src/flask/app.py`",
    "body": "Pyright reports type errors for `src/flask/app.py`:\r\n\r\n```\r\nflask/src/flask/app.py\r\n  flask/src/flask/app.py:352:20 - error: Expression of type \"BufferedReader\" is incompatible with return type \"IO[AnyStr@open_resource]\"\r\n  \u00a0\u00a0\"BufferedReader\" is incompatible with \"IO[AnyStr@open_resource]\"\r\n  \u00a0\u00a0\u00a0\u00a0Type parameter \"AnyStr@IO\" is invariant, but \"bytes\" is not the same as \"AnyStr@open_resource\" (reportReturnType)\r\n  flask/src/flask/app.py:1178:21 - error: Expression with type \"Tuple[ResponseValue, HeadersValue] | Tuple[ResponseValue, int] | Tuple[ResponseValue, int, HeadersValue]\" cannot be assigned to target tuple\r\n  \u00a0\u00a0Type \"Tuple[ResponseValue, int, HeadersValue]\" is incompatible with target tuple\r\n  \u00a0\u00a0\u00a0\u00a0Tuple size mismatch; expected 2 but received 3 (reportAssignmentType)\r\n  flask/src/flask/app.py:1205:28 - error: Argument of type \"HeadersValue | int | None\" cannot be assigned to parameter \"status\" of type \"int | str | HTTPStatus | None\" in function \"__init__\" (reportArgumentType)\r\n  flask/src/flask/app.py:1240:29 - error: Cannot assign to attribute \"status\" for class \"Response\" (reportAttributeAccessIssue)\r\n  flask/src/flask/app.py:1242:34 - error: Cannot assign to attribute \"status_code\" for class \"Response\"\r\n  \u00a0\u00a0Type \"HeadersValue | int\" is incompatible with type \"int\"\r\n  \u00a0\u00a0\u00a0\u00a0\"Mapping[str, HeaderValue]\" is incompatible with \"int\" (reportAttributeAccessIssue)\r\n```\r\n\r\nCommand which was run:\r\n\r\n```shell\r\nsource .venv/bin/activate\r\npyright\r\n```\r\n\r\nEnvironment:\r\n\r\n- Python version: `3.12`\r\n- Flask version: `3.1.0`\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5543",
    "comments": [
      "Thanks for checking this and submitting a fix!\r\n\r\nNo need to report separate issues for each file. You can report and fix errors all in one go.\r\n\r\nWhy did you run the command like that as opposed to running the plain `pyright` command in the project? It should automatically use the venv and pyproject config.",
      "Hi @davidism :\r\n\r\n> Thanks for checking this and submitting a fix!\r\n\r\nYes and thank you for everything you do on Flask. It's been on my todo for a long time to help out more with the project.\r\n\r\n> No need to report separate issues for each file. You can report and fix errors all in one go.\r\n\r\nWould you prefer that I combine those PRs?\r\n\r\n> Why did you run the command like that as opposed to running the plain `pyright` command in the project? It should automatically use the venv and pyproject config.\r\n\r\nGood point. I was running it without activating the virtualenv. I will update the description to make it more idiomatic.",
      "Yes, please report a single issue and make a single PR. \"Fix pyright findings\" is fine. You can split it into multiple commits if you think it makes fixing/reviewing easier."
    ]
  },
  {
    "title": "`pyright` type checking seems to be unused. `mypy` still being used.",
    "body": "We added `pyright` in 3.0.3 (see: https://github.com/pallets/flask/pull/5457), but `mypy` is still being used for type checking https://github.com/pallets/flask/blob/main/tox.ini#L29-L32, and `pyright` is not.\r\n\r\nIf this was an intentional change of type checkers, then would expect that `mypy` be completely removed, and `pyright` be the command run in `tox typing`.\r\n\r\nIt should be noted, however, that running `pyright` yields 90 errors (71 tests/19 src). Is there an upgrade path or was this an oversight?\r\n\r\nEnvironment:\r\n\r\n- Python version:\r\n- 3.12\r\n- Flask version:\r\n- 3.0.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5537",
    "comments": [
      "fixed in #5620 "
    ]
  },
  {
    "title": "Encountering Jinja2 SyntaxError after adding another css file",
    "body": "I've been encountering this confusing error; which is Jinja2.exceptions.TemplateSyntaxError: expected token ',', got 'string'.\r\nThis only happened after I added another css file to my html script. But previously, it worked fine. \r\n\r\nHere are the previous errors i've encountered regarding this issue:\r\n\r\n```\r\n<link rel=\"icon\" href=\"{{ url_for('static', filename='images/favicon.png') }}\">\r\njinja2.exceptions.TemplateSyntaxError: expected token ',', got 'static'\r\n    <li onclick=\"redirectUser('/homepage')\">Home</li>\r\njinja2.exceptions.TemplateSyntaxError: expected token ',', got 'string'\r\n```\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.12.4\r\n- Flask version: 3.0.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5530",
    "comments": [
      "Show the full template. Also double-check that you don't have e.g. typographical quotes instead of the standard `'`. Maybe you didn't properly close some previous Jinja tag?"
    ]
  },
  {
    "title": "\"catch-all\" endpoint doesn't work with `static_url_path=\"/\"`",
    "body": "### Catch all endpoint for SPA from [docs](https://flask.palletsprojects.com/en/2.2.x/patterns/singlepageapplications/) doesn't work with `static_url_path=\"/\"` or `static_url_path=\"\"`\r\n\r\n### Context\r\n\r\nI'm using Flask to serve React SPA with client-side routing. \r\nFlask worked perfectly, until I added images and decided to serve it from `static/` folder.\r\n\r\n### Expected:\r\n\r\nI can serve images from `static/` folder. \r\nI can reload a non-root page and Flask won't respond with `404 Not Found`.\r\n\r\n### Current:\r\n\r\nI can navigate to `/path` or `/path1/path2` and etc. with no problems, but when I reload any non-root page the Flask gives me `404 Not Found` and the catch-all route didn't trigger.\r\n\r\n\r\n### Example:\r\n\r\n**`folder structure`**\r\n```\r\n.\r\n\u251c\u2500\u2500 __init__.py\r\n\u2514\u2500\u2500 main/\r\n    \u251c\u2500\u2500 static/\r\n    \u2502   \u251c\u2500\u2500 image1.jpg\r\n    \u2502   \u251c\u2500\u2500 image2.jpg\r\n    \u2502   \u251c\u2500\u2500 index.html\r\n    \u2502   \u2514\u2500\u2500 main.js\r\n    \u251c\u2500\u2500 __init__.py\r\n    \u2514\u2500\u2500 routes.py\r\n```\r\n\r\n**`./__init__.py`**\r\n```python\r\ndef create_app(config_class=Config) -> Flask:\r\n  app = Flask(__name__)\r\n  from .main import bp as main_bp\r\n  app.register_blueprint(main_bp)\r\n  return app\r\n```\r\n\r\n**`./main/__init__.py`**\r\n```python\r\nfrom flask import Blueprint\r\n\r\nbp = Blueprint(\"main\", __name__, static_folder=\"static\", static_url_path=\"/\")\r\n\r\nfrom .main import routes\r\n``` \r\n\r\n**`./main/routes.py`**\r\n```python\r\nfrom .main import bp\r\n\r\n@bp.route(\"/\", defaults={\"path\": \"\"})\r\n@bp.route(\"/<path:path>\")\r\ndef catch_all(path):\r\n    return bp.send_static_file(\"index.html\")\r\n```\r\n\r\n### Error message\r\n\r\n```\r\n<!doctype html>\r\n<html lang=en>\r\n<title>404 Not Found</title>\r\n<h1>Not Found</h1>\r\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\r\n```\r\n\r\nEnvironment:\r\n\r\n- Python version: `Python 3.9.2`\r\n- Flask version: `Flask 2.2.5`\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5527",
    "comments": [
      "The `static` route is a catch-all path, it matches all paths below it. You need a prefix like `/static` to distinguish it if you have another top-level catch-all path."
    ]
  },
  {
    "title": "Update Werkzeug to 3.0.3",
    "body": "Update Werkzeug to 3.0.3 to address vulnerability found in Werkzeug debugger.\r\nhttps://werkzeug.palletsprojects.com/en/3.0.x/changes/\r\n\r\nUpdating Werkzeug to version 3.0.3 fixes the debugger vulnerability.\r\n\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5523",
    "comments": [
      "That's something you do in your application, this is a minimum supported version."
    ]
  },
  {
    "title": "false redirect from /name to /name/ causes 404",
    "body": "<!--\r\nroute name redirects to /name/ when the canonical name is /name\r\nthis causes the page to be 404 Not Found, since when using /name as a canonical name, / isn't avaliable\r\n-->\r\n\r\n<!--\r\nhow to replicate:\r\ndownload flask on ubuntu 24.04 using the command:\r\nsudo apt install python3-flask\r\n\r\nrun the code from the terminal:\r\nflask --app my_app run --debug\r\nin this order:\r\n1). first using @app.route(\"/hello\")\r\n2). then using @app.route(\"/hello/\")\r\n3). then using @app.route(\"/hello\")\r\nthe page should now autocomplete /hello to /hello/\r\n\r\nexample end code picture: \r\n![Screenshot from 2024-07-08 22-01-58](https://github.com/pallets/flask/assets/87893493/1a91c062-4739-497d-8446-32089db91017)\r\n-->\r\n\r\n<!--\r\nafter changing back the code to @app.route(\"/name\") the code should have not autocompleted the url to /name/\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.12.3\r\n- Flask version: 3.0.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5521",
    "comments": [
      "Your browser may have a previous redirect cached, try clearing the cache. That's just a guess, as you haven't provided a minimal reproducible example demonstrating the issue."
    ]
  },
  {
    "title": "Flask incorrectly parses chained query parameters ",
    "body": "When accessing the /test route with both category and location query parameters (http://localhost:5000/test?category=fish&location=water), Flask correctly parses category but ignores location.\r\n\r\n### Steps to Reproduce\r\nAccess the URL http://localhost:5000/test?category=fish&location=water.\r\nExpected behavior: Both category and location parameters should be correctly parsed by Flask.\r\nActual behavior: Flask parses category correctly (\"excavator\"), but location is ignored.\r\n\r\n```(python)\r\nfrom flask import Flask, request, jsonify\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\"/test\")\r\ndef test():\r\n    category = request.args.get(\"category\")\r\n    location = request.args.get(\"location\")\r\n    return {\"category\": category, \"location\": location}\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug=True)\r\n```\r\n\r\nExpected:\r\n```(json)\r\n{\r\n    \"category\": \"fish\",\r\n    \"location\": \"water\"\r\n}\r\n```\r\n\r\nGot:\r\n```(json)\r\n{\r\n    \"category\": \"fish\",\r\n    \"location\": null\r\n}\r\n```\r\n### Environment:\r\n\r\n- Python version: 3.8.10\r\n- Flask version: 3.0.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5519",
    "comments": [
      "I can't reproduce the issue with the information provided. Running the example gives the expected output."
    ]
  },
  {
    "title": "Handler `before_request` doesn't work as expected.",
    "body": "I want to implement CORS processing without any third party libraries (like flask-cors). My desire is simple: assign multiple headers to any response, access and process the pre-flight OPTIONS request.\r\n\r\n```python\r\nclass CORSMiddleware:\r\n    def before_request(self):\r\n        if request.method == \"OPTIONS\":\r\n            response = jsonify({\"status\": \"ok\"})\r\n            return self.process_response(response)\r\n\r\n    def after_request(self, response):\r\n        return self.process_response(response)\r\n\r\n    # noinspection PyMethodMayBeStatic\r\n    def process_response(self, response):\r\n        if response:\r\n            response.headers.add(\"Access-Control-Allow-Origin\", \"*\")\r\n            response.headers.add(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\r\n            response.headers.add(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS, DELETE, PUT\")\r\n        return response\r\n\r\n    def register(self, app: Flask):\r\n        app.before_request(self.before_request)\r\n        app.after_request(self.after_request)\r\n```\r\n\r\nIt can be tested like this\r\n\r\n```py\r\n\r\n# Note: helper function to reduce view logic\r\ndef add_cors_headers(response):\r\n    response.headers.add(\"Access-Control-Allow-Origin\", \"*\")\r\n    response.headers.add(\"Access-Control-Allow-Headers\", \"Content-Type,Authorization\")\r\n    response.headers.add(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS,DELETE,PUT\")\r\n    return response\r\n\r\n\r\nuser_blueprint = Blueprint(\"user\", __name__, url_prefix=\"/users\")\r\n\r\n\r\n@user_blueprint.route(\"/signup\", methods=[\"POST\", \"OPTIONS\"])\r\ndef create_user_handler():\r\n    # Note: uncomment me to see a desired behaviour\r\n    # if request.method == \"OPTIONS\":\r\n    #     response = jsonify({\"status\": \"ok\"})\r\n    #     return add_cors_headers(response)\r\n    # response = jsonify({\"message\": \"registered\"})\r\n    # return add_cors_headers(response)\r\n    return {\"message\": \"registered\"}\r\n\r\n\r\ndef create_app() -> Flask:\r\n    app = Flask(__name__)\r\n    app.register_blueprint(user_blueprint)\r\n    # Note: comment me to see a desired behaviour\r\n    CORSMiddleware().register(app)\r\n    return app\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app = create_app()\r\n    app.run(host=\"127.0.0.1\", port=5000, debug=True\r\n```\r\n\r\nWith the middleware, it handles a preflight OPTIONS request as an original one:\r\n<img width=\"650\" alt=\"Screenshot 2024-07-01 at 10 59 27\" src=\"https://github.com/pallets/flask/assets/45794357/b49f736d-5b1b-46c7-8569-aa6dd178266c\">\r\n\r\nBut the desired behaviour should be like that (you can comment middleware registration and uncomment logic in the view-handler):\r\n<img width=\"653\" alt=\"Screenshot 2024-07-01 at 11 00 15\" src=\"https://github.com/pallets/flask/assets/45794357/9668ea85-de6a-46c2-8c8c-39b9b1ffd7b7\">\r\n\r\nAlso, I was able to implement desired functionality with the middleware, but with the Werkzeug one:\r\n\r\n```py\r\nfrom werkzeug.wrappers import Request, Response\r\n\r\n\r\nclass CORSMiddleware:\r\n    def __init__(self, app):\r\n        self.app = app\r\n\r\n    def __call__(self, environ, start_response):\r\n        request_ = Request(environ)\r\n\r\n        if request_.method == \"OPTIONS\":\r\n            response = Response(status=200)\r\n            response = self.process_response(response)\r\n            return response(environ, start_response)\r\n\r\n        def custom_start_response(status, headers, exc_info=None):\r\n            response_headers = self.process_headers(headers)\r\n            return start_response(status, response_headers, exc_info)\r\n\r\n        return self.app(environ, custom_start_response)\r\n\r\n    def process_response(self, response):\r\n        response.headers.add(\"Access-Control-Allow-Origin\", \"*\")\r\n        response.headers.add(\"Access-Control-Allow-Headers\",\r\n                             \"Content-Type, Authorization\")\r\n        response.headers.add(\"Access-Control-Allow-Methods\",\r\n                             \"GET, POST, OPTIONS, DELETE, PUT\")\r\n        return response\r\n\r\n    def process_headers(self, headers):\r\n        headers.append((\"Access-Control-Allow-Origin\", \"*\"))\r\n        headers.append((\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\"))\r\n        headers.append(\r\n            (\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS, DELETE, PUT\"))\r\n        return headers\r\n\r\n\r\n# and registering it like that\r\ndef create_app() -> Flask:\r\n    app = Flask(__name__)\r\n    app.register_blueprint(user_blueprint)\r\n    app.wsgi_app = CORSMiddleware(app.wsgi_app)\r\n    return app\r\n```\r\n\r\nSo, my question is: what could be wrong with the Flask middleware?",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5513",
    "comments": []
  },
  {
    "title": "Document behaviour of __init__ in cli.prepare_import()",
    "body": "The code in [cli](https://github.com/pallets/flask/blob/main/src/flask/cli.py#L215) is a bit confusing: if you have an __init__ file in the project it causes the cli to step out of the directory and import it from outside the directory.\r\n\r\nE.h. I was working in directory /Users/visgean/p/social-flask/chapter2/models_app and the flask run command tried to import the app as chapter2.models_app.app, which did not work:\r\n\r\n```\r\nError: While importing 'chapter2.models_app.app', an ImportError was raised:\r\n```\r\n\r\nI had to dig into the code to see that the solution is to delete the init file, apparently i am not the only one: https://stackoverflow.com/questions/70835630/while-importing-myapp-app-an-import-error-was-raised\r\n\r\n\r\nI think this feature is a bit undcomented and to be honest I am not sure what the goal is. If I run flask run in a directory I dont want it to work at all with the parent directory. E.g. flask should only be aware of the current directory.\r\n\r\nProposed fixes: \r\n- Specifically mention this behavior on start e.g. \"importing app as chapter2.models_app.app due to presence of __init__.py\"\r\n- Mention this behaviour in docs somewhere\r\n- Remove this behavior unless there is a clear need for it. ",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5512",
    "comments": [
      "I'm not sure why this is unexpected. If you're in the middle of a package, and were to start python, your imports in your modules would break as the python path would be incorrect. Instead, you'd need to get to the folder containing your package, because all your imports are rooted there. Flask does this for you. If we removed this, people would still get errors if they created incorrect init files or were in the wrong directory. ",
      "Generally in Unix you want the command line to work only with the folder you are in or the children, you dont want the programs to randomly go up the folder tree. \r\n\r\n> Instead, you'd need to get to the folder containing your package, because all your imports are rooted there\r\n\r\nThat depends on the package. My imports were for example not rooted at the package that flask thinks is a root, it worked with normal python way of running python but not with CLI. \r\n\r\nIn other words if I run a python script in directory X I expect the directory to be there in sys.path which is currently not happening. ",
      "> Generally in Unix you want the command line to work only with the folder you are in or the children, you dont want the programs to randomly go up the folder tree.\r\n\r\nPlenty of tools search up the tree to try to find the root. For example, `git`, `poetry`, and `tox`.\r\n\r\nI'd need to see your package then, it does not sound like a standard layout for a Python project. It sounds like you're describing the following:\r\n\r\n```\r\ntop/\r\n  project/\r\n    __init__.py\r\n    app/  # current directory\r\n      __init__.py  # app defined here (or somewhere under here)\r\n```\r\n\r\nIn that case, you'd import your app like `from project.app import app` or similar; `flask -A project.app run`, etc. If somehow `from app import app` works directly, then the layout doesn't make sense, why is the `app` subpackage inside the `project` package if it can't import anything from `project`? Or if it can, that suggests you're directly messing with `sys.path`, which is an antipattern. Either `app` is under `package` and should be imported as such, or it's not actually part of `package` and should be separate.\r\n\r\nYou're welcome to post what your layout actually is, it sounds like you're following a book or tutorial, but I have a strong feeling something is non-standard about it even if it's not exactly what I guessed.",
      "Overall I agree with you that the project layout that I had did not make sense (it was a result of moving some files around without moving the init files). But I think having an explicit message that this is happening would be better. "
    ]
  },
  {
    "title": "get \u8bf7\u6c42\uff0c\u5b9a\u4e49\u53c2\u6570\u7c7b\u578b\u7684\u95ee\u9898",
    "body": "\u4e3a\u4ec0\u4e48\u5728 get \u8bf7\u6c42\u4e2d\uff0c\u8bbe\u7f6e\u67d0\u4e2a\u53c2\u6570\u7c7b\u578b\u4e3a int \u7c7b\u578b\u3002\r\n![image](https://github.com/pallets/flask/assets/38832100/6f2ad22b-63b1-4ea1-8567-975d146c061c)\r\n\r\n\r\n\u800c\u5728\u6d4f\u89c8\u5668\u8fd9\u6837\u8bf7\u6c42\u65f6\uff0c\u5374\u62a5 404  \u9519\u8bef\u3002\r\n![image](https://github.com/pallets/flask/assets/38832100/0c28c5c7-bb27-4669-b877-c90fb7b0e68a)\r\n\r\n\r\nFlaks \u7248\u672c\r\n![image](https://github.com/pallets/flask/assets/38832100/244e1622-2ea0-42ef-98f9-7710c55d83f9)\r\n\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5508",
    "comments": []
  },
  {
    "title": "allow setting encoding in open_resource()",
    "body": "This is a duplicate of #1740 &mdash; that may have been closed for lack of a clear rationale, however, and I'd like to suggest it again with the following reasoning.\r\n\r\nThe documentation currently gives this example for using `open_resource()`:\r\n\r\n```python\r\nwith app.open_resource(\"schema.sql\") as f:\r\n    conn.executescript(f.read())\r\n```\r\n\r\nOn Windows, however, this can fail to open a file encoded in UTF-8, which most are these days, and safer code looks like this:\r\n\r\n```python\r\nwith app.open_resource(\"schema.sql\", mode=\"rb\") as f:\r\n   conn.executescript(f.read().decode(\"utf-8\"))  # type: ignore [attr-defined]\r\n```\r\n\r\n(The type comment is needed to prevent mypy from complaining about `f.read()` possibly being a string with no `.decode()` method, as it can't tell that the file was opened in 'rb' mode.)\r\n\r\nIt would be cleaner and more flexible to be able to write:\r\n\r\n```python\r\nwith app.open_resource(\"schema.sql\", encoding=\"utf-8\") as f:\r\n   conn.executescript(f.read())\r\n```\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5504",
    "comments": []
  },
  {
    "title": "IPP",
    "body": ".",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5502",
    "comments": []
  },
  {
    "title": "request parsing special parameters",
    "body": "I want to know when i send \"http://127.0.0.1:5000/?name=xiaojiann+&age=16\" , why request.query_string can get b'name=xiaojiann+' but request.arg get ImmutableMultiDict([('name', 'xiaojiann ')]), request.args use blank space replace +\r\n\r\n<img width=\"739\" alt=\"image\" src=\"https://github.com/pallets/flask/assets/61368566/0a58880c-a70b-4455-a949-4af5ff55ca5b\">\r\n\r\nI try flask version 2.0.3 , 3.0.3 and python version 3.6 , 3.10",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5494",
    "comments": [
      "Because that's how query string parsing works. You need to percent encode characters with special meanings. "
    ]
  },
  {
    "title": "Avoid opening sessions for static resources",
    "body": "Every HTTP request currently results in an HTTP session being opened via `SessionInterface.open_session`. When a server-side session implementation is used, like [Flask-Session](https://flask-session.readthedocs.io/), this results in storage writes to update the expiry date. Requests for static resources are also subject to this, which can degrade performance.\r\n\r\nIt would be useful to easily opt static resources out of sessions. Currently this is only possible with a custom session interface, for example:\r\n\r\n```python\r\nclass StaticRequestFilteringSessionInterface(SessionInterface):\r\n    def __init__(self, app):\r\n        self._delegate = app.session_interface\r\n        self._exclude_path_prefix = app.static_url_path + \"/\"\r\n\r\n    def open_session(self, app, request):\r\n        if request.path.startswith(self._exclude_path_prefix):\r\n            return self.make_null_session(app)\r\n\r\n        return self._delegate.open_session(app, request)\r\n\r\n    def save_session(self, app, session, response):\r\n        return self._delegate.save_session(app, session, response)\r\n```\r\n\r\nConfigured with:\r\n\r\n```python\r\nfrom flask_session import Session\r\n\r\n...\r\nSession(app)\r\napp.session_interface = StaticRequestFilteringSessionInterface(app)\r\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5491",
    "comments": [
      "In production, if performance is an issue, you want to serve your static files directly through your HTTP server, not through Flask. Then this doesn't apply anyway. In other cases, you may want to serve static files with other conditions applied, at which point it's not clear sessions should always be excluded. I don't think it's worth adding the complexity of implementation and explanation to Flask itself, especially when it's already possible to write a custom session (a completely supported and intended public API) to do whatever you want for your case.",
      "Thanks for the swift reply. I appreciate it's not core functionality, perhaps something that Flask-Session would consider instead.",
      "Raised https://github.com/pallets-eco/flask-session/issues/254.",
      "I don't think it makes sense there either, for the same reasons. "
    ]
  },
  {
    "title": "Flask ignores multiple slashes at the beginning of the path",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nGitHub Discussions or the Pallets Discord for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.8.14\r\n- Flask version: 2.3.2\r\n\r\nI have a paths with prefix /admin. if you follow a path containing this prefix, proxy  before app see this and asks mTLS auth. But when i follow this path with multiple slashes at the beginning (ex //admin, ///admin) proxy ignore this, but flask think that this is the same path as /admin and return values, client must not see. I think this should not work like this\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5489",
    "comments": [
      "This is deliberate. If you know your HTTP server will handle it correctly, you can disable `merge_slashes` on `url_map` or a `Rule`: https://werkzeug.palletsprojects.com/en/3.0.x/routing/#rule-format"
    ]
  },
  {
    "title": "send_from_directory unclosed file error",
    "body": "When warnings are set to error, pytest claims there is an unclosed file when `send_from_directory` is called.  I assume this indicates there is a resource leak.  Even if Python garbage collects this at some point, this causes issues with testing flask applications that use send_from_directory with warnings as errors enabled.\r\n\r\n1. Create app\r\n\r\napp.py:\r\n```\r\nfrom flask import Flask, send_from_directory\r\napp = Flask(__name__)\r\n\r\n@app.route('/<path:name>')\r\ndef download_resources(name):\r\n    return send_from_directory('resources', name)\r\n```\r\n\r\n\r\n2. Add `resources/file.txt`\r\n\r\n```bash\r\nmkdir resources\r\necho file > resources/file.txt\r\n```\r\n\r\n\r\n3. Add tests\r\n\r\ntests/conftest.py:\r\n```\r\nimport pytest\r\n\r\nfrom app import app as flask_app\r\n\r\n@pytest.fixture\r\ndef app():\r\n    yield flask_app\r\n\r\n@pytest.fixture\r\ndef client(app):\r\n    return app.test_client()\r\n```\r\n\r\ntests/test_app.py:\r\n```\r\ndef test_download(app, client):\r\n    res = client.get('/file.txt')\r\n    assert res.status_code == 200\r\n```\r\n\r\n4. Run tests\r\n\r\nExecute `pytest -Werror`.\r\n\r\nThe results ([results.txt](https://github.com/pallets/flask/files/15325158/results.txt)) include the following error:\r\n` ResourceWarning: unclosed file <_io.BufferedReader name='/flask-test/resources/file.txt'>`\r\n\r\nExpected Results:\r\n\r\nExecute `pytest` without warnings as errors.  This is the expected result:\r\n\r\n```\r\n============================= test session starts ==============================\r\nplatform darwin -- Python 3.11.9, pytest-8.2.0, pluggy-1.5.0\r\nrootdir: /flask-test\r\ncollected 1 item\r\n\r\ntests/test_app.py .                                                      [100%]\r\n\r\n============================== 1 passed in 0.02s ===============================\r\n```\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.9\r\n- Flask version: 3.0.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5483",
    "comments": [
      "Call `response.close()` at the end. See Flask itself for examples of this in tests.",
      "> Call `response.close()` at the end. See Flask itself for examples of this in tests.\r\n\r\n@davidism, I assume you are referring to the call to `rv.close()` in the [test_send_from_directory code](https://github.com/pallets/flask/blob/255c8d66af6daff3eaa063ea0819e185d4d1e214/tests/test_helpers.py#L99).\r\n\r\nUnfortunately, the call to send_from_directory and the associated close both happen in the test code proper.  When called by production code the call to `response.close()` cannot be done without error.  When I modify `download_resources` to the following it causes additional errors:\r\n```\r\n@app.route('/<path:name>')\r\ndef download_resources(name):\r\n    response = send_from_directory('resources', name)\r\n    response.close()\r\n    return response\r\n```\r\n\r\nError:\r\n```\r\nself = <werkzeug.wsgi.FileWrapper object at 0x10c061150>\r\n\r\n    def __next__(self) -> bytes:\r\n>       data = self.file.read(self.buffer_size)\r\nE       ValueError: read of closed file\r\n\r\nvenv/lib/python3.11/site-packages/werkzeug/wsgi.py:332: ValueError\r\n```\r\n\r\nThe [documentation](https://flask.palletsprojects.com/en/3.0.x/api/#flask.send_from_directory) does not mention a call to `response.close()`.\r\n\r\n[Other documentation](https://github.com/pallets/flask/blob/255c8d66af6daff3eaa063ea0819e185d4d1e214/docs/patterns/fileuploads.rst?plain=1#L115) similarly does not call `response.close()`.\r\n\r\nIt seems to me that the `rv.close()` in Flask's test case masks the unclosed file error, as you are not using send_from_directory via an external call like a Flask app would.\r\n\r\nThoughts?",
      "You don't call it in your application, only in your test. WSGI servers close the response automatically, the test client cannot. "
    ]
  },
  {
    "title": "Change of query string encoding behaviour in flask 3.0",
    "body": "Flask until 2.0 decoded %-encoded entities from query strings, while it seems that Flask 3.0 does not.\r\n\r\nGiven this `print_args.py`:\r\n\r\n```py\r\nfrom flask import Flask, request\r\n\r\napp = Flask(__name__)\r\n\r\n\r\n@app.route(\"/\")\r\ndef hello_world():\r\n    return request.args.get(\"test\")\r\n```\r\n\r\nOk Flask 2:\r\n\r\n```\r\n$ flask --version\r\nPython 3.11.2\r\nFlask 2.2.2\r\nWerkzeug 2.2.2\r\n$ flask --app print_args run\r\n...\r\ncurl http://127.0.0.1:5000?test=%A0+++a\r\n\ufffd   a\r\n```\r\n\r\nOn Flask 3:\r\n\r\n```\r\n$ flask --version\r\nPython 3.11.9\r\nFlask 3.0.3\r\nWerkzeug 3.0.2\r\n$ flask --app print_args run\r\n...\r\ncurl http://127.0.0.1:5000?test=%A0+++\r\n%A0   a\r\n```\r\n\r\nWhile I understand  %A0 is not a valid unicode sequence, this is a change of behaviour may be worth documenting.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5479",
    "comments": [
      "This is documented in Werkzeug's change log, where the change happened. https://werkzeug.palletsprojects.com/en/3.0.x/changes/#version-2-3-0\r\n\r\n> Percent encoding in URLs must always represent UTF-8 bytes. Invalid bytes are left percent encoded rather than replaced.\r\n\r\nSee https://github.com/pallets/werkzeug/issues/2602 for the issue discussing the change and https://github.com/pallets/werkzeug/pull/2641 for the PR with more discssion."
    ]
  },
  {
    "title": "Add support for partitioned session cookies",
    "body": "Related issue with historical context: https://github.com/pallets/werkzeug/issues/2797\r\n\r\nPartitioned cookies are now supported in Werkzeug: https://github.com/pallets/werkzeug/pull/2855\r\n\r\nIt would be nice to have first-class support for the flask session cookie using the `Partitioned` flag to provide support for Chrome's CHIPS and allow sessions to continue to work within iframes.\r\n\r\nExample usage might be:\r\n\r\n```python\r\napp.config['SESSION_COOKIE_SAMESITE'] = \"None\"\r\napp.config['SESSION_COOKIE_SECURE'] = True\r\napp.config['SESSION_COOKIE_PARTITIONED'] = True # add this?\r\n```\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5472",
    "comments": [
      "This is related to the warning I get on Firefox, right?\r\n\r\n> Cookie \u201csession\u201d does not have a proper \u201cSameSite\u201d attribute value. Soon, cookies without the \u201cSameSite\u201d attribute or with an invalid value will be treated as \u201cLax\u201d. This means that the cookie will no longer be sent in third-party contexts. If your application depends on this cookie being available in such contexts, please add the \u201cSameSite=None\u201c attribute to it. To know more about the \u201cSameSite\u201c attribute, read https://developer.mozilla.org/docs/Web/HTTP/Headers/Set-Cookie/SameSite\r\n\r\nAlthough as I understand it, it won't break anything for me.\r\n",
      "No, that's related to same site, which is already possible to set in the app config.",
      "Hi! I'd like to take a look into collaborate in this issue\r\n\r\nI was going through the context of this issue and saw that implicitly if partitioned is set to true it should also set secure to true as mentioned here: https://github.com/pallets/werkzeug/pull/2855/files#diff-cd95d3a95564f3230d4875ac34fc9d039856b033c6b1430d5d3cc864f87cf89aL1300\r\n\r\nWould that be the case for here as well?",
      "Yes, but you shouldn't need to do anything extra for that, it's already how it's implemented, as you've linked to."
    ]
  },
  {
    "title": "Failing to start (due to port unavailable) cannot be directly determined by the current python api",
    "body": "I believe that failing to start (due to the designated port being unavailable) cannot be directly determined by the current python api, if not mistaken.\r\n\r\nWhen the port specified for startup is taken, a python code starting the server with Werkzeug cannot know if startup has failed, since no exception is raised, and no api is there to check on its status, while the following is written to stderr:\r\n\r\n> Address already in use\r\n> Port 5000 is in use by another program. Either identify and stop that program, or start the server with a different port.\r\n\r\nexample code:\r\n\r\n```python\r\nfrom flask import Flask\r\nfrom werkzeug.serving import run_simple\r\n\r\napp = Flask(__name__)\r\n\r\ntry:\r\n    run_simple('127.0.0.1', 5000, app)  \r\nexcept Exception as e:\r\n    start_success = False\r\n```\r\n\r\nEven though traditionally most web servers frameworks did not touch up their startup and shutdown usability from code to those levels, I think it would be implied to provide the caller with this basic level of transparency being robustly enabled for them. Apologies in advance if I've missed any obvious way. \r\n\r\n# Environment:\r\n\r\n- Python version: 3.10.13\r\n- Flask version: 3.0.3\r\n- Platform: Ubuntu 22.04\r\n\r\n# Mildly related on the same theme of api startup and shutdown: \r\nhttps://stackoverflow.com/questions/72824420/how-to-shutdown-flask-server",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5471",
    "comments": [
      "Complete code reproducing the context, which would hopefully also become a skeleton (or inspiration) for a flaks test, after an api transparency into failure to use the specified server port has been very hopefully incorporated in flask:\r\n\r\n```python\r\nfrom flask import Flask\r\nfrom werkzeug.serving import run_simple\r\nfrom multiprocessing import Process\r\n\r\napp = Flask(__name__)\r\n\r\ndef start():\r\n    print('starting a flask server')\r\n    try:\r\n        started = run_simple('127.0.0.1', 5000, app)\r\n    except Exception as e:\r\n        print(f'the flask web server crashed with an exception:\\n{e}\\n')\r\n    else:\r\n        # of course we will never get here unless the server shut down without throwing\r\n        print(f'the flask web server finished with return value {started}')\r\n\r\n\r\nif __name__ == '__main__':\r\n\r\n    flask_process = Process(target=start, daemon=True)\r\n    flask_process.start()\r\n\r\n    start()\r\n```\r\n\r\nNote that, the messages about the port being unavailable come out on stderr, same as success messages such as the following type, and hence this leaves no deterministic way for the code starting the server to resolve the status of the server, other than parsing stderr:\r\n\r\n> 127.0.0.1 - - [28/Apr/2024 13:31:24] \"GET / HTTP/1.1\" 200 -\r\n\r\n",
      "Not sure what you are trying to do, but keep in mind that this server is ONLY meant for development purposes, NOT for anything else. So if you want to run a flask app embedded in some other application for whatever reason, using `run_simple` is not what you should do.",
      "Makes sense. My scenario is borderline in that regard. Will I have that kind of api-laden way of knowing the status of the server when using a non Werkzeug WSGI component? ",
      "Okay, I understand then that no underlying supported WSGI server component can be controlled (start and stop) robustly from Flask code then, and that that is not planned either."
    ]
  },
  {
    "title": "Conflicting cookies shenanigans with `SESSION_COOKIE_DOMAIN`",
    "body": "Hi,\r\nI encountered a strange behavior of flask regarding cookies when the value of `SESSION_COOKIE_DOMAIN` is updated after some cookies have been set.\r\nI observed this with Python 3.11, Flask 3.0.2 and Werkzeug 3.0.2 with both Firefox 124 and Chrome 123.\r\nFirst of all, I could not reproduce the issue when serving on http://localhost:5000, so you might need to add `127.0.0.1 flask.localhost` in your `/etc/hosts` to be able to reproduce this, and access the app from http://flask.localhost:5000.\r\n\r\n0. Put the following snippet in an `app.py` and run it with `env FLASK_DEBUG=1 FLASK_APP=app flask run`. \r\n```python\r\nimport flask\r\nimport base64\r\napp = flask.Flask(__name__)\r\napp.config[\"SECRET_KEY\"] = \"super secret\"\r\napp.config[\"SERVER_NAME\"] = \"flask.localhost:5000\"\r\napp.config[\"SESSION_COOKIE_DOMAIN\"] = app.config[\"SERVER_NAME\"]\r\n\r\n@app.route(\"/\", methods=(\"GET\", \"POST\"))\r\ndef index():\r\n    if flask.request.form:\r\n        flask.session[\"value\"] = flask.request.form[\"value\"]\r\n\r\n    session_cookies = [\r\n        base64.b64decode(cookie.split(\".\")[0]).decode()\r\n        for cookie in flask.request.cookies.getlist(\"session\")\r\n    ]\r\n    return (\r\n        '<form action=\"/\" method=\"post\"><input name=\"value\"><input type=\"submit\"></form\"><br>\\n'\r\n        + f'value {flask.session.get(\"value\")}<br>\\n'\r\n        + \"cookies: \" + \" \".join(session_cookies)\r\n    )\r\n```\r\n\r\n2. **Open http://flask.localhost:5000, clean the cookies if existing.**\r\n`flask.session` is empty.\r\n3. **Write `foo` in the form, validate.**\r\n`session[\"value\"]` contains `foo`.\r\n4. **Reload the page**\r\n`session[\"value\"]` still contains `foo`.\r\nThe firefox dev tools indicate that the cookie domain is `.flask.localhost` (with a leading dot).\r\n5. **Comment the `app.config[\"SESSION_COOKIE_DOMAIN\"] = app.config[\"SERVER_NAME\"]` line**\r\n6. **Reload the page**\r\n`session[\"value\"]` still contains `foo`.\r\n7. **Write `bar` in the form, validate.**\r\n`session[\"value\"]` still contains `bar`.\r\n8. **Reload the page**\r\n`session[\"value\"]` contains `foo`, which is unexpected.\r\nA cookie has been set on step 6, and the firefox dev tools indicate that the cookie domain is `flask.localhost` (without a leading dot).\r\nHowever it seems the value is read from the step 2. cookie. that is still around.\r\n`flask.request.cookies.getlist(\"session\")` contains two cookies, with the values `foo` and `bar`.\r\n\r\nThose steps work also by starting with the `SESSION_COOKIE_DOMAIN` commented and then uncomment it at step 4.\r\nThe issue is not reproductible without the `app.config[\"SERVER_NAME\"] = \"flask.localhost:5000\"` line.\r\n\r\nThe [SESSION_COOKIE_DOMAIN documentation](https://flask.palletsprojects.com/en/3.0.x/config/#SESSION_COOKIE_DOMAIN) mentions that different values produce different cookies. However it does not mention that different cookies could conflict, neither that changing the value should be avoided.\r\n\r\nMaybe there is some misconfiguration on my side (is it?) but nonetheless it feels strange that Flask could write in one session cookie (step 6.) and then read from another session cookie (step 7.).\r\n\r\nDeleting the cookies solve the situation, however I can not expect the users of my production application to delete their cookies so the application is functionning again. And the curse is that some of my users have their cookies created with subdomains support, and some other have their cookies without subdomains support. So setting or deleting `SESSION_COOKIE_DOMAIN` will fix the issue for ones while provoking it for the other ones.\r\n\r\nWhat do you think?",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5462",
    "comments": [
      "I am confident that we are currently doing the right thing with cookie domain. I spent a long time looking through the relevant current specs and browser behavior when reviewing that code last year.\r\n\r\nGiven the current way browsers handle cookies, it is less secure to set the domain property than to leave it unset. You're seeing the result of the two different behaviors here. When you set a domain, the cookie is valid for that and all subdomains. When you don't set a domain, the browser makes it valid only for the domain that requested it. When both cookies are set, the browser has to pick one to send first.",
      "You can attempt to issue an few extra `response.delete_cookie` calls for each setting on some response, but beyond that we can't really affect what the browser stores and sends if you start sending it different overlapping things at different times.",
      "> When both cookies are set, the browser has to pick one to send first.\r\n\r\nDoes Flask has to pick the first one sent by the browser, or would it make sense for Flask to use the cookie with the most suitable domain, if that information is ever available?\r\n\r\n> You can attempt to issue an few extra response.delete_cookie calls for each setting on some response\r\n\r\n`response.delete_cookie(\"session\", \"flask.localhost\")` works, but `response.delete_cookie(\"session\", \".flask.localhost\")` does not, whatever the value of `SESSION_COOKIE_DOMAIN`.",
      "The domain information is not present in the `Cookie` request header, it is only `key=value`.\r\n\r\nA leading dot is irrelevant in modern browsers, it's equivalent to the same domain without the dot. So both those calls are the same. The other call would be `delete_cookie` without the domain at all.",
      "I see, thank you for your insight.\r\nIn the end I could solve the situation simply by abandoning both cookies by changing the `SESSION_COOKIE_NAME`.\r\n\r\nI think this would be worth mentioning in the documentation though. Would you be OK if I\u00a0write a little caveat paragraph about this?",
      "Sure, but where? It might be mentioned in the Werkzeug API docs already. Maybe in the security section for the Flask docs?",
      "I can think of the [Configuration Handling > SESSION_COOKIE_DOMAIN](https://flask.palletsprojects.com/en/3.0.x/config/#SESSION_COOKIE_DOMAIN) section, or in the [Security > Set-Cookie Options](https://flask.palletsprojects.com/en/3.0.x/config/#SESSION_COOKIE_DOMAIN) section indeed.\r\n\r\nI would expect to read this more on the configuration I think. As you want."
    ]
  },
  {
    "title": "Calling `flash` after `get_flashed_messages` fails ",
    "body": "In a single request, do this:\r\n- call `get_flashed_messages()`\r\n- call `flash(...)`\r\n- call `get_flashed_messages()` again, observe that it returns the empty list, despite a message just having been flashed.\r\n\r\nAfter the first call to `get_flashed_messages()`, `request_ctx.flashes` is  `[]`, which appears to send this code in `get_flashed_messages` off the rails:\r\n\r\nhttps://github.com/pallets/flask/blob/98a7f9fcf09fce5d32bf25e7f917c1c3026719d1/src/flask/helpers.py#L364-L367\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11\r\n- Flask version: 3.0.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5458",
    "comments": [
      "What does \"off the rails\" mean? Did an error happen? Be sure to provide a minimal reproducible example and the full traceback when reporting an issue. ",
      "Sure, fair:\r\n```py\r\nfrom flask import Flask, flash, get_flashed_messages\r\n\r\napp = Flask(__name__)\r\napp.secret_key = \"abcdef\"\r\n\r\n@app.route(\"/\")\r\ndef hello_world():\r\n    get_flashed_messages()\r\n    flash(\"hi\")\r\n    assert get_flashed_messages()\r\n```\r\n\r\nRun with\r\n```\r\nflask --app=flask_repro run \r\n```\r\ngo to http://127.0.0.1:5000/ and see\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/andreas/src/env-3.12/lib/python3.12/site-packages/flask/app.py\", line 1455, in wsgi_app\r\n    response = self.full_dispatch_request()\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/andreas/src/env-3.12/lib/python3.12/site-packages/flask/app.py\", line 869, in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/andreas/src/env-3.12/lib/python3.12/site-packages/flask/app.py\", line 867, in full_dispatch_request\r\n    rv = self.dispatch_request()\r\n         ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/andreas/src/env-3.12/lib/python3.12/site-packages/flask/app.py\", line 852, in dispatch_request\r\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/andreas/tmp/flask_repro.py\", line 10, in hello_world\r\n    assert get_flashed_messages()\r\nAssertionError\r\n```\r\n> What does \"off the rails\" mean? \r\n\r\n\"Off the rails\" means that `flashes` is not None there, and so the code does not look in the session (assuming that's what it's supposed to do).",
      "This is documented: https://flask.palletsprojects.com/en/3.0.x/api/#flask.get_flashed_messages\r\n\r\n> Further calls in the same request to the function will return the same messages.\r\n\r\nThe intended use is documented as well: https://flask.palletsprojects.com/en/3.0.x/patterns/flashing/\r\n\r\n> The flashing system basically makes it possible to record a message at the end of a request and access it next request and only next request.\r\n\r\nYou're intended to put messages into one request, then get them out in the next request. Getting them out, putting them in, and getting them out again in the same request is not the intended use case."
    ]
  },
  {
    "title": "Unable to start flask3.0 app on a minimal implementation with `invalid syntax. Perhaps you forgot a comma? (scaffold.py, line 295)`",
    "body": "Simply create a minimal flask3.0 app as follow and execute it, it will fail instantly on importing `from flask import Flask`:\r\n```python\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\"/\")\r\ndef hello_world():\r\n    return \"<p>Hello, World!</p>\"\r\n\r\napp.run()\r\n```\r\n\r\nError trace:\r\n```text\r\nTraceback (most recent call last):\r\n  File \"/home/lazydreamer/anaconda3/envs/test_env/lib/python3.11/runpy.py\", line 198, in _run_module_as_main\r\n    return _run_code(code, main_globals, None,\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/lazydreamer/anaconda3/envs/test_env/lib/python3.11/runpy.py\", line 88, in _run_code\r\n    exec(code, run_globals)\r\n  File \"/home/lazydreamer/.vscode-server/extensions/ms-python.debugpy-2024.4.0-linux-x64/bundled/libs/debugpy/adapter/../../debugpy/launcher/../../debugpy/__main__.py\", line 39, in <module>\r\n    cli.main()\r\n  File \"/home/lazydreamer/.vscode-server/extensions/ms-python.debugpy-2024.4.0-linux-x64/bundled/libs/debugpy/adapter/../../debugpy/launcher/../../debugpy/../debugpy/server/cli.py\", line 430, in main\r\n    run()\r\n  File \"/home/lazydreamer/.vscode-server/extensions/ms-python.debugpy-2024.4.0-linux-x64/bundled/libs/debugpy/adapter/../../debugpy/launcher/../../debugpy/../debugpy/server/cli.py\", line 284, in run_file\r\n    runpy.run_path(target, run_name=\"__main__\")\r\n  File \"/home/lazydreamer/.vscode-server/extensions/ms-python.debugpy-2024.4.0-linux-x64/bundled/libs/debugpy/_vendored/pydevd/_pydevd_bundle/pydevd_runpy.py\", line 321, in run_path\r\n    return _run_module_code(code, init_globals, run_name,\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/lazydreamer/.vscode-server/extensions/ms-python.debugpy-2024.4.0-linux-x64/bundled/libs/debugpy/_vendored/pydevd/_pydevd_bundle/pydevd_runpy.py\", line 135, in _run_module_code\r\n    _run_code(code, mod_globals, init_globals,\r\n  File \"/home/lazydreamer/.vscode-server/extensions/ms-python.debugpy-2024.4.0-linux-x64/bundled/libs/debugpy/_vendored/pydevd/_pydevd_bundle/pydevd_runpy.py\", line 124, in _run_code\r\n    exec(code, run_globals)\r\n  File \"/home/lazydreamer/Dev/TestProj/src/main.py\", line 3, in <module>\r\n    from app import flask_app\r\n  File \"/home/lazydreamer/Dev/TestProj/src/app.py\", line 1, in <module>\r\n    from flask import Flask\r\n  File \"/home/lazydreamer/anaconda3/envs/test_env/lib/python3.11/site-packages/flask/__init__.py\", line 6, in <module>\r\n    from .app import Flask as Flask\r\n  File \"/home/lazydreamer/anaconda3/envs/test_env/lib/python3.11/site-packages/flask/app.py\", line 43, in <module>\r\n    from .sansio.app import App\r\n  File \"/home/lazydreamer/anaconda3/envs/test_env/lib/python3.11/site-packages/flask/sansio/app.py\", line 31, in <module>\r\n    from .scaffold import _endpoint_from_view_func\r\n  File \"/home/lazydreamer/anaconda3/envs/test_env/lib/python3.11/site-packages/flask/sansio/scaffold.py\", line 295\r\n    raise TypeError('Use the 'route' decorator to use the 'methods' argument.')\r\n                    ^^^^^^^^^^^^^^^\r\nSyntaxError: invalid syntax. Perhaps you forgot a comma?\r\n```\r\n\r\n![image](https://github.com/pallets/flask/assets/8576808/3dc5e15b-2fd7-4c46-a571-2571135a1a58)\r\n\r\nI am not sure what does the exception message `'Use the 'route' decorator to use the 'methods' argument.'` means as I've just upgraded to Flask3.0, but this message string is definitely not right, and I my project will not encounter any issue on Flask2.3.3.\r\n\r\nEnvironment:\r\n- Python version: 3.11.8\r\n- Flask version: 3.0.2\r\n- OS: Ubuntu",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5456",
    "comments": [
      "I can't reproduce that issue with the information provided. Perhaps there's something wrong with your Python environment. ",
      "Instead  try inside virtual env and then reinstall everything after that run again if pass , it means that the problem is on you system config for python @lazydreamerbliss \r\n"
    ]
  },
  {
    "title": "HTTP response status 204 (`No Content`) includes superfluous `Content-Type` header",
    "body": "\r\nWhen returning HTTP code `204` Flask will include a `Content-Type` header which is superfluous as there is no content.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.9\r\n- Flask version: 3.0.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5455",
    "comments": [
      "This is because `Response` has a default content type, and it's not worth inspecting the status and body on each response just in case its 204 with no body to remove the header. You can call `del response.headers[\"content-type\"]` if you know you need to remove it."
    ]
  },
  {
    "title": "Post request response time spikes",
    "body": "Hello,\r\n\r\nin my project I need to upload images as bytes to an endpoint and then process them, within a certain time. The images have a resolution of 600x600 and weight ~700 kB per image. Images are in png format. I have created a minimal flask application with one endpoint. The application is served using a waitress.\r\n\r\nThe problem is that sometimes response time from an endpoint suddenly increases by an order of magnitude. As I have to fit in a certain amount of time, such spikes can cause a critical error.\r\n\r\nI ran a cProfile on the post request and found out that when there is a spike two functions take more time than normal:\r\n\r\n**Normal**\r\n\r\n```\r\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n     2    0.000    0.000    0.000    0.000 {method 'sendall' of '_socket.socket' objects}\r\n     1    0.004    0.004    0.004    0.004 {method 'recv_into' of '_socket.socket' objects}\r\n```\r\n\r\n**Spike**\r\n\r\n```\r\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n     2    0.008    0.004    0.008    0.004 {method 'sendall' of '_socket.socket' objects}\r\n     1    0.012    0.012    0.012    0.012 {method 'recv_into' of '_socket.socket' objects}\r\n```\r\n\r\nWhat is the cause of these spikes, and can they be resolved in some way?\r\n\r\nCode to reproduce:\r\n\r\n```\r\n# app.py\r\nimport numpy as np\r\nfrom flask import Flask, request\r\n\r\n\r\ndef create_app():\r\n    app = Flask(__name__)\r\n\r\n    @app.route(\"/endpoint\")\r\n    def endpoint():\r\n        data = request.data\r\n        img_arr = np.frombuffer(data, dtype=np.uint8)\r\n        # ...\r\n        return {\"foo\": \"bar\"}\r\n\r\n    return app\r\n```\r\n\r\n```\r\n# wsgi.py\r\nfrom waitress import serve\r\n\r\nfrom app import create_app\r\n\r\n\r\ndef main():\r\n    app = create_app()\r\n    serve(app, host=\"0.0.0.0\", port=\"9009\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n```\r\n\r\n```\r\n# send.py\r\n\r\nfrom pathlib import Path\r\n\r\nimport numpy as np\r\nimport requests\r\nfrom PIL import Image\r\n\r\n\r\ndef main():\r\n    img_paths = list(Path(\"images\").rglob(\"*.png\"))\r\n    ses = requests.Session()\r\n    speeds = []\r\n    for img_path in img_paths:\r\n        img_arr = np.asarray(Image.open(img_path))\r\n        response = ses.post(url='http://0.0.0.0:9009/endpoint', data=img_arr.tobytes())\r\n        speeds.append(response.elapsed.total_seconds())\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n```\r\n\r\nPython and package versions:\r\n\r\n```\r\npython==3.8.18\r\n\r\nFlask==3.0.2\r\nnumpy==1.24.4\r\npillow==10.2.0\r\nrequests==2.31.0\r\nwaitress==3.0.0\r\n```\r\n\r\nThree independent performances for 1,000 images:\r\n\r\n[First](https://i.stack.imgur.com/53GEa.png)\r\n\r\n[Second](https://i.stack.imgur.com/1iFrD.png)\r\n\r\n[Third](https://i.stack.imgur.com/TxCpV.png)",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5450",
    "comments": [
      "Sorry, this is outside the scope of what we can help with here. It could be any number of things including the network, OS, filesystem, HTTP server, a proxy, other applications, etc. If you track this down to a specific issue in Flask, we'll be happy to reconsider it."
    ]
  },
  {
    "title": "Use of `hashlib.sha1` causes issue in FIPS build",
    "body": "The use of SHA1 found here: https://github.com/pallets/flask/blob/b90a4f1f4a370e92054b9cc9db0efcb864f87ebe/src/flask/sessions.py#L289\r\nprevents applications from running in a FIPS Enabled Environment/OS. The OS will abruptly stop the application from running when it detects a non compliant Hash Algorithm is used.\r\n\r\nDescribe how to replicate the bug:\r\nEnforce FIPS Enabled on the OS (such as RHEL9)\r\n\r\n\r\nUnexpected Behavior Error output:\r\n```bash\r\nTraceback (most recent call last):\r\n  File \"/opt/abc-app/app.py\", line 1, in <module>\r\n    from xxxxxxxxxx import xxxxxxx\r\n  File \"/opt/abc-app/abc-app_ui.py\", line 67, in <module>\r\n    sess.init_app(app=app)\r\n  File \"/opt/abc-app/venv/lib/python3.11/site-packages/flask_session/__init__.py\", line 50, in init_app\r\n    app.session_interface = self._get_interface(app)\r\n                            ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/abc-app/venv/lib/python3.11/site-packages/flask_session/__init__.py\", line 79, in _get_interface\r\n    session_interface = FileSystemSessionInterface(\r\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/abc-app/venv/lib/python3.11/site-packages/flask_session/sessions.py\", line 312, in __init__\r\n    self.cache = FileSystemCache(cache_dir, threshold=threshold, mode=mode)\r\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/abc-app/venv/lib/python3.11/site-packages/cachelib/file.py\", line 73, in __init__\r\n    self._update_count(value=len(list(self._list_dir())))\r\n  File \"/opt/abc-app/venv/lib/python3.11/site-packages/cachelib/file.py\", line 95, in _update_count\r\n    self.set(self._fs_count_file, new_count, mgmt_element=True)\r\n  File \"/opt/abc-app/venv/lib/python3.11/site-packages/cachelib/file.py\", line 244, in set\r\n    filename = self._get_filename(key)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/abc-app/venv/lib/python3.11/site-packages/cachelib/file.py\", line 201, in _get_filename\r\n    bkey_hash = self._hash_method(bkey).hexdigest()\r\n                ^^^^^^^^^^^^^^^^^^^^^^^\r\n_hashlib.UnsupportedDigestmodError: [digital envelope routines] unsupported\r\n```\r\n\r\nEnvironment:\r\nRHEL9 FIPS Enabled and Enforced\r\n\r\n- Python version: 3.x\r\n- Flask version: 3.0.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5448",
    "comments": [
      "Already reported to cachelib: https://github.com/pallets-eco/cachelib/issues/361",
      "Wait nevermind, the traceback is for Flask-Session but you're pointing at Flask code in the link. So the problem is that the default of `sha1` causes `hashlib` to raise an error before it's possible to override that, so even if the user wants to choose something other than the default they can't do that in time.",
      "Looking into this more, only MD5 is called out as not being available in FIPS mode: https://docs.python.org/3/library/hashlib.html#hash-algorithms. Has this changed recently to include SHA-1? If so, you should report that to Python as well to update the documentation to reflect what FIPS actually does.\r\n\r\nI found this announcement https://www.nist.gov/news-events/news/2022/12/nist-retires-sha-1-cryptographic-algorithm which states that FIPS 180-5 will be released by 2030, but I can't find anything detailing how you'd get a FIPS build of OpenSSL that doesn't support SHA-1 today. I need some more info on how OpenSSL/Python is being built, because it looks like the build is different than what FIPS actually requires."
    ]
  },
  {
    "title": "When using Flask to receive multiple files, an extra \u20180D\u2019 appears at the end of some images",
    "body": "When using Flask to receive multiple image files, occasionally an extra \"0D\" appears at the end of the image. The original data is saved, and the end of this image is normal \"FFD90D0A\". Packet capture tools also show a normal ending. If this request is sent repeatedly, the same error will continue to occur, and the saved image cannot be resent to reproduce the issue.\r\n\r\nBelow is the main code for sending and receiving. This code cannot be run directly because it needs to read some data.\r\n\r\n```\r\nfiles={}\r\nfiles[i]=(\"name\", data[i], 'image/jpeg')\r\nresponse = requests.post(\r\n            \"http://192.168.1.50:8006/test\",\r\n            files = files,\r\n        )\r\n```\r\n\r\n\r\n```\r\nimport flask\r\n\r\napp = flask.Flask(__name__)\r\n\r\n@app.before_request\r\ndef before_request():\r\n    path=flask.request.path\r\n    data=flask.request.get_data(cache=True, as_text=False)\r\n    flask.request.data1=data\r\n\r\n@app.route('/test', methods = ['POST'])\r\ndef testfile():\r\n    data=flask.request.data1\r\n    files=flask.request.files\r\n    files=[(i,files[i]) for i in files]\r\n    for i in range(len(files)):\r\n        with open(f\"test/{i}.jpg\",\"wb\") as f:\r\n            files[i][1].seek(0, os.SEEK_END)\r\n            file_size = files[i][1].tell()\r\n            files[i][1].seek(0)\r\n            f.write(files[i][1].read(file_size))\r\n    return flask.jsonify({\"code\":0})\r\n\r\nif __name__ == '__main__':\r\n    app.run(host=\"0.0.0.0\",port=8006)\r\n```\r\n\r\n\r\n\r\nI have analyzed the raw data and source code, and used packet capture tools to view the received data, all of which are normal. I suspect there is a problem with the parsing, but the flask source code shows that the parsing will remove \"\\r\\n\", why would there still be errors?\r\n\r\nThe probability of this issue occurring is very small, making it difficult to reproduce. However, when it does occur, the same error will occur.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5447",
    "comments": [
      "Upgrade to the latest version of Werkzeug.\n\nDuplicate of https://github.com/pallets/werkzeug/issues/2761"
    ]
  },
  {
    "title": "Broken HTML Markup in Template Inheritance",
    "body": "The HTML Markup within the docs is broken. A <p> Tag is opened but never closed.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5445",
    "comments": [
      "`<p>` does not need a closing tag (just like `<img>`), and please do not open issues for trivial things (the mention about opening an issue first in the contribution guideline does not apply to typos, simple doc fixes, etc.)"
    ]
  },
  {
    "title": "Unable to silence logging messages",
    "body": "Im getting ~15 of:\r\n\r\n> 127.0.0.1 - - [16/Mar/2024 12:10:13] \"POST / HTTP/1.1\" 200 -\r\n\r\nin the terminal when Im running a Dash application.\r\n```\r\nserver = flask.Flask(__name__)\r\napp = dash.Dash(\r\n    __name__,\r\n    server=server,\r\n    external_stylesheets=[dbc.themes.BOOTSTRAP],\r\n    meta_tags=[\r\n        {\"name\": \"viewport\", \"content\": \"width=device-width, initial-scale=1\"}\r\n    ],\r\n)\r\n```\r\n(https://github.com/AlexKurek/srt-py/blob/master/srt/dashboard/app.py#L53)\r\n\r\nHow do I silence them? I have found a lot of methods, e.g. [Disable console messages in Flask server](https://stackoverflow.com/questions/14888799/disable-console-messages-in-flask-server), but none of them worked. My guess is that since they worked in previous versions of Flask - could this be a regression?\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11\r\n- Flask version: 3.0.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5442",
    "comments": [
      "Try [this](https://stackoverflow.com/a/30086809)."
    ]
  },
  {
    "title": "How to avoid duplicate threads in debug mode",
    "body": "## Issue Description\r\n\r\nI have a similar issue as #5307 and I also understand the arguments related to threads in web applications.\r\n\r\nIn my case of a web server for controlling Raspberry Pi cameras [raspiCamSrv](https://github.com/signag/raspi-cam-srv), there are several threads under control of the web app, like live stream, video recording, etc.    \r\nThese threads use the [Picamera2](https://github.com/raspberrypi/picamera2) library which starts its own threads.\r\n\r\nThis is normally not an issue because these threads are started by users from the Web UI after the Flask server has started.\r\n\r\nNow, I have added a motion capture feature, which is also running in an own thread and users want this feature to be automatically started with the server, for example after the device has been rebooted.\r\n\r\nCurrently, I start this thread in the app factory ```create_app()```.   \r\nAnd, as in #5307, the thread is started again when I start Flask with the ```--debug``` option.\r\n\r\nI do not seem to have the possibility from my own code to detect whether these threads are already active.   \r\nThe classes from which these threads are started and which hold their references, seem to be initialized again, although they are singletons.\r\n\r\n## Question\r\n\r\nI am not considering this as a bug.\r\n\r\nMy question is whether there is a possibility in ```create_app()```, to know that the app is being recreated on behalf of the autoloader.\r\n\r\n## Environment:\r\n\r\n- Python version: 3.11.2\r\n- Flask version: 3.0.0\r\n- Wekzeug version: 3.0.1\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5436",
    "comments": []
  },
  {
    "title": "Starter example results in 404 error",
    "body": "The basic example from the readme / flask docs throws a 404 error instead of returning the Hello World message\r\n\r\nIf you run the code from the example:\r\n\r\n```\r\n# save this as app.py\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\"/\")\r\ndef hello():\r\n    return \"Hello, World!\"\r\n```\r\n\r\nand then open 127.0.0.1:5000\r\n\r\n\r\nInstead of getting the Hello World message, you get a 404.\r\nWhen re-trying the app exits with code 0 instead of launching the server.\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.12\r\n- Flask version: 3.02\r\n\r\n\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5434",
    "comments": [
      "The next line down in the readme shows running `flask run` to run the development server.",
      "I did run it,\r\nI am not getting \"unable to reach\". I am getting 404 response from the\r\nactual flask app\r\n\r\nOn Fri, 8 Mar 2024 at 21:19, David Lord ***@***.***> wrote:\r\n\r\n> The next line down in the readme shows running flask run to run the\r\n> development server.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/pallets/flask/issues/5434#issuecomment-1986362352>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/ABUIXHOINNMZSZODJI3EPQTYXIMNFAVCNFSM6AAAAABENKIUZWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSOBWGM3DEMZVGI>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n\r\n\r\n-- \r\nGrzegorz Wilczek\r\n+48 607 79 79  17\r\n",
      "I can't reproduce this issue with the information provided. The example works correctly when I run it.",
      "OK, I can't reproduce it now either. Seems to have been an issue with my\r\nPyCharm and/or general Python configuration.\r\n\r\nOn Fri, 8 Mar 2024 at 23:23, David Lord ***@***.***> wrote:\r\n\r\n> I can't reproduce this issue with the information provided. The example\r\n> works correctly when I run it.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/pallets/flask/issues/5434#issuecomment-1986507989>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/ABUIXHIMN44WQF3O7UGXFQ3YXI24ZAVCNFSM6AAAAABENKIUZWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSOBWGUYDOOJYHE>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n\r\n\r\n-- \r\nGrzegorz Wilczek\r\n+48 607 79 79  17\r\n"
    ]
  },
  {
    "title": "Flask is not running when Debug is True on Windows",
    "body": "```\r\nfrom flask import Flask\r\napp = Flask(__name__)\r\nif __name__ == \"__main__\":\t\r\n\tapp.run(debug=True)\r\n```\r\nI made main.py like above. \r\nand tried to run it with below command\r\n`flask run --app test --debug`\r\n`python main.py`\r\nboth way got the error like below\r\n\r\n![image](https://github.com/pallets/flask/assets/45891661/d4b6ebc4-517c-41ba-9988-ce04172e2d1c)\r\n\r\n`Traceback (most recent call last):\r\n  File \"D:\\Employer\\Security Snares\\ransomsnare-backend\\flask\\test.py\", line 4, in <module>\r\n    app.run(debug=True)\r\n  File \"D:\\Employer\\Security Snares\\vee\\lib\\site-packages\\flask\\app.py\", line 615, in run\r\n    run_simple(t.cast(str, host), port, self, **options)\r\n  File \"D:\\Employer\\Security Snares\\vee\\lib\\site-packages\\werkzeug\\serving.py\", line 1077, in run_simple\r\n    srv = make_server(\r\n  File \"D:\\Employer\\Security Snares\\vee\\lib\\site-packages\\werkzeug\\serving.py\", line 917, in make_server\r\n    return ThreadedWSGIServer(\r\n  File \"D:\\Employer\\Security Snares\\vee\\lib\\site-packages\\werkzeug\\serving.py\", line 779, in __init__\r\n    self.socket = socket.fromfd(fd, address_family, socket.SOCK_STREAM)\r\n  File \"C:\\Users\\K_Teacher\\AppData\\Local\\Programs\\Python\\Python310\\lib\\socket.py\", line 545, in fromfd\r\n    nfd = dup(fd)\r\nOSError: [WinError 10038] An operation was attempted on something that is not a socket`\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10\r\n- Flask version: 2.3.2, 3.0.2\r\n- OS: Windows 10\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5432",
    "comments": [
      "As with previous reported incidences of this, I cannot reproduce this issue with the information provided. The dev server reloader tests pass on Windows in CI. When I run a project locally it works as expected as well. It is impossible for me to identify the issue or evaluate a proposed fix if I don't have a reproducing example to test against.\r\n\r\n```\r\n> mkdir example\r\n> cd example\r\n> py -3.12 -m venv .venv\r\n> .venv\\Scripts\\activate\r\n> pip install flask\r\n```\r\n\r\n```python\r\n# example.py\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\"/\")\r\ndef index():\r\n    return \"Hello, World!\"\r\n```\r\n\r\n```\r\n> flask -A example run --debug\r\n * Serving Flask app 'example'\r\n * Debug mode: on\r\nWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\r\n * Runnning on http://127.0.0.1:5000\r\nPress CTRL+C to quit\r\n * Restarting with stat\r\n * Debugger is active!\r\n * Debugger PIN: 123-456-789\r\n127.0.0.1 - - [06/Mar/2024 11:44:09] \"GET / HTTP/1.1\" 200 -\r\n * Detected change in 'C:\\\\Users\\\\David\\\\Projects\\\\example\\\\example.py', reloading\r\n * Restarting with stat\r\n * Debugger is active!\r\n * Debugger PIN: 123-456-789\r\n```"
    ]
  },
  {
    "title": "@app.errorhandler() cannot be used in blueprint when debug=False",
    "body": "I want to customize an error type in Flask, and then use `@app.errorhandler()` in the main program to capture it. Then, I define a function raise_error to actively throw this exception. When `debug=True` is enabled at runtime, both the main and blueprint routes can be used normally in the interface function. However, when `debug=False`, only the main route can be used, and the blueprint route cannot capture it and reports a program error,I hope someone  can help me take a look\r\nThere are two files in total(`mains.py`,`aaa.py`)\r\n\r\n```\r\n#python mains.py\r\nfrom flask import jsonify, Flask\r\nfrom typing import Union\r\napp = Flask(__name__)\r\n\r\nclass CustomError(Exception):\r\n    def __init__(self, message, status_code=500):\r\n        try:\r\n            self.message = message.__dict__\r\n        except Exception as e:\r\n            self.message = message\r\n        self.status_code = status_code\r\n\r\ndef raise_error(msg: Union[dict, str], status: Union[int, str] = 500):\r\n    raise CustomError(msg, status_code=status)\r\n\r\n@app.route(\"/\")\r\ndef home():\r\n    raise_error(\"this is error\")\r\n    return {}\r\n\r\nfrom aaa import router\r\napp.register_blueprint(router)\r\n\r\n@app.errorhandler(CustomError)\r\ndef handle_custom_exception(error: CustomError):\r\n    response = jsonify({\"code\": error.status_code, \"data\": error.message})\r\n    response.status = 20\r\n    return response\r\n\r\nif __name__ == \"__main__\":\r\n    # app.run(host=\"0.0.0.0\", port=7788, debug=True) #can in blueprint\r\n    app.run(host=\"0.0.0.0\", port=7788, debug=False)  # cannot in blueprint\r\n\r\n#python aaa.py\r\nfrom flask import Blueprint, jsonify\r\n\r\nrouter = Blueprint(\"aaa\", __name__, url_prefix=\"/aaa\")\r\n\r\n@router.get(\"/\")\r\ndef aaa():\r\n    from mains import raise_error\r\n    print(\"is runing\")\r\n    raise_error(\"this is eror in blueprint\")\r\n    return jsonify({\"data\": \"in blueprint\"})\r\n```\r\n\r\n```\r\nFlask==3.0.2\r\ntyping_extensions==4.10.0\r\npython == 3.12.2\r\n(my_flask) PS C:\\Users\\Administrator\\Desktop\\flask_project> & C:/ProgramData/miniconda3/envs/my_flask/python.exe c:/Users/Administrator/Desktop/flask_project/mains.py\r\n * Serving Flask app 'mains'\r\n * Debug mode: off\r\nWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\r\n * Running on all addresses (0.0.0.0)\r\n * Running on http://127.0.0.1:7788\r\n * Running on http://192.168.3.69:7788\r\nPress CTRL+C to quit\r\n127.0.0.1 - - [05/Mar/2024 11:10:07] \"GET / HTTP/1.1\" 20 -\r\n127.0.0.1 - - [05/Mar/2024 11:10:07] \"GET /favicon.ico HTTP/1.1\" 404 -\r\n127.0.0.1 - - [05/Mar/2024 11:10:12] \"GET /aaa HTTP/1.1\" 308 -\r\nis runing\r\n[2024-03-05 11:10:12,268] ERROR in app: Exception on /aaa/ [GET]\r\nTraceback (most recent call last):\r\n  File \"C:\\ProgramData\\miniconda3\\envs\\my_flask\\Lib\\site-packages\\flask\\app.py\", line 1463, in wsgi_app\r\n    response = self.full_dispatch_request()\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\ProgramData\\miniconda3\\envs\\my_flask\\Lib\\site-packages\\flask\\app.py\", line 872, in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\ProgramData\\miniconda3\\envs\\my_flask\\Lib\\site-packages\\flask\\app.py\", line 870, in full_dispatch_request\r\n    rv = self.dispatch_request()\r\n         ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\ProgramData\\miniconda3\\envs\\my_flask\\Lib\\site-packages\\flask\\app.py\", line 855, in dispatch_request\r\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"c:\\Users\\Administrator\\Desktop\\flask_project\\aaa.py\", line 11, in aaa\r\n    raise_error(\"this is eror in blueprint\")\r\n  File \"c:\\Users\\Administrator\\Desktop\\flask_project\\mains.py\", line 17, in raise_error\r\n    raise CustomError(msg, status_code=status)\r\nmains.CustomError: this is eror in blueprint\r\n127.0.0.1 - - [05/Mar/2024 11:10:12] \"GET /aaa/ HTTP/1.1\" 500 -\r\n127.0.0.1 - - [05/Mar/2024 11:10:12] \"GET /favicon.ico HTTP/1.1\" 404 -\r\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5430",
    "comments": []
  },
  {
    "title": "Secret Key Rotation",
    "body": "Hi everyone,\r\n\r\nI have started working with Flask in the last month and I noticed that there could be an improvement on secret key managment for sessions; specifically I am taking as reference OWASP Top 10 [Cryptographic Failures](https://owasp.org/Top10/A02_2021-Cryptographic_Failures/) on the point where it talks about the importance of proper key managment (that isn't flask responsibility) and rotation.\r\n\r\nI saw that there is a closed issue on that topic, however that was from 10 years ago, a lot of time passed so I thought it would be a nice thing pointing that out; I understand that this implies session invalidating when the secret key changes, but I think that this could be a choice left to developers based on security requirements of the specific system, therefore adding more flexibility.\r\n\r\nIf I am wrong in any way or it isn't feasible I hope that someone can provide me a good explanation about why.\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5428",
    "comments": [
      "Same previously closed discussions still apply. "
    ]
  },
  {
    "title": "Keep code running after response has been sent. (To respond with HTTP requests to other servers) ",
    "body": "Ability to send a response but continue execution.\r\n\r\nAn example of this problem is a backend Flask server which receives requests from another backend server, and returns one or more responses at different points in time. One such example is Telegram API.\r\n\r\nhttps://core.telegram.org/bots/faq#how-can-i-make-requests-in-response-to-updates\r\n\r\nWhile it is possible to simply send data back as an HTTP response, it is sometimes desirable to close the HTTP connection with a 200 to acknowledge the message has been received, and reopen a new connection for each response.\r\n\r\nHere are some scenarios where this technique might be useful:\r\n\r\n- Multiple messages are sent in a progressively more detailed nature, to ensure that errors in complex responses don't compromise simple responses. For example Response(\"Hello\") Response (\"Error\") Response(\"Error 194:blablabla\")\r\n- Separating messages carry a semantic meaning. For example: Response(\"Ok so here's the plan\\n We leave at 9 am \\n ...\") != Response(\"Ok so here's the plan\") Response(\"We leave at 9 am\") Response(\"...\")\r\n- Responses may be scheduled for the future, well after the http connection closes by timeout.\r\n\r\nCan we solve this without a builtin? Yeah sure, we can use threading or multiprocessing or libraries like celery. \r\n\r\nI think that the ideal solution is to integrate the multi threading into existing flask multithreading (Main server loop), and ideally integrating it into production one worker process per hardware core configurations to avoid both GIL issues and one process per request overheads.\r\n\r\n\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5427",
    "comments": [
      "That's now how HTTP works. There's one response (status code / headers). Of course you can send/stream whatever you want in the body, but it doesn't sound like you want to do that...",
      "Thanks for the response Adrian. \r\n\r\nI understand that each Request can only have one response. Not sure what would even happen if two responses are sent in response to one request, don't care.\r\n\r\nWhat this thread is about is, recognizing that limitation, many server-to-server servers that need to send more than one response per request, effectively send nothing on the corresponding http response, but send new HTTP requests altogether, in all likelihood the responses of these second requests is ignored as well.\r\n\r\nThis image from the docs linked above should clarify\r\n\r\n![image](https://github.com/pallets/flask/assets/153238260/fc0da526-2d31-4164-b2b3-f32b49306a28)\r\n\r\nAs you can see the traditional approach is diagrammed in 2. But the approach I'm referring to is diagrammed in 1. This allows multiple replies (Outgoing Request) per incoming request to the Flask server.\r\n",
      "This may be out of scope for flask, I will take a look into using Werkzeug directly, which may have a more native approach towards this, that may not even need threading, in essence we just want to (send a response/do stuff) without closing the inbound-request-thread.\r\n\r\nIt's just that in Flask sending an HTTP response and closing the request-thread seem to be tightly coupled.  Perhaps there is a way and I'm just ignorant of it. I typically send an http response returning from a function marked as a route, maybe there's something like flask.respond(200,\"Hello\")\r\n\r\nIf not, that would be the ideal API flask.respond(status_code,body), function may be called respondAndContinue if you want to avoid confusion.",
      "You're looking for a background task queue. https://flask.palletsprojects.com/en/3.0.x/patterns/celery/",
      "I suppose one could import thousands of lines of code and add yet another layer of scheduling abstraction.\r\n\r\nBut I'd rather remove than add\r\n\r\n",
      "This is a good use case for Quart and the background tasks."
    ]
  },
  {
    "title": "transfer-encoding: debug server behavior differs from test client ",
    "body": "With code like:\r\n\r\n`            resp = make_response(file.open(\"rb\"))\r\n           return resp\r\n`\r\n\r\nthe debug server automatically kicks into transfer-encoding chunked mode:\r\n\r\n```\r\ncurl -svo /dev/null -X GET localhost:8080/src/cond-mat/9805021 2>&1 | grep \"^<\"\r\n< HTTP/1.1 200 OK\r\n< Server: Werkzeug/2.3.7 Python/3.11.2\r\n< Date: Thu, 29 Feb 2024 21:14:59 GMT\r\n< Transfer-Encoding: chunked\r\n< Connection: close`\r\n```\r\nbut in a unit test it does not go into Transfer-Encoding chunked mode or the header is missing:\r\n```\r\n\r\nclient_with_test_fs = <FlaskClient <Flask 'browse'>>, path = '/src/', paperid = 'cond-mat/9805021'\r\nexpected_file = 'arXiv-cond-mat9805021v2.gz', desc = 'single file .gz'\r\n\r\n    @pytest.mark.parametrize(\"path,paperid,expected_file,desc\", [ [\"/src/\"]+c for c in cases] )\r\n    def test_src(client_with_test_fs, path, paperid, expected_file, desc ):\r\n        client = client_with_test_fs\r\n        resp = client.get(path + paperid)\r\n        assert resp\r\n        assert resp.status_code == 200\r\n>       assert resp.headers[\"Transfer-Encoding\"] == \"chunked\" # Must do chunked on a raw get for Cloud run large obj\r\n\r\ntests/test_src.py:70: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = Headers([])\r\nkey = 'Transfer-Encoding', _get_mode = False\r\n\r\n    def __getitem__(self, key, _get_mode=False):\r\n        if not _get_mode:\r\n            if isinstance(key, int):\r\n                return self._list[key]\r\n            elif isinstance(key, slice):\r\n                return self.__class__(self._list[key])\r\n        if not isinstance(key, str):\r\n            raise BadRequestKeyError(key)\r\n        ikey = key.lower()\r\n        for k, v in self._list:\r\n            if k.lower() == ikey:\r\n                return v\r\n        # micro optimization: if we are in get mode we will catch that\r\n        # exception one stack level down so we can raise a standard\r\n        # key error instead of our special one.\r\n        if _get_mode:\r\n            raise KeyError()\r\n>       raise BadRequestKeyError(key)\r\nE       werkzeug.exceptions.BadRequestKeyError: 400 Bad Request: The browser (or proxy) sent a request that this server could not understand.\r\n\r\n../../.pyenv/versions/3.11.2/envs/browse-311/lib/python3.11/site-packages/werkzeug/datastructures/headers.py:73: BadRequestKeyError              \r\n`\r\n\r\n\r\nI would expect the debug server and the test client to work the same.\r\n\r\nEnvironment:\r\n\r\n- Python version:  3.11\r\n- Flask version: 2.2.5",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5424",
    "comments": [
      "Whether `Transfer-Encoding: chunked` is used is a property of any given WSGI server in front of the application. It's not something Flask/Werkzeug the WSGI application chooses, it's something the server chooses. Besides the presence of the header, there should be no difference in the data received in the response, so there's no reason to test if the encoding was chunked. That would be testing the behavior of the server, not of the application."
    ]
  },
  {
    "title": "Flask logging - Other libraries - FileHandler creates duplicate log entries",
    "body": "**Description**\r\n\r\nIn my web server, based on Flask 3.0.0, ([raspi-cam-srv](https://github.com/signag/raspi-cam-srv)), I want to log to a log file.   \r\nFor implementation, I followed the Flask [Logging](https://flask.palletsprojects.com/en/3.0.x/logging/) documentation.   \r\n\r\nFor app and my own modules, I have added a FileHandler with\r\n\r\n```\r\n    # Configure loggers\r\n    logsPath = os.path.dirname(app.instance_path) + \"/logs\"\r\n    os.makedirs(logsPath, exist_ok=True)\r\n    logFile = logsPath + \"/raspiCamSrv.log\"\r\n    Path(logFile).touch(exist_ok=True)\r\n    filehandler = logging.FileHandler(logFile)\r\n    filehandler.setFormatter(app.logger.handlers[0].formatter)\r\n    for logger in(\r\n        app.logger,\r\n        logging.getLogger(\"werkzeug\"),\r\n        logging.getLogger(\"raspiCamSrv.camera_pi\"),\r\n    ):\r\n        logger.addHandler(filehandler)\r\n        logger.setLevel(logging.ERROR)\r\n```\r\n\r\nAs a result, I see duplicate entries for each log entry in the log file (see attachments, below).   \r\nThe log output on the console has single entries.\r\n\r\n**Note**\r\n\r\nI did not add the default_handler to the loggers as described in the Flask [Logging](https://flask.palletsprojects.com/en/3.0.x/logging/) documentation.   \r\nWhen doing this, I get duplicate log entries also from the StreamHandler to the console.\r\n\r\n**How to reproduce the bug**\r\n\r\nThis is the ```__init__.py```:  [__init__.py.txt](https://github.com/pallets/flask/files/14402038/__init__.py.txt)\r\nThis is the log file:  [raspiCamSrv.log](https://github.com/pallets/flask/files/14402051/raspiCamSrv.log)\r\nThis is the console output; [console.log](https://github.com/pallets/flask/files/14402057/console.log)\r\n\r\n**Expected behavior**\r\n\r\nEvery log entry should occur only once\r\n\r\n**Environment:**\r\n\r\n- Python version: 3.11.2\r\n- Flask version: 3.0.0\r\n- Wekzeug version: 3.0.1\r\n",
    "labels": [
      "docs"
    ],
    "url": "https://github.com/pallets/flask/issues/5422",
    "comments": [
      "just FYI, `flask run` should never be used for production setups, it's ONLY meant for development.\r\nso dealing with the werkzeug dev server logger logging stuff should be a non-issue for production usage...",
      "Thanks, I know",
      "I found the solution:\r\nIt is sufficient to add the FileHandler only to the app Logger:\r\n```\r\n    # Configure loggers\r\n    logsPath = os.path.dirname(app.instance_path) + \"/logs\"\r\n    os.makedirs(logsPath, exist_ok=True)\r\n    logFile = logsPath + \"/raspiCamSrv.log\"\r\n    Path(logFile).touch(exist_ok=True)\r\n    filehandler = logging.FileHandler(logFile)\r\n    filehandler.setFormatter(app.logger.handlers[0].formatter)\r\n    for logger in(\r\n        app.logger,\r\n        logging.getLogger(\"werkzeug\"),\r\n        logging.getLogger(\"raspiCamSrv.camera_pi\"),\r\n    ):\r\n        logger.setLevel(logging.ERROR)\r\n    app.logger.addHandler(filehandler)\r\n```\r\n\r\nObviously, by some Flask magic, the other loggers get the FileHandler added, too.\r\n\r\nWith this modification, all log entries occur just once in the log file.\r\n",
      "It's a mistake in the docs. Instead of `app.logger` in the loop, it should be `logging.getLogger(app.name)`. The docs were trying to say that logging should be configured before accessing `app.logger`, which is undermined if it's accessed during logging configuration. \ud83e\udd26\ud83c\udffc\u200d\u2642\ufe0f",
      "I tried with\r\n\r\n```\r\n    # Configure loggers\r\n    logsPath = os.path.dirname(app.instance_path) + \"/logs\"\r\n    os.makedirs(logsPath, exist_ok=True)\r\n    logFile = logsPath + \"/raspiCamSrv.log\"\r\n    Path(logFile).touch(exist_ok=True)\r\n    filehandler = logging.FileHandler(logFile)\r\n    filehandler.setFormatter(app.logger.handlers[0].formatter)\r\n    for logger in(\r\n        logging.getLogger(app.name),\r\n        logging.getLogger(\"werkzeug\"),\r\n        logging.getLogger(\"raspiCamSrv.camera_pi\"),\r\n    ):\r\n        logger.addHandler(filehandler)\r\n        logger.setLevel(logging.ERROR)\r\n```\r\n\r\n... and get duplicate log entries in the log file again.",
      "You accessed `app.logger` a few lines up. ",
      "From the docs you linked:\n\n> When you want to configure logging for your project, you should do it as soon as possible when the program starts. If app.logger is accessed before logging is configured, it will add a default handler.",
      "> You accessed `app.logger` a few lines up.\r\n\r\nOK, I had overseen this one.   \r\nBut nevertheless, having the default_handler added, is OK for me.\r\n\r\nNow, I tried with (this is the complete start of ```__init__.py``` and there is no access to a logger afterwards)\r\n\r\n```\r\nimport os\r\nfrom pathlib import Path\r\nfrom flask import Flask\r\nimport logging\r\nfrom flask.logging import default_handler\r\nfrom picamera2 import Picamera2\r\nimport json\r\n\r\ndef create_app(test_config=None):\r\n    # create and configure the app\r\n    app = Flask(__name__, instance_relative_config=True)\r\n    app.config.from_mapping(\r\n        SECRET_KEY=\"dev\",\r\n        DATABASE=os.path.join(app.instance_path, \"raspiCamSrv.sqlite\"),\r\n    )\r\n\r\n    # ensure the instance folder exists\r\n    try:\r\n        os.makedirs(app.instance_path)\r\n    except OSError:\r\n        pass\r\n    \r\n    # Configure loggers\r\n    logsPath = os.path.dirname(app.instance_path) + \"/logs\"\r\n    os.makedirs(logsPath, exist_ok=True)\r\n    logFile = logsPath + \"/raspiCamSrv.log\"\r\n    Path(logFile).touch(exist_ok=True)\r\n    filehandler = logging.FileHandler(logFile)\r\n    filehandler.setFormatter(default_handler.formatter)\r\n    for logger in(\r\n        logging.getLogger(app.name),\r\n        logging.getLogger(\"werkzeug\"),\r\n        logging.getLogger(\"raspiCamSrv.auth\"),\r\n        logging.getLogger(\"raspiCamSrv.auth_su\"),\r\n        logging.getLogger(\"raspiCamSrv.camCfg\"),\r\n        logging.getLogger(\"raspiCamSrv.camera_pi\"),\r\n        logging.getLogger(\"raspiCamSrv.config\"),\r\n        logging.getLogger(\"raspiCamSrv.home\"),\r\n        logging.getLogger(\"raspiCamSrv.images\"),\r\n        logging.getLogger(\"raspiCamSrv.info\"),\r\n        logging.getLogger(\"raspiCamSrv.settings\"),\r\n        logging.getLogger(\"raspiCamSrv.photoseries\"),\r\n        logging.getLogger(\"raspiCamSrv.photoseriesCfg\"),\r\n    ):\r\n        logger.addHandler(default_handler)    \r\n        logger.addHandler(filehandler)    \r\n        logger.setLevel(logging.DEBUG)\r\n\r\n```\r\n... and get duplicate log entries for my own modules in the log file **as well as in console output**.   \r\nFor module ```_internal```, there is a single entry.   \r\n\r\nWhen I omit ``` logger.addHandler(default_handler) ```,    \r\nI get **no** log output on the console and again duplicate log output for my own modules in the log file",
      "Sounds like you have other issues. Logging configuration is confusing in general for Python. I'll fix the docs issue I commented about, but otherwise can't help with your specific issue here. ",
      "Thanks a lot for your support.   \r\nI returned to the previous solution which works, even if it isn't according to the docs.",
      "Docs fixed in adb7dd99c295a28726c8d818fba54c7b3f958ecc"
    ]
  },
  {
    "title": "Route Aliases",
    "body": "I think it would be cool if there were built-in aliases for routes, for example:\r\n\r\n```py\r\n@route(\r\n    \"/information\",\r\n    aliases=[\"/info\", \"/faq\"] # <- They all show the same thing as the main route `/information`.\r\n)\r\n```\r\n\r\nIt might be useless to some, but I don't. I think it would be useful to allow people to define multiple aliases for one route. It is possible as of now using this code I made:\r\n\r\n```py\r\nfrom typing import List, Callable, Union\r\nfrom flask import Flask, wraps, redirect, jsonify\r\n\r\napp = Flask(__name__)\r\n\r\ndef route(name: str, aliases: List[str] = [], **options) -> Callable:\r\n    def decorator(func: Callable) -> Callable:\r\n        @app.route(name, **options)\r\n        @wraps(func)\r\n        async def wrapper(*args, **kwargs) -> Union[redirect, jsonify]:\r\n            return await func(*args, **kwargs)\r\n\r\n        [app.route(alias, **options)(wrapper) for alias in aliases]\r\n\r\n        return wrapper\r\n\r\n    return decorator\r\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5418",
    "comments": [
      "Your aliases should probably redirect and not result in multiple URLs doing the same thing... it's generally considered bad to have duplicate content on the web w/o redirects to the canonical URL.\r\nAlso, don't abuse list comprehensions where a for loop would be appropriate.\r\n\r\nIn any case, this is something you can easily implement in your own app if you want it.",
      "> Your aliases should probably redirect and not result in multiple URLs doing the same thing... it's generally considered bad to have duplicate content on the web w/o redirects to the canonical URL. Also, don't abuse list comprehensions where a for loop would be appropriate.\r\n> \r\n> In any case, this is something you can easily implement in your own app if you want it.\r\n\r\nMy code was something I created on the spot. I haven't taken a comprehensive look at it, as you mentioned, duplicate content on the web. I mean, would it be better if I made them all redirect back to the main route?"
    ]
  },
  {
    "title": "The dependency specifiers are too relaxed",
    "body": "Good day!\r\n\r\nWe have dependency specifiers in such way:\r\nhttps://github.com/pallets/flask/blob/b90a4f1f4a370e92054b9cc9db0efcb864f87ebe/pyproject.toml#L22-L24\r\n\r\nBut indeed `Werkzeug>=3.0.0` should be `Werkzeug>=3.0.0,<4` or `Werkzeug>=3.0.0,<3.1` or `Werkzeug==3.0.0`, etc.\r\n\r\nGot it when I installed `flask==2.0.2` and got an incompatible `Werkzeug==3.0.2` along.\r\n\r\nThanks!",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5414",
    "comments": [
      "You are not supposed to install old versions in new projects - and in old projects you are supposed to have pinned your transitive dependencies. There are MANY other issues with some useful links on that topic.",
      "But these issue could be fixed by... just being correct, couldn't?\r\n\r\nhttps://github.com/pallets/flask/blob/3.0.2/pyproject.toml#L23 says: `the flask 3.0.2 requires any version of Werkzeug greater than or equal to 3.0.0`. And this statement is (just) false, isn't it?\r\n\r\nWhich reason to have a logically incorrect code instead of a correct one?",
      "There is no way to change the metadata of existing releases. We can't go back and say \"actually, 2.0.2 is only compatible with N\". So even if we made a release that added a maximum version (we won't) it wouldn't fix you not being able to install the specific old version without specifying other dependency versions.\r\n\r\nThis is why, when starting development of an application, you use a tool such as [pip-tools](https://pypi.org/project/pip-tools/) to pin your application's full dependency tree. This gives you reproducible deployments if you need to recreate the environment later."
    ]
  },
  {
    "title": "CHIPS support",
    "body": "Add an argument for `set_cookie` to add `Partitioned;` attribute to the Set-Cookie header.\r\n\r\nAccording to Google, third-party cookies will soon be deprecated. [link](https://developers.google.com/privacy-sandbox/3pcd/prepare/prepare-for-phaseout)\r\nFor cross-site cookies which store data on a per site basis, like an embed, will need to migrate to [CHIPS](https://developers.google.com/privacy-sandbox/3pcd/chips), which uses `partitioned` storage to store cookies.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5412",
    "comments": [
      "Duplicate of https://github.com/pallets/werkzeug/issues/2797"
    ]
  },
  {
    "title": "Add domain support to Blueprint",
    "body": "Currently, Blueprints support a `url_prefix` and a `subdomain` option. I would like to see support for a `domain` option.\r\n\r\nI need to host the same codebase on two different sites, but with some of the routes only available to one domain and others only to the other, and roughly 3/4 of routes available on both sites.\r\n\r\nI don't want to split the codebase into two because 95% of the code is the same. Checking for `request.host` on every route (even with a route decorator) is cumbersome. Having this at the level of Blueprints would make the most sense.\r\n\r\nThere's [a way to support multiple domains](https://gist.github.com/tachyondecay/a17960d5d8276387e7cf6982760e7ec2) but it does not allow for the sharing of routes.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5411",
    "comments": [
      "I'm not clear what the request is here. You should already be able to do this with `host_matching=True`. For the 5% that app A needs, make a blueprint only for A's domain, same for the 5% that only B needs.",
      "Maybe you're saying that `Blueprint()` does not take a `host=` parameter. But `bp.register()` _does_ take a `host` parameter. So you can still apply this to all routes on a blueprint without change, you just have to specify it at registration instead of at creation.",
      "I want some routes to be available to example.org only, others to somesite.com only, and some to both. Didn't find any example of how to do it with Blueprints.\r\n\r\nWhat's `bp.register()`? ",
      "Sorry, meant `app.register_blueprint`. But you can do that. You can have any layout you want with blueprints. So make some that are shared, some that have `host=first_host`, and some that have `second_host`.\r\n\r\n```python\r\na_bp = Blueprint()\r\nb_bp = Blueprint()\r\nshared_bp = Blueprint()\r\n\r\napp.register_blueprint(a_bp, host=\"a\")\r\napp.register_blueprint(b_bp, host=\"b\")\r\napp.register_blueprint(shared_bp)\r\n```\r\n\r\nSomething along those lines. Sorry, I don't really use this feature, so I don't have a ready made environment to spin up to answer your specific question.",
      "i have the following example:\r\n\r\n```python\r\n\"\"\"\r\nattempt at an MVCE for Flask with domain blueprints (Flask 3.x)\r\npython3 flaskapp-with-blueprint-example-1.py\r\n\"\"\"\r\n\r\nfrom flask import Blueprint, Flask, request\r\n\r\n\r\ndef create_app():\r\n    app = Flask(__name__)\r\n\r\n    first_bp = Blueprint('first', __name__)\r\n    second_bp = Blueprint('second', __name__)\r\n    shared_bp = Blueprint('shared', __name__)\r\n\r\n    @first_bp.route('/')\r\n    def first_home():\r\n        return f\"\"\"route meant only for first.localhost\"\"\"\r\n\r\n    @second_bp.route('/')\r\n    def second_home():\r\n        return f\"\"\"route meant only for second.localhost\"\"\"\r\n\r\n    @shared_bp.route('/shared')\r\n    def shared_page():\r\n        return f\"\"\"this route should work with both domains\"\"\"\r\n\r\n    app.register_blueprint(first_bp, host=\"first.localhost\")\r\n    app.register_blueprint(second_bp, host=\"second.localhost\")\r\n    app.register_blueprint(shared_bp)\r\n\r\n    return app\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app = create_app()\r\n    app.run(\r\n        debug=True,\r\n        host='0.0.0.0',\r\n        port=6123,\r\n\r\n        # if running it inside of my docker container:\r\n        # ssl_context=(\r\n        #     \"/etc/apache2/ssl/SSLforMyHosts-certificate.pem\",\r\n        #     \"/etc/apache2/ssl/SSLforMyHosts-key.pem\",\r\n        # ),\r\n    )\r\n    \r\n\"\"\"adding these lines to your /etc/hosts file should be enough to get up and running:\r\n127.0.0.1 first.localhost\r\n127.0.0.1 second.localhost\r\n\"\"\"\r\n```\r\n\r\n\r\n\r\nit runs, but not as expected:\r\n\r\n- http://first.localhost:6123/ returns \"route meant only for first.localhost\" (ok)\r\n- http://second.localhost:6123/ returns \"route meant only for first.localhost\" as well which is wrong. expected to get \"route meant only for second.localhost\".\r\n- http://first.localhost:6123/shared returns \"this route should work with both domains\" (ok)\r\n- http://second.localhost:6123/shared returns \"this route should work with both domains\" (ok)\r\n\r\n\r\ni thought maybe i need this to set `app` instead:\r\n\r\n```\r\napp = Flask(__name__, host_matching=True, static_host='first.localhost')\r\n```\r\n\r\nbut then every route becomes 404 Not Found.\r\n\r\ni don't understand what `static_host` is. i guess it's the host used to serve static data but it's counter-intuitive that i should set it to a single value when working with multiple domains. likewise for `app.config['SERVER_NAME']` (i don't understand if i'm supposed to set it or not, either way setting it to 'first.localhost' did not help in the examples above.)\r\n\r\n\r\nno offense but the documentation could be clearer. `host_matching` and domain are not mentioned once on the blueprints page (only subdomains are.)\r\n\r\n"
    ]
  },
  {
    "title": "send_file doesn't work with objects",
    "body": "I had a file in an object of type io.BytesIO(), but when I put this object in a send_file made me the error that the parameter is incorrect.\r\nIn the version 2 this work well but in the version 3.0.2 doesn't.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.12\r\n- Flask version: 3.0.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5408",
    "comments": [
      "I can't reproduce the issue with the information provided. When reporting an issue, be sure to include a minimal reproducible example and the full traceback."
    ]
  },
  {
    "title": "Extend Config type",
    "body": "At the moment, Pylance, when in strict mode, report an error when trying to use app config. \r\nThe return type of `app.config[\"KEY\"]` is `Unknown`\r\n\r\nFirst time contribution to an open source project, i want to try and see if i can tell Flask to take into account changes made to `App.config_class` for type hints\r\n\r\nPython 3.12\r\n\r\n<!--\r\nReplace this comment with an example of the problem which this feature\r\nwould resolve. Is this problem solvable without changes to Flask, such\r\nas by subclassing or using an extension?\r\n-->\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5407",
    "comments": [
      "That's because `config` is a dict-like interface with arbitrary keys and values, so there's no way to say what an arbitrary key's type is. You can probably write a class that uses attribute access or a `TypedDict` instead to specify the types of known keys, but that only covers the keys you know about, not the extra ones that extensions or applications may use, which is presumably the interesting ones. But subclassing `Config` to provide other type information shouldn't require anything from Flask itself. You're welcome to explore this, and if you discover that something in Flask is needed, then please open a specific issue about that."
    ]
  },
  {
    "title": "Blueprint Dynamic URL For `string` vs. `path`",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n## Context\r\n\r\nNot sure if this is a bug or intentional feature. When using Blueprint route with Flask, I understand routes with trailing `/` can be used to handle routes with and without `/`. (e.g. `/api/do/stuff` and `/api/do/stuff/`.\r\n\r\nWhen you have route:\r\n\r\n```python\r\n@blueprint_api.route('/project/<string:category>/', methods=['POST'])\r\ndef project_category(category):\r\n    ...\r\n```\r\n\r\nWhen user enters a route `/project/food/`, it will return what `project_category` does and returns, but when user enters `/project/food`, it will redirect to `/project/food/`.\r\n\r\nSo if you don't want the redirect, you might do something like:\r\n\r\n```python\r\n@blueprint_api.route('/project/<string:category>', methods=['POST'])  # 200 OK\r\n@blueprint_api.route('/project/<string:category>/', methods=['POST'])  # 200 OK\r\ndef project_category(category):\r\n    ...\r\n```\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\n## Replicate\r\n\r\nNow this works fine if the dynamic route uses `string` type, but it seem to be working differently for `path` type.\r\n\r\n```python\r\n@blueprint_api.route('/project/<path:category>', methods=['POST'])  # 308 PERMANENT REDIRECT\r\n@blueprint_api.route('/project/<path:category>/', methods=['POST'])  # 200 OK\r\ndef project_category(category):\r\n    ...\r\n```\r\n\r\nWith the `path` type, even when you specify both routes, the route **without** the trailing `/` will still redirect to route with trailing `/` even though it is specified as a route.\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\n## Expect\r\n\r\nI was expecting the same behavior for both `string` type dynamic route parameter and `path` type dynamic route parameter?\r\n\r\nEnvironment: macOS 14.3 (23D56)\r\n\r\n- Python version: 3.10.11\r\n- Flask version: 3.0.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5405",
    "comments": []
  },
  {
    "title": "`FileStorage` closed unexpectedly when using `copy_current_request_context`",
    "body": "Whilst using boto3 for some S3 work in Flask, I needed to register an [event hook](https://boto3.amazonaws.com/v1/documentation/api/1.34.29/guide/events.html) which led to me discovering that `request.files[...]` get closed before the request is completely handled.\r\n\r\nI found what looks like one of the events runs in a different thread so I wrapped the hook with `copy_current_request_context` which worked, but then found that by doing this, after calling `object.load()` (triggering the hooks) that `request.files[...]` is closed prematurely.\r\n\r\nAfter some digging I found https://github.com/pallets/werkzeug/issues/1685 which I guess meant that some how the file streams loose context whilst bouncing through the thread and into another context (the copy of the original request context). I know that reported issue is for the main `request.stream`, but this affects the `FileStorage` streams under `request.files`.\r\n\r\nTo reproduce it here is the minimal code I managed to get this occurring with; only difference between `test_work` and `test_bust` is the use of `session.events.register(...)`.\r\n```\r\nimport boto3\r\nfrom flask import Flask, abort, copy_current_request_context, request\r\n\r\napp = Flask(__name__)\r\n\r\ndef _test(params, **kwargs):\r\n\r\n    pass\r\n\r\n@app.route('/work', methods=['GET', 'POST'])\r\ndef test_work():\r\n\r\n    if 'test' not in request.files:\r\n        abort(400)\r\n    file = request.files['test']\r\n\r\n    session = boto3.session.Session()\r\n\r\n    s3 = session.resource('s3')\r\n    object = s3.Object('test', 'test')\r\n    try:\r\n        object.load()\r\n    except:\r\n        pass\r\n\r\n    return { 'closed': request.stream.closed, 'file': file.closed }\r\n\r\n@app.route('/bust', methods=['GET', 'POST'])\r\ndef test_bust():\r\n\r\n    if 'test' not in request.files:\r\n        abort(400)\r\n    file = request.files['test']\r\n\r\n    session = boto3.session.Session()\r\n    session.events.register('provide-client-params.s3', copy_current_request_context(_test))\r\n\r\n    s3 = session.resource('s3')\r\n    object = s3.Object('test', 'test')\r\n    try:\r\n        object.load()\r\n    except:\r\n        pass\r\n\r\n    return { 'closed': request.stream.closed, 'file': file.closed }\r\n```\r\n\r\nSpin up a local S3 endpoint, though running one means you are not waiting 10 seconds for the retry logic in boto3 to give up:\r\n```\r\ndocker run -it --rm -p 9000:9000 -p 9001:9001 quay.io/minio/minio server --console-address :9001 /data\r\n```\r\n\r\nRun with:\r\n```\r\nenv AWS_ACCESS_KEY_ID=minioadmin AWS_SECRET_ACCESS_KEY=minioadmin AWS_ENDPOINT_URL=http://localhost:9000 ./.venv/bin/flask --app test run\r\n```\r\n\r\nTest with:\r\n```\r\n$ echo hello world > test.txt\r\n$ curl -sS --fail-with-body -D /dev/stderr -F 'test=@test.txt' http://localhost:5000/work\r\nHTTP/1.1 200 OK\r\nServer: Werkzeug/3.0.1 Python/3.11.2\r\nDate: Mon, 29 Jan 2024 10:01:58 GMT\r\nContent-Type: application/json\r\nContent-Length: 30\r\nConnection: close\r\n\r\n{\"closed\":false,\"file\":false}\r\n```\r\n\r\nAnd test the failure (where `file` gets closed) with:\r\n```\r\nalex@hanzawa:~/src/kx/downloads$ curl -sS --fail-with-body -D /dev/stderr -F 'test=@test.txt' http://localhost:5000/bust\r\nHTTP/1.1 200 OK\r\nServer: Werkzeug/3.0.1 Python/3.11.2\r\nDate: Mon, 29 Jan 2024 10:02:42 GMT\r\nContent-Type: application/json\r\nContent-Length: 29\r\nConnection: close\r\n\r\n{\"closed\":false,\"file\":true}\r\n```\r\n\r\nMy expectation is that `file` remains open until I return my response from `test_bust`.\r\n\r\nMy use case is I need to pass `FileStorage` to an S3 upload request, so obviously with the file handle closed, that makes it somewhat difficult :)\r\n\r\nI worked around the problem by using `functools.partial` and just shimming over what I needed instead of using `request`, but reporting this in case it is considered a bug or at least so others can find this and prevent themselves losing hours of their lives trying to figure out what is happening.\r\n\r\nMy environment is:\r\n\r\n- Python version: 3.11.2\r\n- Flask version: 3.0.1\r\n- Boto3 version: 1.34.29",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5399",
    "comments": [
      "It's not possible to copy the stream (and thus the files) from the initial request to the copied request. It's not possible to copy open file-like objects in general. What `copy_current_request_context` copies is the context, not the request the context refers to. So both context still refer to the same data. Once the view or other function ends (whichever first), the context is popped which triggers cleaning up the request it's associated with. Therefore as said in the other issue you linked, you need to store file data first so that it is available separately from the request data."
    ]
  },
  {
    "title": "use ThreadPoolExecutor and copy_current_request_context  in flask will appear some bug",
    "body": "in app.py file: \r\n```\r\nfrom flask import Flask\r\napp = Flask(__name__)\r\n\r\n@app.route(\"/\")\r\ndef hello_world():\r\n    from test2 import start\r\n    start()\r\n    return \"<p>Hello, World!</p>\"\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug=True)\r\n```\r\n\r\n\r\nin test2 file:\r\n```\r\nfrom flask import copy_current_request_context\r\nimport time\r\nfrom concurrent.futures import ThreadPoolExecutor\r\nimport threading\r\n\r\n@copy_current_request_context\r\ndef function_a(number):\r\n    print(threading.current_thread().ident)\r\n    time.sleep(1)\r\n    return number\r\n\r\ndef start():\r\n    with ThreadPoolExecutor(max_workers=5) as executor:\r\n        response = list(executor.map(function_a, [1, 2]))\r\n    return response\r\n```\r\n\r\nwhen i request this api , it will appear \"AssertionError: Popped wrong app context. (&lt;flask.ctx.AppContext object at 0x00000167CB79A3C8&gt; instead of &lt;flask.ctx.AppContext object at 0x00000167CB79A668&gt;) // Werkzeug Debugger\", how to resolve it?  thanks!",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5396",
    "comments": []
  },
  {
    "title": "Issue matching route with methods=['OPTIONS'] when similar route appears later using ['GET', 'POST']",
    "body": "With routing setup like this:\r\n\r\n```\r\nclass ApiHandler:\r\n\r\n  @route_with('/<regex(\"(.*)\"):path>', methods = ['OPTIONS'])\r\n  def cors(self, path):\r\n    # Send custom CORS headers\r\n    # This should be matched for any request\r\n    return make_response('OK', 200)\r\n\r\n  @route_with('/post/<regex(\"(.*)\"):id>', methods = ['GET', 'POST'])\r\n  def post(self, id):\r\n    # This should only be matched on GET / POST for \"/post/<id>\"\r\n    return make_response('You are at the post', 200)\r\n```\r\n\r\nThe `cors` handler never gets run if an `OPTIONS` request is made to `/post/123` with the above setup.\r\n\r\nInstead, strangely, a blank `200` reponse is returned (with no logs besides the single request entry shown in the logs).\r\n\r\nIf an `OPTIONS` request is made to any other URL (or if the `post` handler is commented out), the `cors` handler is correctly run.\r\n\r\nI've tried running this in multiple Flask version all the way from `1.1.4` to `3.0.1`, to no avail.\r\n\r\nThis appears to be a bug in Flask's / Werkzeug's routing.\r\n\r\nAnyone encountered something similar or have any suggestions on what I can do to diagnose / fix?",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5395",
    "comments": [
      "Similar issue happened years ago, but the solution in the closed issue does not work:\r\n\r\nhttps://github.com/pallets/flask/issues/3187",
      "What is `route_with`? That's not from Flask.\r\n\r\nWhat is the `regex()` converter type? That's not from Flask. Other people with that type have had problems because its implementation needed to be changed for Werkzeug 3.\r\n\r\nI used `provide_automatic_options=False` and it worked as expected.\r\n\r\n```python\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\"/<path:path>\", methods=[\"OPTIONS\"])\r\n@app.route(\"/\", methods=[\"OPTIONS\"], defaults={\"path\": \"\"})\r\ndef handle_options(path: str) -> str:\r\n    return \"options\"\r\n\r\n\r\n@app.route(\"/post/<int:id>\", methods=[\"GET\", \"POST\"], provide_automatic_options=False)\r\ndef post(id: int) -> str:\r\n    return f\"post {id}\"\r\n```",
      "Thanks for the quick response @davidism .\r\n\r\nMy apologies, `route_with` is a decorator which in turn calls `blueprint.add_url_rule()`.\r\n\r\n`regex()` is a custom routing converter, similar to:\r\n\r\nhttps://gist.github.com/ekayxu/5743138\r\n\r\nDoes the fact we are calling `blueprint.add_url_rule()` instead of using the `@app.route` decorator increase the chance that the route is somehow handled differently when matched by Werkzeug?"
    ]
  },
  {
    "title": "Invalid `SERVER_NAME` + `url_for` leads to `AttributeError`",
    "body": "In our environment we have some security scanners running which generate artificial HTTP requests. Since they are closed source and I can't generate these calls with other tools, I created the below example which starts at the flask level and assumes that an invalid server passed thru the levels. \r\n\r\n```py\r\nfrom flask import Flask, url_for\r\n\r\napp = Flask(__name__)\r\n\r\n@app.errorhandler(400)\r\ndef do_400(e):\r\n    url_for(\"foo\")\r\n    return \"error\", 400\r\n\r\n\r\nres = app(\r\n    {\r\n        \"ACTUAL_SERVER_PROTOCOL\": \"HTTP/1.1\",\r\n        \"PATH_INFO\": \"/\",\r\n        \"QUERY_STRING\": \"\",\r\n        \"REQUEST_METHOD\": \"GET\",\r\n        \"REQUEST_URI\": \"/\",\r\n        \"SCRIPT_NAME\": \"\",\r\n        \"SERVER_NAME\": \"foobar/..\",\r\n        \"SERVER_PROTOCOL\": \"HTTP/1.1\",\r\n        \"wsgi.url_scheme\": \"https\",\r\n    },\r\n    lambda x, y: None,\r\n)\r\n```\r\n\r\nError\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"work/venv/lib/python3.12/site-packages/werkzeug/routing/map.py\", line 258, in bind\r\n    server_name = server_name.encode(\"idna\").decode(\"ascii\")\r\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".pyenv/versions/3.12.0/lib/python3.12/encodings/idna.py\", line 173, in encode\r\n    raise UnicodeError(\"label empty or too long\")\r\nUnicodeError: label empty or too long\r\nencoding with 'idna' codec failed\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"work/venv/lib/python3.12/site-packages/flask/app.py\", line 1484, in full_dispatch_request\r\n    rv = self.dispatch_request()\r\n         ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"work/venv/lib/python3.12/site-packages/flask/app.py\", line 1458, in dispatch_request\r\n    self.raise_routing_exception(req)\r\n  File \"work/venv/lib/python3.12/site-packages/flask/app.py\", line 1440, in raise_routing_exception\r\n    raise request.routing_exception  # type: ignore\r\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"work/venv/lib/python3.12/site-packages/flask/ctx.py\", line 316, in __init__\r\n    self.url_adapter = app.create_url_adapter(self.request)\r\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"work/venv/lib/python3.12/site-packages/flask/app.py\", line 1883, in create_url_adapter\r\n    return self.url_map.bind_to_environ(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"work/venv/lib/python3.12/site-packages/werkzeug/routing/map.py\", line 371, in bind_to_environ\r\n    return Map.bind(\r\n           ^^^^^^^^^\r\n  File \"work/venv/lib/python3.12/site-packages/werkzeug/routing/map.py\", line 260, in bind\r\n    raise BadHost() from e\r\nwerkzeug.exceptions.BadHost: 400 Bad Request: The browser (or proxy) sent a request that this server could not understand.\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"work/venv/lib/python3.12/site-packages/flask/app.py\", line 2190, in wsgi_app\r\n    response = self.full_dispatch_request()\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"work/venv/lib/python3.12/site-packages/flask/app.py\", line 1486, in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"work/venv/lib/python3.12/site-packages/flask/app.py\", line 1341, in handle_user_exception\r\n    return self.handle_http_exception(e)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"work/venv/lib/python3.12/site-packages/flask/app.py\", line 1281, in handle_http_exception\r\n    return self.ensure_sync(handler)(e)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"work/foo.py\", line 9, in do_400\r\n    url_for(\"foo\")\r\n  File \"work/venv/lib/python3.12/site-packages/flask/helpers.py\", line 225, in url_for\r\n    return current_app.url_for(\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"work/venv/lib/python3.12/site-packages/flask/app.py\", line 1686, in url_for\r\n    rv = url_adapter.build(  # type: ignore[union-attr]\r\n         ^^^^^^^^^^^^^^^^^\r\nAttributeError: 'NoneType' object has no attribute 'build'\r\n```\r\n\r\nAs you can see, the server_name passed to flask is invalid. This should normally not happen, but let's just assume that it might happen. In my case I use cheroot and it let's it thru.\r\nThen the server name should be encoded with IDNA which fails and that is fine. However, then the custom error handler for 400 is called and in my case it contains a `url_for` call. This call then fails with an `AttributeError` because the request was never fully consumed by flask.\r\n\r\nEven if this seems now a little bit artificial, I would like to ask, if flask could improve its handling here, I have the following ideas\r\n1. Don't call custom error handlers when such an error occurs\r\n2. Have a nicer exception than `AttributeError` so that the caller of `url_for` can handle it gracefully\r\n3. Handle a `None` `url_adapter` in `url_for`\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.12.0\r\n- Flask version: 2.3.3\r\n- Werkzeug: 2.3.8\r\n_This error also happens with flask/werkzeug 3.0_\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5392",
    "comments": [
      "I'm having a hard time evaluating this. None of the suggested fixes are really useful.\r\n\r\n1 is not possible. 3 is not possible, except to \"handle\" it by raising an error, which is what happens when the app context (instead of request context) can't create an adapter. 2 is possible, at least to raise a clearer error message closer to where the problem occurs, as explained for 3, but it shouldn't be something the dev should consider handling, since ultimately it's an issue with the server environment.\r\n\r\nThere is a little known feature called `app.url_build_error_handlers`, which is a list of handlers to call when `adapter.build()` raises a `BuildError`. Right now, it's _only_ called when `adapter.build()` fails with a `BuildError`, not for other errors or errors raised by Flask when wrapping that call. This could be extended so that the `RuntimeError` and `ValueError` that `url_for` raises in certain situations would be a `BuildError` instead and pass through the same handlers. By default, no handlers means that the error is re-raised.",
      "Thanks for checking this. I know it's a weird one, with not a clear path forward.\n\nI like the idea to register a url build error handler \ud83d\udc4d",
      "Hi, I now found a reproducible example by just providing an invalid Host header value. I also reported it to cheroot: https://github.com/cherrypy/cheroot/issues/646",
      "After thinking about this more, I'm going to close it for now. It seems to be mainly a server configuration issue rather than an issue with Flask. I don't think spending time resurrecting/changing an unused feature in Flask is really worth it for this.",
      "Anyways, thanks for the time analysis this. I hugkly appreciate it! "
    ]
  },
  {
    "title": "Flask 3.0.1 breaks path-separated command line arguments",
    "body": "In a minimal flask app, running `flask run --extra-files=` or using any other argument that internally uses `SeparatedPathType` results in `TypeError: super(type, obj): obj must be an instance or subtype of type`\r\n\r\n\r\n\r\n1. Create a minimal flask application (follow [the Quickstart](https://flask.palletsprojects.com/en/3.0.x/quickstart/#a-minimal-application)).\r\n2. Install flask==3.0.1 (this bug is not reproducible with 3.0.0 AFAIK)\r\n3. Run `flask run --extra-files=a`\r\n\r\n**Expected Behavior:**\r\nThe server should start up.\r\n\r\n**Actual Behavior:**\r\nThe command raises a `Type Error` and exits with code 1\r\n\r\n<details><summary>Full Traceback</summary>\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \".../flask-cli-bug/..venv/bin/flask\", line 8, in <module>\r\n    sys.exit(main())\r\n             ^^^^^^\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/flask/cli.py\", line 1105, in main\r\n    cli.main()\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/click/core.py\", line 1078, in main\r\n    rv = self.invoke(ctx)\r\n         ^^^^^^^^^^^^^^^^\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/click/core.py\", line 1686, in invoke\r\n    sub_ctx = cmd.make_context(cmd_name, args, parent=ctx)\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/click/core.py\", line 943, in make_context\r\n    self.parse_args(ctx, args)\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/click/core.py\", line 1408, in parse_args\r\n    value, args = param.handle_parse_result(ctx, opts, args)\r\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/click/core.py\", line 2400, in handle_parse_result\r\n    value = self.process_value(ctx, value)\r\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/click/core.py\", line 2356, in process_value\r\n    value = self.type_cast_value(ctx, value)\r\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/click/core.py\", line 2344, in type_cast_value\r\n    return convert(value)\r\n           ^^^^^^^^^^^^^^\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/click/core.py\", line 2316, in convert\r\n    return self.type(value, param=self, ctx=ctx)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/click/types.py\", line 83, in __call__\r\n    return self.convert(value, param, ctx)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/flask/cli.py\", line 861, in convert\r\n    return [super().convert(item, param, ctx) for item in items]\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".../flask-cli-bug/..venv/lib/python3.11/site-packages/flask/cli.py\", line 861, in <listcomp>\r\n    return [super().convert(item, param, ctx) for item in items]\r\n            ^^^^^^^\r\nTypeError: super(type, obj): obj must be an instance or subtype of type\r\n```\r\n</details>\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.6\r\n- Flask version: 3.0.1\r\n\r\nOutput from `pip freeze`:\r\n```\r\nblinker==1.7.0\r\nclick==8.1.7\r\nFlask==3.0.1\r\nitsdangerous==2.1.2\r\nJinja2==3.1.3\r\nMarkupSafe==2.1.4\r\nWerkzeug==3.0.1\r\n```\r\n\r\nDemo Repo: https://github.com/alexrudy/flask-3.0.1-cli-bug\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5391",
    "comments": [
      "I can confirm that this bug was introduced in 3.0.1. In our case, we're using the `--exclude-patterns` command line parameter.\r\n\r\n# versions\r\n\r\n- python 3.11.5\r\n- flask 3.0.1\r\n- click 8.1.7\r\n- ubuntu 22.04.1\r\n\r\n# command\r\n\r\n```bash\r\nflask --app app:start run --debug --exclude-patterns \"*/tests/*:*/venv/*:*/temp/*\"\r\n```\r\n\r\n# traceback\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"<frozen runpy>\", line 198, in _run_module_as_main\r\n  File \"<frozen runpy>\", line 88, in _run_code\r\n  File \"<project>/venv/lib/python3.11/site-packages/flask/__main__.py\", line 3, in <module>\r\n    main()\r\n  File \"<project>/venv/lib/python3.11/site-packages/flask/cli.py\", line 1105, in main\r\n    cli.main()\r\n  File \"<project>/venv/lib/python3.11/site-packages/click/core.py\", line 1078, in main\r\n    rv = self.invoke(ctx)\r\n         ^^^^^^^^^^^^^^^^\r\n  File \"<project>/venv/lib/python3.11/site-packages/click/core.py\", line 1686, in invoke\r\n    sub_ctx = cmd.make_context(cmd_name, args, parent=ctx)\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"<project>/venv/lib/python3.11/site-packages/click/core.py\", line 943, in make_context\r\n    self.parse_args(ctx, args)\r\n  File \"<project>/venv/lib/python3.11/site-packages/click/core.py\", line 1408, in parse_args\r\n    value, args = param.handle_parse_result(ctx, opts, args)\r\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"<project>/venv/lib/python3.11/site-packages/click/core.py\", line 2400, in handle_parse_result\r\n    value = self.process_value(ctx, value)\r\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"<project>/venv/lib/python3.11/site-packages/click/core.py\", line 2356, in process_value\r\n    value = self.type_cast_value(ctx, value)\r\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"<project>/venv/lib/python3.11/site-packages/click/core.py\", line 2344, in type_cast_value\r\n    return convert(value)\r\n           ^^^^^^^^^^^^^^\r\n  File \"<project>/venv/lib/python3.11/site-packages/click/core.py\", line 2316, in convert\r\n    return self.type(value, param=self, ctx=ctx)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"<project>/venv/lib/python3.11/site-packages/click/types.py\", line 83, in __call__\r\n    return self.convert(value, param, ctx)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"<project>/venv/lib/python3.11/site-packages/flask/cli.py\", line 861, in convert\r\n    return [super().convert(item, param, ctx) for item in items]\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"<project>/venv/lib/python3.11/site-packages/flask/cli.py\", line 861, in <listcomp>\r\n    return [super().convert(item, param, ctx) for item in items]\r\n            ^^^^^^^\r\nTypeError: super(type, obj): obj must be an instance or subtype of type\r\n```",
      "Ah, this was because in Python 3.12, list comprehensions no longer execute in a separate hidden function scope. So no-arg `super()` became valid, which is what I saw when cleaning up things locally, but still didn't work on older Python versions."
    ]
  },
  {
    "title": "jinja_loader type bug",
    "body": "I have\r\n```Python\r\nfrom jinja2 import ChoiceLoader, FileSystemLoader\r\n\r\n\r\napp.jinja_loader = ChoiceLoader([\r\n    FileSystemLoader(project_dir / 'templates/'),\r\n    app.jinja_loader,\r\n])\r\n```\r\n\r\nThere is a mypy error\r\n```\r\nerror: Incompatible types in assignment (expression has type \"ChoiceLoader\", variable has type \"FileSystemLoader | None\")  [assignment]\r\nerror: List item 1 has incompatible type \"FileSystemLoader | None\"; expected \"BaseLoader\"  [list-item]\r\n```\r\n\r\nThere shouldn't be an error.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.12.1\r\n- Flask version: 3.0.1\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5388",
    "comments": []
  },
  {
    "title": "Session data is not untagged properly when using other JSON providers",
    "body": "Providers such as `orjson` and `ujson` do not implement `object_hook`. The \"tagged JSON\" scheme used to encode types for session data currently calls `loads(data, object_hook=...)`, so providers that ignore that option return the data still tagged. Untagging needs to be implemented without using `object_hook`.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5381",
    "comments": []
  },
  {
    "title": "Improve error messages on simple after request hook bugs",
    "body": "When a user forgets to return the response in an `after_request` hook, the message is particularly unhelpful as it does not point to the involvement of the hook:\r\n\r\n```python\r\nfrom flask import Flask\r\napp = Flask(\"test\")\r\n\r\n# oops\r\napp.after_request(lambda _: None)\r\n\r\n@app.get(\"/hello\")\r\ndef get_hello():\r\n    return \"hello world!\", 200\r\n```\r\n\r\nRun:\r\n```sh\r\nflask --debug -A app run\r\ncurl -si -X GET http://0.0.0.0:5000/hello\r\n```\r\n\r\nResults in:\r\n```\r\nTypeError\r\n\r\nTypeError: 'NoneType' object is not callable\r\nTraceback (most recent call last)\r\n\r\n    File \"/home/fabien/tmp/test/venv/lib/python3.12/site-packages/flask/app.py\", line 1478, in __call__\r\n\r\n    return self.wsgi_app(environ, start_response)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n    File \"/home/fabien/tmp/test/venv/lib/python3.12/site-packages/flask/app.py\", line 1462, in wsgi_app\r\n\r\n    return response(environ, start_response)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n    TypeError: 'NoneType' object is not callable\r\n```\r\n\r\nI suggest that the error message *should* point to the involvement of the after request hook.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5380",
    "comments": [
      "I'm hesitant to do this at runtime. It would require checking the return value of every `after_request` function call for every request, overhead that isn't necessary if things are written correctly. This check would also run away from where the function was defined or registered, so the traceback wouldn't be any more useful. This is something type checking should pick up, because `after_request` functions should be annotated to return a response."
    ]
  },
  {
    "title": "Donating Funds to Flask",
    "body": "Hi Flask maintainers. I'm Lucas, a core contributor to the Drips project (drips dot network). I help recipients of donations through their learning and onboarding process.\r\n\r\nOctant (octant dot build) (a project from the Golem Foundation) has been using https://github.com/pallets/flask. It's one of their most critical dependencies!\r\n\r\nOctant\u2019s core contributors appreciate the work you all do and want to make sure that you are all well-funded to keep doing it. For that reason, they have decided to donate some funds to your project through\u00a0Drips.\r\n\r\nWho can I talk to about it?",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5379",
    "comments": [
      "We already have funding sources set up, which can be found through GitHub's \"Sponsor\" button on each of our repositories. If any project would like to donate to us, they can do so through:\r\n\r\n* GitHub sponsors: https://github.com/sponsors/pallets\r\n* Python Software Foundation: https://psfmember.org/civicrm/contribute/transact/?reset=1&id=20\r\n* Tidelift: https://tidelift.com/funding/github/pypi/Flask\r\n\r\nIf your platform has already taken their donation as if they were donating to us, then they should be refunded so they can direct their funds to the appropriate location.",
      "> We already have funding sources set up, which can be found through GitHub's \"Sponsor\" button on each of our repositories. If any project would like to donate to us, they can do so through:\r\n> \r\n> * GitHub sponsors: https://github.com/sponsors/pallets\r\n> * Python Software Foundation: https://psfmember.org/civicrm/contribute/transact/?reset=1&id=20\r\n> * Tidelift: https://tidelift.com/funding/github/pypi/Flask\r\n> \r\n> If your platform has already taken their donation as if they were donating to us, then they should be refunded so they can direct their funds to the appropriate location.\r\n\r\nHi @davidism,\r\n\r\nThank you for your quick response. I understand Flask is using certain platforms to accept donations, but none of them seem to accept cryptocurrencies.\r\n\r\nThe funder organization would like to donate in ETH because this is the asset they have.\r\n\r\nAre you open to receiving cryptocurrencies, or is there a policy against it?\r\n\r\nIf Yes, let\u2019s discuss how you can receive these funds.\r\nIf No, no worries. We can inform the funder and redirect those funds elsewhere.\r\n\r\nThank you",
      "hi @davidism, just wanted to hear your thoughts on this. \r\n\r\nLet me know if you have any questions, or if you all have made a decision on how to move forward. "
    ]
  },
  {
    "title": "Can I contribute ",
    "body": "Hi I'm @Yuheshpandian. I love Flask and its capabilities, in fact when I wanted to learn _web dev_ , with only the knowledge of `Python`, I went for Flask without hesitation. I had made some projects using Flask, also a modern boilerplate for `flask` projects. Now I wanted to Contribute to my go to web framework in Python. \r\n\r\nI just want to contribute and make changes in the README.md/Documetation.\r\n\r\nThank You",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5373",
    "comments": [
      "that's not what issues are for... please see https://github.com/pallets/flask/blob/main/CONTRIBUTING.rst",
      "> that's not what issues are for... please see https://github.com/pallets/flask/blob/main/CONTRIBUTING.rst\r\n\r\nno actually I asked a willing/permission, if the `pallets` would like me to contribute, I was not reporting any vulnearability/bugs or request a feature. ",
      "This is an open source project. If you can make useful contributions we're happy about them. And the link I posted literally recommends you to:\r\n\r\n- not use the issue tracker for support-like questions (which yours here is, this would have been better suited in discussions or on our discord)\r\n- open an issue to discuss if you think there's something you may want to contribute\r\n\r\nIt is up to you to find something you find worth contributing, either coming up with something you think would be useful (open an issue about it in that case), or finding an issue you'd like to work on (but considering there's just one issue open right now that might be hard).",
      "yeah thank you for spending your valuable time I would sure follow the Contributing guidelines and make my contributions. Thank your for you kind guidance.",
      "Also please note that one-line \"I think this could be worded differently\" changes to readme/docs are usually not useful, *especially* if they do not actually fix e.g. incorrect spelling/grammar.",
      "In this and other projects, please stick to open issues that are unassigned and do not yet have PRs submitted. You'll notice that Flask and Werkzeug have very few of those, so they're not good targets for first time contributors. Within Pallets, Click and Jinja have open issues, but those tend to be more complex or confusing, so still probably not good targets. The Flask extension ecosystem however is very large, and tends to receive much less contributor attention, so you may want to look around there for something that is actively maintained and needs help."
    ]
  },
  {
    "title": "I'm seeing \"GET /socket.io/?EIO=3&transport=polling&t=OozzqO3 HTTP/1.1\" 404 errors running a simple flask app",
    "body": "I created a \"Hello World\" flask app (which can be found here: https://github.com/dhylands/flask-hello/tree/main\r\n\r\nIf I create a virtual environment and install flask and then do `flask run` I get the following output:\r\n```\r\n * Debug mode: off\r\nWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\r\n * Running on http://127.0.0.1:5000\r\nPress CTRL+C to quit\r\n127.0.0.1 - - [30/Dec/2023 19:42:28] \"GET /socket.io/?EIO=3&transport=polling&t=OozzqO3 HTTP/1.1\" 404 -\r\n127.0.0.1 - - [30/Dec/2023 19:42:33] \"GET /socket.io/?EIO=3&transport=polling&t=OozzrcF HTTP/1.1\" 404 -\r\n127.0.0.1 - - [30/Dec/2023 19:42:33] \"GET /socket.io/?EIO=3&transport=polling&t=OozzrcI HTTP/1.1\" 404 -\r\n127.0.0.1 - - [30/Dec/2023 19:42:38] \"GET /socket.io/?EIO=3&transport=polling&t=OozzsqT HTTP/1.1\" 404 -\r\n```\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nI'd expect to not see errors/warnings about socket.io\r\n\r\nEnvironment:\r\n - Pop_OS! (aka ubuntu) 22.04 LTS\r\n- Python version:  Python 3.10.12\r\n- Flask version: 3.0.0\r\n\r\npip freeze reports:\r\n```\r\nblinker==1.7.0\r\nclick==8.1.7\r\nFlask==3.0.0\r\nitsdangerous==2.1.2\r\nJinja2==3.1.2\r\nMarkupSafe==2.1.3\r\nWerkzeug==3.0.1\r\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5372",
    "comments": [
      "You have something making those requests, so you see them. If you didn't write code to do that, perhaps a browser extension?",
      "Hmm - yep - you're right. When I quit my browser they stopped, so there must have been a browser window open someplace that was doing that. Sorry for the noise."
    ]
  },
  {
    "title": "Edit required in documentation: https://flask.palletsprojects.com/en/3.0.x/patterns/javascript/ #Replacing Content",
    "body": "<!--\r\nThis is code example given in documentation:\r\n\r\n<div id=\"geology-fact\">\r\n    {{ include \"geology_fact.html\" }}\r\n</div>\r\n-->\r\n\r\n<!--\r\nThe inner curly braces should be replaced with percentage signs:\r\n<div id=\"geology-fact\">\r\n    {% include \"geology_fact.html\" %}\r\n</div>\r\n-->\r\n\r\n<!--\r\nThe example code is meant to allow a portion of the content to be replaced. The current version with double curly brackets results in a error when running. The documentation needs to be updated to reflect the correct syntax.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version:\r\n- Flask version: 3.0.x\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5371",
    "comments": []
  },
  {
    "title": "Application Setup Tutorial doesn't work",
    "body": "### Description\r\nIf you try to run the Flask application by following this tutorial it doesn't work: https://flask.palletsprojects.com/en/3.0.x/tutorial/factory/\r\n\r\n### Suggested solution\r\nIn my personal project, I created an app.py file and in there I pasted the following code:\r\n\r\n```\r\nfrom flaskr import create_app\r\n\r\napp = create_app()\r\n\r\nif __name__ == '__main__':\r\n    app.run()\r\n```\r\n    \r\nI run this file and the Flask app can initialize.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5368",
    "comments": [
      "I can't reproduce this issue with the information provided. The tutorial code is included in the repo if you want to compare if you missed or typoed something. It runs fine for me. There's no need to create the script you've shown, the `flask` command shown in the tutorial already does that for you. "
    ]
  },
  {
    "title": "GPU performance issues of flask framework",
    "body": "When I loaded an ultralytics YOLO model outside the framework, I read the image from the client in a request processing function and performed inference. I found that the inference speed was 10 times slower than normal.\r\nI don\u2019t have this problem when I use fastapi.\r\n\r\n```python\r\nfrom flask import Flask, request\r\n\r\nfrom ultralytics import YOLO\r\nimport cv2\r\nimport numpy\r\nimport base64\r\nmodel = YOLO(\"/workspace/yolov8s.pt\")\r\ndef b64_cv(frame_b64):\r\n    return cv2.imdecode(numpy.frombuffer(base64.b64decode(frame_b64), numpy.uint8), cv2.IMREAD_COLOR)\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route('/frame', methods=['POST'])\r\ndef read_item():\r\n    data = request.json\r\n    frame = data.get('frame', None)\r\n    \r\n    results = model(source=b64_cv(frame))\r\n\r\n    return {}\r\n\r\nif __name__ == '__main__':\r\n    app.run(host='0.0.0.0', port=8000)\r\n```\r\n\r\n```python\r\nimport requests\r\nimport cv2\r\nimport numpy\r\nimport base64\r\n\r\ndef cv_b64(frame_cv):\r\n    return str(base64.b64encode(cv2.imencode(\".jpg\", frame_cv)[1]))[2:-1]\r\n\r\nwhile True:\r\n    stream = cv2.VideoCapture(\"/workspace/road_30_1920x1080.mp4\")\r\n    while stream.isOpened():\r\n        ret, frame = stream.read()\r\n        if not ret: break\r\n\r\n        data = {\"frame\": cv_b64(frame)}\r\n        response = requests.post(url=\"http://127.0.0.1:8000/frame\", json=data)\r\n\r\n```\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.12\r\n- Flask version: 3.0.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5366",
    "comments": []
  },
  {
    "title": "Getting Error - TemplateNotFound(template)",
    "body": "Getting below error though I placed the templates in right place and right directory.\r\n\r\n\"jinja2.exceptions.TemplateNotFound: auth/register.html\"\r\n\r\n\r\nI followed the instructions until the end of below page and tried to run my flask app\r\nhttps://flask.palletsprojects.com/en/3.0.x/tutorial/templates/\r\n\r\nGot the above error.\r\n\r\n\r\n\r\nExpected to see register page without any errors\r\nhttp://127.0.0.1:5000/auth/register\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11\r\n- Flask version: 3.0.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5364",
    "comments": []
  },
  {
    "title": "cli::ScriptInfo in versions >2.2.0 does not read FLASK_APP environment variable when invoked from command line",
    "body": "<!--\r\nhttps://github.com/pallets/flask/commit/99fa3c36abc03cd5b3407df34dce74e879ea377a#diff-fed8939d1905b99bba605ad91e9ccdf5ede6223e03ccbc3f0121853035051e62L343 removed the ability to invoke CLI commands directly using `python -m`\r\n-->\r\n\r\nhttps://github.com/pallets/flask/commit/99fa3c36abc03cd5b3407df34dce74e879ea377a#diff-fed8939d1905b99bba605ad91e9ccdf5ede6223e03ccbc3f0121853035051e62L343 removed the ability to invoke CLI commands directly using `python -m` by setting `FLASK_APP`\r\n\r\nPre 2.2.0 this works\r\n```\r\n$ FLASK_APP=myapp.commands.foo python3 -m myapp.commands.foo US\r\n```\r\n-->\r\n\r\nAfter 2.2.0 it fails like\r\n\r\n```\r\n$ FLASK_APP=myapp.commands.foo python3 -m myapp.commands.foo US\r\n\r\n'FLASK_ENV' is deprecated and will not be used in Flask 2.3. Use 'FLASK_DEBUG' instead.\r\nUsage: python -m myapp.commands.foo \r\n           [OPTIONS] COUNTRY_CODE\r\nTry 'python -m mayapp.commands.foo --help' for help.\r\n\r\nError: Could not locate a Flask application. Use the 'flask --app' option, 'FLASK_APP' environment variable, or a 'wsgi.py' or 'app.py' file in the current directory.\r\n```\r\n\r\nThis is especially confusing because Flask was able to parse CLI options.\r\n\r\nE.g. of a file `myapp.commands.foo.py`\r\n\r\n```python\r\nimport click\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\n@app.cli.command(\"foo\")\r\n@click.argument(\"country_code\")\r\ndef main(country_code: str, **kwargs):\r\n    print(\"I want this to work so bad\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n```\r\n\r\n\r\nExpected behavior:\r\n[ScriptInfo.app_import_path](https://github.com/pallets/flask/blob/main/src/flask/cli.py#L283) defaults to reading `FLASK_APP` environment variable if `app_import_path` is `None` when `ScriptInfo.__init__` is invoked.\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version:N/A\r\n- Flask version:>2.2.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5363",
    "comments": [
      "You'll want to invoke your commands through the `flask` command. If you want a custom entry point you can define your own `FlaskGroup`, but that's not really a public API. "
    ]
  },
  {
    "title": "Can't run tests without installing it",
    "body": "An attempt to run test without installing flask leads to fail:\r\n```\r\n:info:test cls = <class 'importlib.metadata.Distribution'>, name = 'flask'\r\n:info:test     @classmethod\r\n:info:test     def from_name(cls, name):\r\n:info:test         \"\"\"Return the Distribution for the given package name.\r\n:info:test     \r\n:info:test         :param name: The name of the distribution package to search for.\r\n:info:test         :return: The Distribution instance (or subclass thereof) for the named\r\n:info:test             package, if found.\r\n:info:test         :raises PackageNotFoundError: When the named package's distribution\r\n:info:test             metadata cannot be found.\r\n:info:test         \"\"\"\r\n:info:test         for resolver in cls._discover_resolvers():\r\n:info:test             dists = resolver(DistributionFinder.Context(name=name))\r\n:info:test             dist = next(dists, None)\r\n:info:test             if dist is not None:\r\n:info:test                 return dist\r\n:info:test         else:\r\n:info:test >           raise PackageNotFoundError(name)\r\n:info:test E           importlib.metadata.PackageNotFoundError: flask\r\n:info:test /opt/local/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/importlib/metadata.py:177: PackageNotFoundError\r\n:info:test ========================================================================================== short test summary info ==========================================================================================\r\n:info:test FAILED tests/test_cli.py::test_get_version - importlib.metadata.PackageNotFoundError: flask\r\n:info:test ================================================================================= 1 failed, 468 passed, 7 skipped in 2.68s ==================================================================================\r\n\r\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5362",
    "comments": [
      "That's correct, as explained in the contributing guide. "
    ]
  },
  {
    "title": "JavaScript .js file content type default is text/javascript but could be application/javascript",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\nReplication: serve a static `.js` file from a directory.\r\n\r\n\r\n```\r\n$ cat app.py\r\nfrom flask import Flask, send_from_directory\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\"/static/<path:path>\")\r\ndef route_static(path):\r\n    \"\"\"/static/\"\"\"\r\n    return send_from_directory(\"static\", path)\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug=True)\r\n\r\n```\r\n\r\n```\r\ncat static/x.js \r\n/*example*/\r\n\r\n```\r\n\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nThe behavior I get is \r\n```\r\nContent-Type\r\n\ttext/javascript; charset=utf-8\r\n```\r\n\r\nI would expect\r\n```\r\nContent-Type\r\n\tapplication/javascript; charset=utf-8\r\n```\r\n\r\nSee https://stackoverflow.com/a/189877/1320237\r\n\r\n---\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.6\r\n- Flask version: 3.0.0\r\n\r\n```\r\n$ pip list\r\nPackage      Version\r\n------------ -------\r\nblinker      1.7.0\r\nclick        8.1.7\r\nFlask        3.0.0\r\nitsdangerous 2.1.2\r\nJinja2       3.1.2\r\nMarkupSafe   2.1.3\r\npip          23.2\r\nsetuptools   68.2.2\r\nWerkzeug     3.0.1\r\nwheel        0.41.2\r\n```\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5361",
    "comments": [
      "You'll need to take that up with Python, we're using their `mimetypes.guess_type` function."
    ]
  },
  {
    "title": "Tutorial Database code doesn't work",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\nFollow the Tutorial doc through the \"Define and Access the Database\" doc. When you try and initialize the db, you will be greeted with an error\r\n\r\n`AttributeError: 'AppGroup' object has no attribute 'add_command'`\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version:\r\n- Flask version:\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5359",
    "comments": [
      "I can't reproduce this issue, `AppGroup` subclasses `click.Group`, which does provide `add_command`. The linked PR does not seem related."
    ]
  },
  {
    "title": "jsonify does not support integer keys",
    "body": "The snippets below are self-descriptive and reflect the problem mentioned in the title.\r\n\r\nExpected behavior: jsonify builds a response irrespective of the key/value data types (at least for basic types like int and str)  \r\n\r\nActual behavior: keys of type `int` break `jsonify`  \r\n\r\nPersonal suggestion: just typecast to str, but issue a warning\r\n\r\n\r\nMinimal code to reproduce the issue:\r\n\r\n```\r\nfrom flask import Flask, jsonify\r\nimport json\r\n\r\nd={32: \"aa\", \"something\":\"else\"}\r\n\r\nprint(json.dumps(d)) # works # <-------\r\n\r\napp = Flask('app')\r\n\r\n# app.config['JSON_SORT_KEYS'] = False  #<-- makes no difference\r\n\r\nwith app.app_context():\r\n    print(jsonify(d)) # b0rks # <-------\r\n```\r\n\r\n\r\nError log:\r\n```\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-12-d8fbf48063d9> in <module>\r\n      1 with app.app_context():\r\n----> 2     jsonify(d)\r\n      3\r\n\r\n~/.local/lib/python3.10/site-packages/flask/json/__init__.py in jsonify(*args, **kwargs)\r\n    168     .. versionadded:: 0.2\r\n    169     \"\"\"\r\n--> 170     return current_app.json.response(*args, **kwargs)\r\n\r\n~/.local/lib/python3.10/site-packages/flask/json/provider.py in response(self, *args, **kwargs)\r\n    213\r\n    214         return self._app.response_class(\r\n--> 215             f\"{self.dumps(obj, **dump_args)}\\n\", mimetype=self.mimetype\r\n    216         )\r\n\r\n~/.local/lib/python3.10/site-packages/flask/json/provider.py in dumps(self, obj, **kwargs)\r\n    178         kwargs.setdefault(\"ensure_ascii\", self.ensure_ascii)\r\n    179         kwargs.setdefault(\"sort_keys\", self.sort_keys)\r\n--> 180         return json.dumps(obj, **kwargs)\r\n    181\r\n    182     def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\r\n\r\n/usr/lib/python3.10/json/__init__.py in dumps(obj, skipkeys, ensure_ascii, check_circular, allow_nan, cls, indent, separators, default, sort_keys, **kw)\r\n    236         check_circular=check_circular, allow_nan=allow_nan, indent=indent,\r\n    237         separators=separators, default=default, sort_keys=sort_keys,\r\n--> 238         **kw).encode(obj)\r\n    239\r\n    240\r\n\r\n/usr/lib/python3.10/json/encoder.py in encode(self, o)\r\n    197         # exceptions aren't as detailed.  The list call should be roughly\r\n    198         # equivalent to the PySequence_Fast that ''.join() would do.\r\n--> 199         chunks = self.iterencode(o, _one_shot=True)\r\n    200         if not isinstance(chunks, (list, tuple)):\r\n    201             chunks = list(chunks)\r\n\r\n/usr/lib/python3.10/json/encoder.py in iterencode(self, o, _one_shot)\r\n    255                 self.key_separator, self.item_separator, self.sort_keys,\r\n    256                 self.skipkeys, _one_shot)\r\n--> 257         return _iterencode(o, 0)\r\n    258\r\n    259 def _make_iterencode(markers, _default, _encoder, _indent, _floatstr,\r\n\r\nTypeError: '<' not supported between instances of 'str' and 'int'\r\n```\r\n\r\n- Python version: Python 3.10.12\r\n- Flask version: Flask 2.3.3\r\n- Werkzeug 2.3.7\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5356",
    "comments": [
      "If you have data that is not serializable to JSON, you'll need to process that data first. Libraries like Marshmallow, attrs/cattrs, Pydantic, and others, are available that can do that."
    ]
  },
  {
    "title": "Cannot import Markup from flask (v3.0.0) ",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\nAs [previously reported](https://github.com/pallets/flask/issues/5084). \r\n\r\n### A\r\n\r\n```python\r\nimport flask\r\n\r\nprint(flask.Markup('hi'))\r\n```\r\n\r\n \r\n\r\n```text\r\nTraceback (most recent call last):\r\n  File \"/tmp/fl/mu1.py\", line 3, in <module>\r\n    print(flask.Markup('hi'))\r\n  File \"/tmp/fl/.venv/lib/python3.10/site-packages/flask/__init__.py\", line 60, in __getattr__\r\n    raise AttributeError(name)\r\nAttributeError: Markup\r\n```\r\n\r\n### B\r\n```python\r\nfrom flask import Markup\r\n\r\nprint(Markup('hi'))\r\n```\r\n \r\n```\r\nTraceback (most recent call last):\r\n  File \"/tmp/fl/mu2.py\", line 1, in <module>\r\n    from flask import Markup\r\nImportError: cannot import name 'Markup' from 'flask' (/tmp/fl/.venv/lib/python3.10/site-packages/flask/__init__.py)\r\n```\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.12\r\n- Flask version: 3.0.0\r\n- (and flask-misaka-1.0.0 but I don't think that's relevant) \r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5353",
    "comments": [
      "import it from `markupsafe` instead of from `flask`."
    ]
  },
  {
    "title": "flask -A flaskr init-db Error: Could not import 'flaskr.flaskr'.  Usage: flask [OPTIONS] COMMAND [ARGS]... Try 'flask --help' for help.  Error: No such command 'init-db'.",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\n-->\r\nFollowing the tutorial in the website. When I ran flask --app flaskr init-db, it returned the error\r\n<!--\r\nInitialized the database.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.12.0\r\n- Flask version: Flask==3.0.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5348",
    "comments": [
      "I can't reproduce this issue with the information provided. When reporting an issue, be sure to included a minimal reproducible example.\n\nIn this case, be sure you've followed the tutorial exactly. It does work as written. ",
      "> I can't reproduce this issue with the information provided. When reporting an issue, be sure to included a minimal reproducible example.\r\n> \r\n> In this case, be sure you've followed the tutorial exactly. It does work as written.\r\n\r\nMy bad. The steps to reproduce was in the comment lol updated it"
    ]
  },
  {
    "title": " cannot import name '_request_ctx_stack' from 'flask'",
    "body": "\r\nI am trying to run my webserver with Flask and Flask-Socket.io I have set up socket.io and flask right but for some reason when running it with Docker. I get the error: cannot import name '_request_ctx_stack' from 'flask'.  Am using Flask version 2.3.3 and the latest Flask-Socket.io\r\n\r\n\r\n\r\nInstall both Flask and Flask-Socket.io create a Dockerfile to build the app and add docker-compose to handle the build using docker-compose up. \r\n\r\nHere's the code you can use:\r\n```\r\nfrom flask import Flask\r\n\r\nfrom flask_socketio import SocketIO\r\nfrom src.db.init import DbInit\r\nfrom src.manager.sockets import SocketManager\r\nfrom src.routes import heath_route as hr\r\nfrom src.routes import docs_routes as dr\r\nfrom src.routes import query_route as qr\r\nfrom decouple import config\r\n\r\napp = Flask(__name__)\r\n\r\n# Register the blueprints\r\napp.register_blueprint(hr.health_bp, url_prefix='/api')\r\napp.register_blueprint(dr.files_bp, url_prefix='/api')\r\napp.register_blueprint(qr.query_bp, url_prefix='/api')\r\n\r\n# SocketIO.app(socketio, app=app, path=\"/io\", cors_allowed_origins=\"*\")\r\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\r\ndb = DbInit.get_instance()\r\nmanager = SocketManager(socketio, db)\r\n\r\n\r\ndef start_app():\r\n    \"\"\"Start the application\"\"\"\r\n    port = config(\"PORT\", 5050)\r\n    host = config(\"HOST\", \"0.0.0.0\")\r\n    env = config(\"ENVIRONMENT\", \"development\")\r\n    if env == \"development\":\r\n        socketio.run(host=host, app=app, port=port, debug=True, use_reloader=True)\r\n    else:\r\n        socketio.run(host=host, app=app, port=port, debug=False, use_reloader=False)\r\n```\r\nHere is the traceback\r\n```\r\nbackend  | Traceback (most recent call last):\r\nbackend  |   File \"/app/main.py\", line 1, in <module>\r\nbackend  |     from app import start_app\r\nbackend  |   File \"/app/app.py\", line 6, in <module>\r\nbackend  |     from flask_socketio import SocketIO\r\nbackend  |   File \"/usr/local/lib/python3.10/site-packages/flask_socketio/__init__.py\", line 19, in <module>\r\nbackend  |     from flask import _request_ctx_stack, has_request_context, json as flask_json\r\nbackend  | ImportError: cannot import name '_request_ctx_stack' from 'flask' (/usr/local/lib/python3.10/site-packages/flask/__init__.py)\r\n```\r\n\r\n\r\n\r\nI would like the app to run on the port 5050 and be able to allow POST, handle file uploads. \r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.13\r\n- Flask version: 2.3.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5347",
    "comments": [
      "You are not using the latest Flask-SocketIO. The version that you are using is only compatible with older versions of Flask. At some point around Flask 2.2 they have changed some implementation details regarding user sessions in a backwards incompatible way.\r\n\r\nFlask-SocketIO 5.3.0 and up have adapted to their new way, so switch to that and hopefully you should be fine.",
      "Thanks @miguelgrinberg let me try that out",
      "Will give feedback here instead of opening a new issue incase something occurs, I had tried adding the allow_wezbierg flag to true and it worked fine but I could not upload files for some reason",
      "Am getting the following error \r\n`RuntimeError('The Werkzeug web server is not '\r\nbackend  | RuntimeError: The Werkzeug web server is not designed to run in production. Pass allow_unsafe_werkzeug=True to the run() method to disable this error.`\r\nIf I add this flag to the socketio.run function uploading files fails, ",
      "I've been in this loop for almost three days now, not sure whether its a combination of the package versions that's wrong or what it is really. ",
      "I suggest that you start by closing this issue, since you do not seem to experience the original issue anymore.\r\n\r\nThe whole point of having the `allow_unsafe_werkzeug` flag is to prevent you from doing something that is almost always a bad idea. I would consider switching to a production server instead of continuing using Werkzeug. Try Gunicorn, for example.\r\n\r\nFinally you seem to have a problem uploading files, which is completely unrelated to the `allow_unsafe_werkzeug` flag. You suggest that uploads work without this flag set, but that cannot be, since without the flag the web server wouldn't start at all. Once you collect enough information about your file upload issue, you may consider writing a discussions post on the Flask repo or Flask-SocketIO repo, whichever is the project you need help with."
    ]
  },
  {
    "title": "Code style inconsistency",
    "body": "https://github.com/pallets/flask/blob/main/src/flask/cli.py#L724\n\nIn cli.py `{var_name!r}` style to wrap variables values in quotes is everywhere except the line 724",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5345",
    "comments": []
  },
  {
    "title": "The double quote is missing in the string",
    "body": "https://github.com/pallets/flask/blob/d61198941adcb191ddb591f08d7d912e40bde8bc/src/flask/cli.py#L798\r\n\r\nThere is no double quote in the first argument of `click.BadParameter` `\"--key is not used`.",
    "labels": [
      "docs"
    ],
    "url": "https://github.com/pallets/flask/issues/5342",
    "comments": []
  },
  {
    "title": "Add OpenAPI functionality ",
    "body": "\r\nAs of today, Fast api and Flask are more preferred framework to develop microservice and service mesh architecture. \r\nFlask is more preferred for below points:\r\n1. microservice architecture\r\n2. more extension available in community than others as its bit matured.  \r\n\r\nI really like the simplicity flask has. But in recent days Flask is loosing to FastAPI.\r\n\r\nBiggest CON of flask is its **incompatibility** with OpenAPI/documentation capability. \r\nBeing an Architect, my whole org has moved to FastAPI for a simple reason OpenAPI integration and documentation. As it helps us save on maintaining more than 30+ product API documentation. Earlier we were using 3rd party tools to maintain these documentation.    \r\n\r\nIt would really help flask gain more ability if we can add openapi specification just like fast api. \r\nI understand the same [feature request](https://github.com/pallets/flask/issues/4315) was raised in back in 2021 but I believe being in technology domain we have keep ourselves updated. Same goes with the web framework as well. \r\n\r\nTo illustrate few, Django is adding capability to have microservice support. why? its to keep them updated with latest requirement.\r\n\r\nOut of Django, Flask and FastAPI only Flask is not having OpenAPI support. \r\n\r\nI know there are library available in community which can do this but having it natively available in flask bring more confidence.   \r\n\r\n\r\nOut of Django, Flask and FastAPI only Flask is not having OpenAPI support. I know there are library available in community which can do this but having it natively available in flask bring more confidence and usability. as there are open source repo which supports this functionality may slowly loose its contributor unlike Flask contributors.\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5341",
    "comments": [
      "To me it sounds like having a well-maintained Flask extension for this would fit much better in the spirit of how flask works...",
      "There are already numerous extensions that provide this. It's outside the scope of Flask core. "
    ]
  },
  {
    "title": "Incompatible return value type: got \"werkzeug.wrappers.response.Response\", expected \"flask.wrappers.Response\"",
    "body": "Environment:\r\n\r\n- Python version: 3.11\r\n- Flask version: 3.0.0\r\n- mypy version: 1.5.1\r\n\r\n\r\nHey! I recently started migrating from Flask version 2.3.2 to version 3.0.0, and I've encountered some typing bugs while doing so.\r\n\r\nI have a simple part of a code in my project:\r\n```python\r\ndef redirect_to_uri(uri: str) -> flask.Response:\r\n    return flask.redirect(uri)\r\n```\r\nBut when I migrated to version 3.0.0, mypy started to raise an error during type checking, while everything was okay on version 2.3.2:\r\n\r\n```\r\nmain/api/helpers.py: note: In function \"redirect_to_uri\":\r\nmain/api/helpers.py:74:12: error: Incompatible return value type (got \"werkzeug.wrappers.response.Response\", expected \"flask.wrappers.Response\")  [return-value]\r\n        return flask.redirect(uri)\r\n               ^~~~~~~~~~~~~~~~~~~\r\nFound 1 error in 1 file (checked 29 source files)\r\n```\r\n\r\nI've found an old issue that could possibly help solve the described problem https://github.com/pallets/flask/issues/4600\r\n\r\nHave a nice day:)",
    "labels": [
      "typing"
    ],
    "url": "https://github.com/pallets/flask/issues/5337",
    "comments": [
      "Happy to review a PR.",
      "@davidism \r\nHi I am kadai, new to here and looking forward to contribute. I think this issue is good for the beginner and i will try to fix it.",
      "Hi @Azaze1l  and @davidism,\r\nProblem:\r\nThis is because `flask.redirect` internally calls `werkzeug.utils.redirect` which returns an instance of `werkzeug.wrappers.Response`.\r\nSee [redirect](https://github.com/pallets/flask/blob/089f6a1c50ea2b18287106ecd357522bab200510/src/flask/helpers.py#L231).\r\n\r\n_Flask is leaking the underlying werkzeug abstractions?_\r\n\r\nProposed Solution:\r\nCasting an instance of `werkzeug.wrappers.Response` to `flask.wrappers.response` before returning it and changing the annotation of `flask.redirect` appropriately.",
      "Hi @davidism,\r\n\r\nI am happy to submit a PR subject to your approval.",
      "`redirect` returns a `werkzeug.Response`, so annotating the view with `flask.Response`, a subclass, fails. Instead, use `werkzeug.Response` there."
    ]
  },
  {
    "title": "Can we  create a database that  collect just integers",
    "body": "The database will calculate and increase the number by 1 like the one of replit\r\n\r\n```python  \r\n          db = [ ]\r\nif number not in db:\r\n    number +=1\r\n   db.append(number)\r\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5328",
    "comments": [
      "How is that a flask issue?",
      "to create database that collect and stores an integers"
    ]
  },
  {
    "title": "ResponseValue Typing issue",
    "body": "This is not a runtime bug but a typing issue. In `flask.typing`, `ResponseValue` does not accept `AsyncIterator[str]`.\r\n\r\nI am using `quart-trio`, which itself uses `quart`, which uses `flask`.\r\n`quart.templating.stream_template` returns `AsyncIterator[str]`, and when running mypy on my project I get the following error:\r\n```\r\nerror: Value of type variable \"T_route\" of function cannot be \"Callable[[], Coroutine[Any, Any, AsyncIterator[str] | Response]]\"  [type-var]\r\n```\r\n\r\nExample usage:\r\n```python\r\n__title__ = \"Example Server\"\r\n__author__ = \"CoolCat467\"\r\n\r\nfrom quart.templating import stream_template\r\nfrom quart_trio import QuartTrio\r\nimport trio\r\nfrom os import path, makedirs\r\nimport functools\r\nimport logging\r\nfrom quart import Response\r\nfrom typing import Final\r\nfrom logging.handlers import TimedRotatingFileHandler\r\nfrom collections.abc import AsyncIterator\r\nfrom hypercorn.config import Config\r\nfrom hypercorn.trio import serve\r\n\r\n\r\nDOMAIN: str | None = None#getenv(\"DOMAIN\", None)\r\n\r\nFORMAT = \"[%(asctime)s] [%(levelname)s] %(message)s\"\r\n\r\nROOT_FOLDER = trio.Path(path.dirname(__file__))\r\nCURRENT_LOG = ROOT_FOLDER / \"logs\" / \"current.log\"\r\n\r\nif not path.exists(path.dirname(CURRENT_LOG)):\r\n    makedirs(path.dirname(CURRENT_LOG))\r\n\r\nlogging.basicConfig(format=FORMAT, level=logging.DEBUG, force=True)\r\nlogging.getLogger().addHandler(\r\n    TimedRotatingFileHandler(\r\n        CURRENT_LOG,\r\n        when=\"D\",\r\n        backupCount=60,\r\n        encoding=\"utf-8\",\r\n        utc=True,\r\n        delay=True,\r\n    ),\r\n)\r\n\r\n\r\napp: Final = QuartTrio(\r\n    __name__,\r\n    static_folder=\"static\",\r\n    template_folder=\"templates\",\r\n)\r\n\r\nasync def send_error(\r\n    page_title: str,\r\n    error_body: str,\r\n    return_link: str | None = None,\r\n) -> AsyncIterator[str]:\r\n    \"\"\"Stream error page.\"\"\"\r\n    return await stream_template(\r\n        \"error_page.html.jinja\",\r\n        page_title=page_title,\r\n        error_body=error_body,\r\n        return_link=return_link,\r\n    )\r\n\r\n\r\nasync def get_exception_page(code: int, name: str, desc: str) -> Response:\r\n    \"\"\"Return Response for exception.\"\"\"\r\n    resp_body = await send_error(\r\n        page_title=f\"{code} {name}\",\r\n        error_body=desc,\r\n    )\r\n    return Response(resp_body, status=code)\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root_get() -> Response:\r\n    \"\"\"Main page GET request.\"\"\"\r\n    return await get_exception_page(404, \"Page not found\", \"Requested content does not exist.\")\r\n\r\n\r\n# Stolen from WOOF (Web Offer One File), Copyright (C) 2004-2009 Simon Budig,\r\n# available at http://www.home.unix-ag.org/simon/woof\r\n# with modifications\r\n\r\n# Utility function to guess the IP (as a string) where the server can be\r\n# reached from the outside. Quite nasty problem actually.\r\n\r\n\r\ndef find_ip() -> str:\r\n    \"\"\"Guess the IP where the server can be found from the network.\"\"\"\r\n    # we get a UDP-socket for the TEST-networks reserved by IANA.\r\n    # It is highly unlikely, that there is special routing used\r\n    # for these networks, hence the socket later should give us\r\n    # the IP address of the default route.\r\n    # We're doing multiple tests, to guard against the computer being\r\n    # part of a test installation.\r\n\r\n    candidates: list[str] = []\r\n    for test_ip in (\"192.0.2.0\", \"198.51.100.0\", \"203.0.113.0\"):\r\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\r\n        sock.connect((test_ip, 80))\r\n        ip_addr: str = sock.getsockname()[0]\r\n        sock.close()\r\n        if ip_addr in candidates:\r\n            return ip_addr\r\n        candidates.append(ip_addr)\r\n\r\n    return candidates[0]\r\n\r\n\r\nasync def run_async(\r\n    root_dir: str,\r\n    port: int,\r\n    *,\r\n    ip_addr: str | None = None,\r\n    localhost: bool = True,\r\n) -> None:\r\n    \"\"\"Asynchronous Entry Point.\"\"\"\r\n    if ip_addr is None:\r\n        ip_addr = \"0.0.0.0\"  # noqa: S104  # Binding to all interfaces\r\n        if not localhost:\r\n            ip_addr = find_ip()\r\n\r\n    try:\r\n        # Add more information about the address\r\n        location = f\"{ip_addr}:{port}\"\r\n\r\n        config = {\r\n            \"bind\": [location],\r\n            \"worker_class\": \"trio\",\r\n        }\r\n        if DOMAIN:\r\n            config[\"certfile\"] = f\"/etc/letsencrypt/live/{DOMAIN}/fullchain.pem\"\r\n            config[\"keyfile\"] = f\"/etc/letsencrypt/live/{DOMAIN}/privkey.pem\"\r\n        app.config[\"SERVER_NAME\"] = location\r\n\r\n        app.jinja_options = {\r\n            \"trim_blocks\": True,\r\n            \"lstrip_blocks\": True,\r\n        }\r\n\r\n        app.add_url_rule(\"/<path:filename>\", \"static\", app.send_static_file)\r\n\r\n        config_obj = Config.from_mapping(config)\r\n\r\n        proto = \"http\" if not DOMAIN else \"https\"\r\n        print(f\"Serving on {proto}://{location}\\n(CTRL + C to quit)\")\r\n\r\n        await serve(app, config_obj)\r\n    except OSError:\r\n        logging.error(f\"Cannot bind to IP address '{ip_addr}' port {port}\")\r\n        sys.exit(1)\r\n    except KeyboardInterrupt:\r\n        logging.info(\"Shutting down from keyboard interrupt\")\r\n\r\n\r\ndef run() -> None:\r\n    \"\"\"Synchronous Entry Point.\"\"\"\r\n    root_dir = path.dirname(__file__)\r\n    port = 6002\r\n\r\n    hostname: Final = \"None\"#os.getenv(\"HOSTNAME\", \"None\")\r\n\r\n    ip_address = None\r\n    if hostname != \"None\":\r\n        ip_address = hostname\r\n\r\n    local = True#\"--nonlocal\" not in sys.argv[1:]\r\n\r\n    trio.run(\r\n        functools.partial(\r\n            run_async,\r\n            root_dir,\r\n            port,\r\n            ip_addr=ip_address,\r\n            localhost=local,\r\n        ),\r\n        restrict_keyboard_interrupt_to_checkpoints=True,\r\n    )\r\n\r\n\r\ndef main() -> None:\r\n    \"\"\"Call run after setup.\"\"\"\r\n    print(f\"{__title__}\\nProgrammed by {__author__}.\\n\")\r\n    try:\r\n        logging.captureWarnings(True)\r\n        run()\r\n    finally:\r\n        logging.shutdown()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n```\r\n\r\n`templates/error_page.html.jinja`\r\n```\r\n<!DOCTYPE HTML>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"utf-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n    <title>{{ page_title }}</title>\r\n    <!--<link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\">-->\r\n  </head>\r\n  <body>\r\n    <div class=\"content\">\r\n      <h1>{{ page_title }}</h1>\r\n      <div class=\"box\">\r\n        <p>\r\n          {{ error_body }}\r\n        </p>\r\n        <br>\r\n        {% if return_link %}\r\n        <a href=\"{{ return_link }}\">Return to previous page</a>\r\n        <br>\r\n        {% endif %}\r\n        <a href=\"/\">Return to main page</a>\r\n      </div>\r\n    </div>\r\n    <footer>\r\n      <i>If you're reading this, the web server was installed correctly.\u2122</i>\r\n      <hr>\r\n      <p>Example Web Server v0.0.0 \u00a9 CoolCat467</p>\r\n    </footer>\r\n  </body>\r\n</html>\r\n```\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.12\r\n- Flask version: 3.0.0\r\n",
    "labels": [
      "typing"
    ],
    "url": "https://github.com/pallets/flask/issues/5322",
    "comments": [
      "Flask doesn't accept that though. It would be Quart's response type that should allow that type. If it doesn't, that should be reported to Quart. ",
      "This one is a Flask issue now that Quart is based on Flask. I think the solution is to make the Flask sansio classes Generic over the response type. (Or support async iterators in Flask which could be nice).\r\n\r\n@CoolCat467 Something to `type: ignore` for a while - until I find a nice solution.",
      "Ok, wasn't clear that Quart was passing through Flask's type here. ",
      "@georgruetsche please don't paste ML generated answers that don't add any value.",
      "Yeah looking at this again during the pycon 2024 sprints, the naive fix for this reported issue *seems* to be just adding `AsyncIterator` to the initializer within quart. I can't find how quart is \"passing through Flask's type\".\r\n\r\nIf anything, quart's `Response` object looks a lot like the superclass to flask's `Response`, werkzeug's `Response`, and if consolidation is desired than yeah modifying werkzeug's response makes sense. But for the time being I've filed pallets/quart#341 which does fix the provided example using the naive approach, I'm not sure if additional consolidation work is desired in the future but in that case that looks like a tracked issue would be better placed in werkzeug's repo.",
      "Looks like this was fixed in Quart instead? If that's not the case, I can reopen this."
    ]
  },
  {
    "title": "flask.send_file() with Pylance in strict mode shows reportUnknownMemberType",
    "body": "I was using this method fine, until I switched on 'strict' mode in the Pylance plugin for vscode. This gave me the error at calling the method:\r\n\r\n```\r\nType of \"send_file\" is partially unknown\r\n  Type of \"send_file\" is \"(path_or_file: PathLike[Unknown] | str | BinaryIO, mimetype: str | None = None, as_attachment: bool = False, download_name: str | None = None, conditional: bool = True, etag: bool | str = True, last_modified: datetime | int | float | None = None, max_age: int | ((str | None) -> (int | None)) | None = None) -> Response\" \r\n```\r\nCode that causes the error:\r\n```\r\n@app.route('/')\r\ndef home():\r\n    return flask.send_file('web/index.html')\r\n```\r\nThe error sits on: \"flask.send_file\"\r\n\r\nI've been trying to infer this type and googled around, but can't seem to resolve this issue. having investigated \"PathLike[Unknown]\" for a while now looking into this, I've come to the conclusion that this issue is likely cause by the fact that PathLike requires a generic type to be declared.  If I manually (and temporary) add this generic type in, the error goes away.\r\n\r\nIn helpers.py (around line 391) I change:\r\n```\r\ndef send_file(\r\n    path_or_file: t.Union[os.PathLike, str, t.BinaryIO],\r\n```\r\ninto:\r\n```\r\ndef send_file(\r\n    path_or_file: t.Union[os.PathLike[str], str, t.BinaryIO],\r\n```\r\nI've added the \"[str]\" generic type to PathLike. Possibly this might need to be \"[AnyStr]\" as that is the type declared in os.\r\n\r\nI hope this is an easy fix, and that this isn't a user error that I have mistaken as an issue.\r\n\r\nEnvironment:\r\nPython 3.11.2\r\nFlask 2.2.2\r\nWerkzeug 2.2.2",
    "labels": [
      "typing"
    ],
    "url": "https://github.com/pallets/flask/issues/5320",
    "comments": [
      "This sounds reasonable. Happy to review a PR. ",
      "Hi, I'm new to contributing to this project and would love to raise a PR if no one else is working on this.",
      "Hey, thanks for being interested! Here, in our project, there's no need to ask to work on an issue. As long as the issue is not assigned to anyone and doesn't have have a linked open PR (both can be seen in the sidebar), anyone is welcome to work on any issue. So please go ahead! If you need help, you can ask here or on [our Discord server](https://discord.gg/pallets)."
    ]
  },
  {
    "title": "Auto-redirects breaks the connection",
    "body": "If you send  a multi-part body request to the incorrect URL(when you forget a \"/\" at the end of URL eg), you will get redirected automatically. And it breaks the connection with uwsgi. \r\n\r\nI believe because it does not read the whole request body and it is required by uwsgi that the application needs to read the request body.\r\n\r\nI get the file upload from the examples for Flask:\r\n\r\n```python\r\nimport os\r\nfrom flask import Flask, flash, request, redirect, url_for\r\nfrom werkzeug.utils import secure_filename\r\nimport logging\r\n\r\nUPLOAD_FOLDER = './upload'\r\n\r\napp = Flask(__name__)\r\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\r\napp.config['SECRET_KEY'] = \"Your_secret_string\"\r\n\r\n@app.route('/stg/', methods=['GET', 'POST'])\r\ndef upload_file():\r\n    if request.method == 'POST':\r\n        # check if the post request has the file part\r\n        if 'file' not in request.files:\r\n            flash('No file part')\r\n            app.logger.warning('no file part')\r\n            return redirect(request.url)\r\n        file = request.files['file']\r\n        # If the user does not select a file, the browser submits an\r\n        # empty file without a filename.\r\n        if file.filename == '':\r\n            flash('No selected file')\r\n            app.logger.warning('empty filename')\r\n            return redirect(request.url)\r\n        if file:\r\n            filename = secure_filename(file.filename)\r\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\r\n            return redirect(request.url)\r\n    return '''\r\n    <!doctype html>\r\n    <title>Upload new File</title>\r\n    <h1>Upload new File</h1>\r\n    <form method=post enctype=multipart/form-data>\r\n      <input type=file name=file>\r\n      <input type=submit value=Upload>\r\n    </form>\r\n    '''\r\n```\r\n\r\nServe this using uWSGI, we had nginx in front of the uWSGI but I realized it does not matter\r\nif you use the http mode in uWSGI as well. Then cURL a file:\r\n`curl -X POST -F \"file=@yourfile.stg\" http://localhost/stg`\r\n\r\nand in the nginx logs you get either a readv error \r\n`2023/11/03 15:02:45 [error] 397765#397765: *19 readv() failed (104: Connection reset by peer) while reading upstream, client: 127.0.0.1, server: , request: \"POST /stg HTTP/1.1\", upstream: \"uwsgi://127.0.0.1:5555\", host: \"localhost\"`\r\n\r\nor if you increase the file size a broken pipe\r\n`2023/11/03 15:02:53 [error] 397766#397766: *21 sendfile() failed (32: Broken pipe) while sending request to upstream, client: 127.0.0.1, server: , request: \"POST /stg HTTP/1.1\", upstream: \"uwsgi://127.0.0.1:5555\", host: \"localhost\"`\r\n\r\nAlso if you use uWSGI in http mode, you get \r\n\r\n`[uwsgi-http key: localhost:5555 client_addr: 127.0.0.1 client_port: 11401] hr_instance_read(): Connection reset by peer [plugins/http/http.c line 647]`\r\n\r\n\r\nI would expect after the redirection that there would be no errors since there is no extraordinary situation here, the user just mistyped the URL(I realized this issue when I mistyped an URL) \r\n\r\nEnvironment:\r\n\r\n- Python version:  3.11.4\r\n- Flask version: 2.3.3\r\n\r\nEdit: First I thought it was an issue with some configuration we had etc so I asked it in, https://stackoverflow.com/questions/77411368/does-flask-consume-request-body-on-redirects but when I realize that it was possible to reproduce it with such a small example, I thought that it must be a bug or stg.\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5319",
    "comments": [
      "These notices are fine. The connection stopped because one side or other closed the connection and started something else. With curl, you also need to tell it to follow redirects with `-L`, otherwise it just stops. And this seems like a uWSGI issue, it advertises to Flask that it terminates the input stream, so if it's not doing so report that there.\r\n\r\nThere's nothing for Flask to do there. Flask will not go farther than it already does to handle request bodies, you can search closed issues on Flask and Werkzeug to see the very long history and discussion.",
      "Yeah, I know it does not follow redirects but doing `-L` still does not change the fact that with large enough files client gets a 502. If I try it with `-L` then I get \r\n\r\n> 2023/11/03 15:36:46 [error] 397767#397767: *23 sendfile() failed (32: Broken pipe) while sending request to upstream, client: 127.0.0.1, server: , request: \"POST /stg HTTP/1.1\", upstream: \"uwsgi://127.0.0.1:5555\", host: \"localhost\"\r\n\r\nand from the cURL\r\n```html\r\n<html>\r\n<head><title>502 Bad Gateway</title></head>\r\n<body>\r\n<center><h1>502 Bad Gateway</h1></center>\r\n<hr><center>nginx/1.24.0</center>\r\n</body>\r\n</html>\r\n```\r\n\r\nAlso quoting the uWSGI:\r\n\r\n> If an HTTP request has a body (like a POST request generated by a form), you have to read (consume) it in your application. If you do not do this, the communication socket with your webserver may be clobbered. If you are lazy you can use the post-buffering option that will automatically read data for you. For Rack applications this is automatically enabled.\r\n\r\nWell I do not know if it is required specifically by uWSGI or is this requirement also part of the WSGI. Cause if latter,  then it would make it a Flask bug I assume.",
      "Our reading of the WSGI spec is that the WSGI server is in charge of handling connections and data in them. There is no way in general for Flask / the WSGI application to handle this without causing other issues, the WSGI server must.",
      "I see, that's not a show-stopper for us since everything else works like a charm when using uWSGI. But thanks for clarification that I'm not doing anything wrong but this is somehow expected behavior when we use uWSGI with Flask. But to be fair, it is also kind of interesting as uWSGI makes that remark that the application must read it and here application makes the remark that they won't read it. Guess not much to do here, thanks for your time. "
    ]
  },
  {
    "title": "Typo in docs/tutorial/factory",
    "body": "I was working through the tutorial and ran into a problem getting the example code to work.\r\n\r\nIt appears that you need to put a trailing backslash on this route for it to render.\r\n\r\n---\r\n\r\n```python\r\n@app.route(\"/hello\") # no trailing backslash\r\ndef hello():\r\n    return \"Hello, World!\"\r\n```\r\nThis code returns:\r\n![not_found_error](https://github.com/pallets/flask/assets/10804241/3fb97874-0fd0-4b13-b110-6b0feca66392)\r\n\r\n---\r\n\r\n```python\r\n@app.route(\"/hello/\") # with trailing backslash\r\ndef hello():\r\n    return \"Hello, World!\"\r\n```\r\nreturns:\r\n![hello_world](https://github.com/pallets/flask/assets/10804241/f5071e1d-594c-474a-9391-4ace7d7b8f4b)\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.2\r\n- Flask version: 3.0.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5314",
    "comments": [
      "Tutorial is correct as is. Compare the link in the tutorial to what's in your browser, there's a difference."
    ]
  },
  {
    "title": "Docs: outdated link to Hypercorn in asgi.rst",
    "body": "Outdated link to Hypercorn at https://flask.palletsprojects.com/en/3.0.x/deploying/asgi/\r\nHypercorn moved from gitlab to github. See https://gitlab.com/pgjones/hypercorn/-/blob/main/README.rst\r\n\r\n**How to replicate the bug.**\r\nGo to https://flask.palletsprojects.com/en/3.0.x/deploying/asgi/\r\nClick on Hypercorn.\r\nYou'll get to page https://gitlab.com/pgjones/hypercorn and see the messages:\r\n- Quart has moved! See https://github.com/pgjones/hypercorn\r\n- Hypercorn is now hosted at [github.com/pgjones/hypercorn](https://github.com/pgjones/hypercorn).",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5312",
    "comments": []
  },
  {
    "title": "Change color of output",
    "body": "Hi I'm trying to configure color output for formatting, but I'm loosing this battle, I have no idea what you did with logger, but everything I try works on  \"clear\" logging, but not on logger coming with flask. Can you configure logs like this please ? Like, why python [\"INFO\"] log is red in console ? \r\n\r\n![image](https://github.com/pallets/flask/assets/19526670/1e89759e-beb8-4b66-a703-228033ba7c35)\r\n\r\n\r\nThis code works with logging, but not with flask.\r\n\r\n```\r\nclass CustomFormatter(logging.Formatter):\r\n    grey = \"\\x1b[38;20m\"\r\n    yellow = \"\\x1b[33;20m\"\r\n    red = \"\\x1b[31;20m\"\r\n    bold_red = \"\\x1b[31;1m\"\r\n    reset = \"\\x1b[0m\"\r\n    format = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s (%(filename)s:%(lineno)d)\"\r\n\r\n    FORMATS = {\r\n        logging.DEBUG: grey + format + reset,\r\n        logging.INFO: grey + format + reset,\r\n        logging.WARNING: yellow + format + reset,\r\n        logging.ERROR: red + format + reset,\r\n        logging.CRITICAL: bold_red + format + reset\r\n    }\r\n\r\n    def format(self, record):\r\n        print(record)\r\n        log_fmt = self.FORMATS.get(record.levelno)\r\n        formatter = logging.Formatter(log_fmt)\r\n        return formatter.format(record)\r\n\r\nlogger = logging.getLogger(\"tmp\")\r\nlogger.setLevel(logging.DEBUG)\r\n\r\n# create console handler with a higher log level\r\nch = logging.StreamHandler()\r\nch.setLevel(logging.DEBUG)\r\n\r\nch.setFormatter(CustomFormatter())\r\n\r\nlogger.addHandler(ch)\r\n\r\nlogger.info(\"Hello\")\r\nlogger.error(\"Hello\")\r\nlogger.debug(\"Hello\")\r\nlogger.warning(\"Hello\")\r\n\r\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5310",
    "comments": []
  },
  {
    "title": "Deprecated link for ProxyFix via Sphinx",
    "body": "## Summary of Bug\r\n\r\nThe link to class `ProxyFix` in `Werkzeug` in the [Flask 3.0.x quickstart docs](https://flask.palletsprojects.com/en/3.0.x/quickstart/#hooking-in-wsgi-middleware), generated with ` :class:``~werkzeug.middleware.proxy_fix.ProxyFix`` `, is given as: \r\n\r\nhttps://werkzeug.palletsprojects.com/en/2.3.x/middleware/proxy_fix/#werkzeug.middleware.proxy_fix.ProxyFix\r\n\r\nHowever, that link, linking to werkzeug 2.3.x is deprecated, and should instead link to 3.0.x I believe:\r\n\r\nhttps://werkzeug.palletsprojects.com/en/3.0.x/middleware/proxy_fix#werkzeug.middleware.proxy_fix.ProxyFix\r\n\r\n## Describe how to replicate the bug\r\n\r\nI was not able to reproduce the bug. Building the docs locally gives the correct link (werkzeug 3.0.x). \r\n\r\n## Describe the expected behavior\r\n\r\nThe docs should build with the updated cross-link to `Proxyfix` in `Werkzeug`:\r\n\r\nhttps://werkzeug.palletsprojects.com/en/3.0.x/middleware/proxy_fix#werkzeug.middleware.proxy_fix.ProxyFix\r\n\r\n## Environment:\r\n\r\n- Python version: 3.10.13\r\n- Flask version: `main` branch: beedaa4eff3919f250fad49a5092cf07c4d638e1",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5308",
    "comments": [
      "Rebuilt the docs to refresh the links."
    ]
  },
  {
    "title": "running Thread object cause twice running",
    "body": "following code cause MyThread object running twice.\r\n\r\n```python\r\nimport threading\r\nimport time\r\nfrom flask import Flask\r\n\r\nclass MyThread(threading.Thread):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.event = threading.Event()\r\n\r\n    def run(self):\r\n        print(\"Hello\")\r\n\r\n\r\napp = Flask(__name__)\r\nt1 = MyThread()\r\nt1.start()\r\napp.run(host='0.0.0.0', port = 19001, debug = True)\r\n```\r\n\r\nset debug as False can avoid this problem but why is that? Is that a feature?",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5307",
    "comments": [
      "my python version is 3.9.13 and Flask version is 1.1.2",
      "This is because of the dev server's autoreloader which restarts the process (the original one monitors for changes, while the new one runs the actual app)\r\n\r\nI'd also question why you need to run a background thread in a webapp process (and not use celery, cronjobs, etc. to offload long-running or periodic tasks) ;)"
    ]
  },
  {
    "title": "Streaming data to multiple clients",
    "body": "I'm not sure if this is a bug in flask or just what is to be expected.\r\n\r\nIn the following example, if 1 VLC client connects, the stream plays back smoothly.\r\nIf 2 or more clients connect, all streams fail to play back smoothly/properly.\r\nAs soon as the client connections goes back down to 1, the stream starts to playback properly.\r\n\r\n```\r\nimport subprocess\r\nfrom flask import (\r\n    Flask,\r\n    Response,\r\n)\r\n\r\napp = Flask(__name__)\r\n\r\nstream = None\r\n\r\n\r\n@app.route(\"/play\", methods=[\"GET\"])\r\ndef channel():\r\n    def createStream(ffmpegcmd):\r\n        global stream\r\n        print(\"create stream\")\r\n        stream = subprocess.Popen(\r\n            ffmpegcmd,\r\n            stdin=subprocess.DEVNULL,\r\n            stdout=subprocess.PIPE,\r\n            stderr=subprocess.DEVNULL,\r\n        )\r\n\r\n    def streamData():\r\n        print(\"stream data\")\r\n        try:\r\n            while True:\r\n                chunk = stream.stdout.read(1024)\r\n                if len(chunk) == 0:\r\n                    break\r\n                yield chunk\r\n        except:\r\n            pass\r\n\r\n    if not stream:\r\n        link = \"https://cph-p2p-msl.akamaized.net/hls/live/2000341/test/master.m3u8\"\r\n\r\n        ffmpegcmd = [\r\n            \"ffmpeg\",\r\n            \"-re\",\r\n            \"-i\",\r\n            link,\r\n            \"-map\",\r\n            \"0\",\r\n            \"-codec\",\r\n            \"copy\",\r\n            \"-f\",\r\n            \"mpegts\",\r\n            \"pipe:\",\r\n        ]\r\n\r\n        createStream(ffmpegcmd)\r\n\r\n    return Response(streamData(), mimetype=\"application/octet-stream\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(host=\"0.0.0.0\", port=8001, debug=True)\r\n\r\n```\r\nThis example code is only used to reproduce the issue.\r\nCan anyone explain why it behaves like this?\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.4\r\n- Flask version: 2.3.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5305",
    "comments": [
      "The problem is you've used a global variable `stream` to manage the stream for both clients, so one client will interfere with the other as they both access it. In general, you cannot use global variables in web applications for this reason. The quick fix here would be to remove the global variable and use only local/`nonlocal` variables within the function, although you may want to think about a better structure for this as you continue.",
      "Thanks for the reply.\r\nIs there a way I can serve multiple clients with a single subprocess/instance of ffmpeg using flask?\r\nThe idea is to only have a single connection to the source server and restream it internally.\r\nI understand ffmpeg can do this on its own, but I would like to do it in flask if possible.",
      "The answer is likely yes, but that's outside the scope of what we can help with here. This issue tracker is for issues with the project itself. If you have questions, you can ask on our Discord or our GitHub Discussions."
    ]
  },
  {
    "title": "Getting a permanent redirect instead of executing the function on a URL with variables",
    "body": "In my code I have the following:\r\n\r\n```\r\n@bp.post('/refresh', defaults={'mode': 'app'})\r\n@bp.post('/refresh/<mode>')\r\ndef refresh_expiring_jwts(mode):\r\n    if mode not in ['app', 'web']:\r\n        raise NotFound\r\n```\r\nI would expect that when pointing a request to /refresh/app, I'd get refresh_expiring_jwts executed. Instead, I am getting back a permanent redirect to \"/refresh/\". I have checked the urls map and there are two rules pointing to the same method, one for /refresh and another for /refresh/<mode>. At the same time, I see that in the definition of Map (line, 99) is set to True, with this description for the parameter:\r\n```python\r\n    :param redirect_defaults: This will redirect to the default rule if it\r\n                              wasn't visited that way. This helps creating\r\n                              unique URLs.\r\n```\r\nThis map is used in the initialization of MapAdapter, line 391, and then in then in line 628, for match():\r\n```python\r\n            if self.map.redirect_defaults:\r\n                redirect_url = self.get_default_redirect(rule, method, rv, query_args)\r\n                if redirect_url is not None:\r\n                    raise RequestRedirect(redirect_url)\r\n```\r\nSo... I think I am missing something here? What am I doing wrong?\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.5\r\n- Flask version: 3.0.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5304",
    "comments": [
      "If you dont have the urls in use as is,I recommend using https://werkzeug.palletsprojects.com/en/3.0.x/routing/#werkzeug.routing.AnyConverter\n\nAs for the defaults redirect, at first glance it looks like different trailing slashes might cause confusion\n\n\nPersonally id recommend having distinct urls and not using a default with redirect "
    ]
  },
  {
    "title": "request.is_secure, Azure and X-ARR-SSL",
    "body": "This code will cause a redirect when ran on Azure Web App (possibly on other Azure services as well):\r\n\r\n```\r\n@app.before_request\r\ndef before_request():\r\n    if not request.is_secure:\r\n        url = request.url.replace('http://', 'https://', 1)\r\n        code = 301\r\n        print(\"Redirecting to https\")\r\n        return redirect(url, code=code)\r\n```\r\n\r\nbecause request.is_secure will return False.\r\n\r\nI had to use this instead:\r\n\r\n```\r\n@app.before_request\r\ndef before_request():\r\n    \"\"\"Redirect to https and www-less.\r\n    BEWARE that the value must be returned. Otherwise, the request'll continue.\r\n    So extracting into subfunctions not necessarily convenient.\r\n    \"\"\"    \r\n    if not secure_site():\r\n        url = request.url.replace('http://', 'https://', 1)\r\n        code = 301\r\n        print(\"Redirecting to https\")\r\n        return redirect(url, code=code)\r\n\r\n    host = request.headers.get('Host')\r\n    if host.startswith('www.'):\r\n        url = request.url.replace(f'{host}', f'{host[4:]}', 1)\r\n        print(\"Redirecting to www-less\")\r\n        return redirect(url, code=301)\r\n\r\ndef secure_site():\r\n    # Check if Flask thinks it's secure\r\n    if request.is_secure:\r\n        return True\r\n\r\n    # Check for Azure's header indicating SSL termination at the load balancer\r\n    # Because Flask does not know/handle this.\r\n    if request.headers.get('X-ARR-SSL'):\r\n        return True\r\n\r\n    # Check for the header used by Heroku and others\r\n    forwarded_proto = request.headers.get('X-Forwarded-Proto')\r\n    if forwarded_proto and forwarded_proto.lower() == 'https':\r\n        return True\r\n\r\n    return False\r\n```\r\n\r\nI would expect Flask to be able to detect that X-ARR-SSL is still secure.\r\n\r\nDiscussions:\r\n\r\n- https://stackoverflow.com/questions/38501618/is-current-request-being-made-over-ssl-with-azure-deployment\r\n- In discussing this with ChatGPT: \"**Safety Note:** It's important to ensure that these headers can't be easily spoofed by a malicious client. Normally, reverse proxies (like those used by Azure or Heroku) remove or overwrite these headers if they're set by the client. Therefore, in a correctly configured environment, these headers should be trustworthy. However, if you're in a different environment where you're not certain about this, you'd want to ensure that external users can't set these headers to trick your app into thinking an insecure connection is secure.\"\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11\r\n- Flask version: 2.3.2\r\n- On Azure Web Apps\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5301",
    "comments": [
      "Use werkzeug's `ProxyFix` middleware. If Azure sets any standard headers (such as `X-Forwarded-Proto`), then this will work. `X-ARR-SSL` is certainly not standard, but probably they set the standard headers as well.\r\n\r\nJust FYI: Doing such things automatically would be problematic. ProxyFix and similar \"trust headers to override connction details\" features must ONLY be used when it's guaranteed that all requests come through a trusted proxy/loadbalancer/whatever so a client cannot simply set those headers themselves."
    ]
  },
  {
    "title": "Pip",
    "body": "<!--\nThis issue tracker is a tool to address bugs in Flask itself. Please use\nPallets Discord or Stack Overflow for questions about your own code.\n\nReplace this comment with a clear outline of what the bug is.\n-->\n\n<!--\nDescribe how to replicate the bug.\n\nInclude a minimal reproducible example that demonstrates the bug.\nInclude the full traceback if there was an exception.\n-->\n\n<!--\nDescribe the expected behavior that should have happened but didn't.\n-->\n\nEnvironment:\n\n- Python version:\n- Flask version:",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5298",
    "comments": []
  },
  {
    "title": "jinja2.exceptions.TemplateNotFound",
    "body": "Hi.\r\n\r\nI am discovering flask by following a tutorial on the web site : https://www.geeksforgeeks.org/flask-http-method/\r\nI am trying to repeate the exercise but when I try to open the server after I have launched the Python script, it doesn't work. And I don't understand as I have created the \"templates\" directory, and put there the .html files.\r\nHere are screenshots about my project and the issue.\r\n\r\nThanks for the help.\r\n\r\n![page1](https://github.com/pallets/flask/assets/111196043/74566791-7ab6-4148-b49c-8b3fcebec02a)\r\n\r\n![page2](https://github.com/pallets/flask/assets/111196043/e169f24e-75c3-44b3-b0e1-fe62f231ebe9)\r\n\r\n![page3](https://github.com/pallets/flask/assets/111196043/ae217f00-9596-4f09-ac22-89647ab8fbc4)\r\n\r\n![page4](https://github.com/pallets/flask/assets/111196043/b9004e6b-66f8-408c-b7a6-cae3036556f8)\r\n\r\n![page5](https://github.com/pallets/flask/assets/111196043/4344fd61-84ae-4b89-8626-f2d134d222c3)\r\n\r\n![page6](https://github.com/pallets/flask/assets/111196043/1669e1c2-4bd8-4119-999e-93531f1cbae5)\r\n\r\n![page7](https://github.com/pallets/flask/assets/111196043/470c2fcb-1753-4079-b1fd-8ff8aee8a5a3)\r\n\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5296",
    "comments": []
  },
  {
    "title": "Refactoring and improving documentation in tox.ini",
    "body": "<!--\r\nImproved the readability and organization of the dependency configuration by grouping all development dependencies from Pallets GitHub repositories under a 'dev' section. This change eliminates redundancy and makes it easier to manage and update development dependencies in the future.\r\n-->\r\n\r\n<!--\r\nThis problem is solvable without changes to Flask and should not provide any issues or conflicts!\r\n-->\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5288",
    "comments": []
  },
  {
    "title": "url_for() does not percent encode /",
    "body": "url_for does not percent encode /\r\n\r\n```\r\nfrom flask import Blueprint, url_for, Flask\r\n\r\n\r\nbp = Blueprint('test', __name__)\r\n\r\n@bp.route('/bogus')\r\ndef bogus():\r\n    pass\r\n\r\napp = Flask(__name__)\r\napp.register_blueprint(bp)\r\n\r\nwith app.test_request_context(\"/bogus\"):\r\n\r\n    url = url_for('test.bogus', query=\"bob smith\")\r\n    print(url)\r\n    assert url != \"/bogus?query=bob smith\"\r\n\r\n\r\n    url = url_for('test.bogus', query=\"bob/smith\")\r\n    print(url)\r\n    assert url != \"/bogus?query=bob/smith\"\r\n```\r\n\r\n```\r\n$ python --version\r\nPython 3.10.6\r\n$ pip show flask\r\nName: Flask\r\nVersion: 3.0.0\r\nSummary: A simple framework for building complex web applications.\r\nHome-page: \r\nAuthor: \r\nAuthor-email: \r\nLicense: \r\nLocation: /home/xxx/.pyenv/versions/3.10.6/envs/flask30/lib/python3.10/site-packages\r\nRequires: blinker, click, itsdangerous, Jinja2, Werkzeug\r\nRequired-by: \r\n$ python test.py\r\n/bogus?query=bob+smith\r\n/bogus?query=bob/smith\r\nTraceback (most recent call last):\r\n  File \"/home/xxx/src/flaks30/test.py\", line 22, in <module>\r\n    assert url != \"/bogus?query=bob/smith\"\r\nAssertionError\r\n```\r\n\r\nExpected that / would be percent encoded as specified in RFC3986\r\nhttps://datatracker.ietf.org/doc/html/rfc3986#section-2.1\r\n\r\nI believe this is a regression because I have a unit test that fails with this version of Flask but passed with earlier versions. \r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.6\r\n- Flask version: 3.0.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5286",
    "comments": [
      "That character does not need to be escaped in the query party of a URL, because the path part has ended at that point. See https://url.spec.whatwg.org/ for the current URL standard. "
    ]
  },
  {
    "title": "Flask setup.py should use \"Werkzeug ~= 2.2.2\" instead of \"Werkzeug >= 2.2.2\"",
    "body": "The recent release of Werkzeug 3.x has affected the logic of Flask setup.py causing it to install an incompatible version of Werkzeug. A change to setup.py from `>=` to `~=` would  remedy the situation until the community can verify Flask 3.x is at a known stable release point.\r\n\r\nActual:\r\n\r\n`pip install Flask==2.2.2` does not create a working install of Flask\r\n\r\nExpected:\r\n\r\n`pip install Flask==2.2.2` should create a working install of Flask\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11\r\n- Flask version: 2.2.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5285",
    "comments": [
      "You need to pin your transitive dependencies, and update them together as well. Please read one of the many issues related to this. See e.g. [this comment](https://github.com/pallets/flask/issues/5279#issuecomment-1744132550) for details.\r\n\r\nAlso, in a new project, you should use recent versions instead of older/unsupported ones.",
      "Health care software cannot use the latest versions without going through FDA mandated verification and validation.",
      "But you can use outdated and thus unsupported versions?! Anyway, in that case you should probably either:\r\n\r\n- pin the proper (older) version of flask, werkzeug, jinja, etc\r\n- use packages provided by your (enterprise-grade, I assume, ie RHEL) distribution instead of installing from pip",
      "We cannot pin your dependencies because we cannot know when to move them. ",
      "That makes no sense...\r\n\r\nAt point X you install Flask (which pulls in werkzeug and jinja). So at that point you have a working set of dependencies. You pin those (ideally using a tool like pip-compile).\r\n\r\nAnd you just said that newer versions need to be \"verified and validated\" (whatever that means in your context). So that's how you know when to update: As soon as you're allowed to use the newer versions...",
      "We make new images constantly via CI. We do not install Flask once. \r\n\r\nWe can lock Werkzeug now that we know your stance, but this creates the opposite problem when we need to move Flask up of having to figure out which other set of libraries needs to be moved. To do that, we'd have to unpin them in our pyproject.toml and re-pin them just-in-case after we know what works.\r\n\r\nWe maintain our dep tree, you maintain yours or this turns into the same dependency hell of RPMs back in the late 90's.",
      "When writing an application, you _must_ use a tool like [pip-tools](https://pypi.org/project/pip-tools/) to pin your application's full dependency tree. This gives you reproducible deployments, allowing you to control when you get updates. Be sure to run your tests with deprecation warnings treated as errors so that you get notified of those types of changes early.\r\n\r\nPlease review any of the following for more information:\r\n\r\n* https://hynek.me/articles/semver-will-not-save-you/\r\n* https://www.youtube.com/watch?v=WSVFw-3ssXM&t\r\n* https://snarky.ca/why-i-dont-like-semver/\r\n* https://caremad.io/posts/2016/02/versioning-software/\r\n* https://bernat.tech/posts/version-numbers/\r\n* https://iscinumpy.dev/post/bound-version-constraints/"
    ]
  },
  {
    "title": "About Stream with context not work on IIS ",
    "body": "On Local, I can make @stream_with_context work and generate a stream string to my mobile flutter app.\r\nHowever when publish to IIS windows server in production, it does not work anymore, it return the whole string.\r\n\r\nIs there a way to make it work in production with IIS?\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5283",
    "comments": []
  },
  {
    "title": "Import error in Flask version 3.0.0",
    "body": "After updating the flask version, I wanted to run my server as usual, but encountered the following message:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/ft61dv/Desktop/Enablers/P05182-Asgard/server.py\", line 2, in <module>\r\n    from flask_mysqldb import MySQL\r\n  File \"/Users/ft61dv/Library/Python/3.12/lib/python/site-packages/flask_mysqldb/__init__.py\", line 3, in <module>\r\n    from flask import _app_ctx_stack, current_app\r\nImportError: cannot import name '_app_ctx_stack' from 'flask' (/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/flask/__init__.py)\r\n```\r\n\r\nThe application was working fine before this update. To get it to work again, I downgraded my flask version back to 2.3.3\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.12.0\r\n- Flask version: 3.0.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5282",
    "comments": [
      "You need to read changelogs before updating and should check deprecation warnings. You also need to pin your dependencies to avoid getting surprise updates from new major releases.\r\n\r\nAlso, this is an issue with flask-mysqldb which needs to be updated to support recent Flask versions. There's already [an issue for it](https://github.com/alexferl/flask-mysqldb/issues/29)."
    ]
  },
  {
    "title": "work around for getting _request_ctx_stack.top",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.5\r\n- Flask version: 3.0.0\r\n\r\nWith the release of flask-3.0.0, _request_ctx_stack and _app_ctx_stack got remoevd. May I know whether it's possible to \r\nget _request_ctx_stack.top with the new version? any workaround and sample?\r\n\r\nit's causing import error in downstream library (flask-track-usage) - https://github.com/ashcrow/flask-track-usage/issues/69\r\n\r\nThanks! \r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5280",
    "comments": [
      "From the changelog:\r\n\r\n> Extension maintainers, be aware that `_app_ctx_stack.top` and `_request_ctx_stack.top` are deprecated. Store data on `g` instead using a unique prefix, like `g._extension_name_attr`.",
      "@ThiefMaster ,\r\nFor _app_ctx_stack.top and _request_ctx_stack.top, would it be g. _app_ctx_stack.top / g._request_ctx_stack.top?\r\n\r\nMany thanks!\r\n\r\n",
      "It would just be g. "
    ]
  },
  {
    "title": "Issue with Werkzeug bump",
    "body": "\r\nI have a few Flask applications running on Flask 2.3.2. On deployment today, the 2 apps went down. Error: \r\n\r\n File \"/tmp/8dbc37810e69912/wsgi.py\", line 3, in <module>\r\n2023-10-03T02:41:50.698042229Z     from application import create_app\r\n2023-10-03T02:41:50.698045529Z   File \"/tmp/8dbc37810e69912/application/__init__.py\", line 8, in <module>\r\n2023-10-03T02:41:50.698049029Z     from flask_login import login_required\r\n2023-10-03T02:41:50.698052329Z   File \"/tmp/8dbc37810e69912/antenv/lib/python3.10/site-packages/flask_login/__init__.py\", line 12, in <module>\r\n2023-10-03T02:41:50.698055829Z     from .login_manager import LoginManager\r\n2023-10-03T02:41:50.698059729Z   File \"/tmp/8dbc37810e69912/antenv/lib/python3.10/site-packages/flask_login/login_manager.py\", line 33, in <module>\r\n2023-10-03T02:41:50.698066830Z     from .utils import _create_identifier\r\n2023-10-03T02:41:50.698070030Z   File \"/tmp/8dbc37810e69912/antenv/lib/python3.10/site-packages/flask_login/utils.py\", line 14, in <module>\r\n2023-10-03T02:41:50.698073530Z     from werkzeug.urls import url_decode\r\n2023-10-03T02:41:50.698076930Z ImportError: cannot import name 'url_decode' from 'werkzeug.urls'\r\n\r\n\r\n\r\nI noticed that a few days ago werkzeug was bumped from 2.7.2 to 3.0.0\r\n\r\nPinning werkzeug back to 2.7.2 in my project resolves my issue. \r\n\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.0\r\n- Flask version: 2.3.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5279",
    "comments": [
      "When writing an application, you _must_ use a tool like [pip-tools](https://pypi.org/project/pip-tools/) to pin your application's full dependency tree. This gives you reproducible deployments, allowing you to control when you get updates. Be sure to run your tests with deprecation warnings treated as errors so that you get notified of those types of changes early.\r\n\r\nPlease review any of the following for more information:\r\n\r\n* https://hynek.me/articles/semver-will-not-save-you/\r\n* https://www.youtube.com/watch?v=WSVFw-3ssXM&t\r\n* https://snarky.ca/why-i-dont-like-semver/\r\n* https://caremad.io/posts/2016/02/versioning-software/\r\n* https://bernat.tech/posts/version-numbers/\r\n* https://iscinumpy.dev/post/bound-version-constraints/",
      "In case other extension maintainers run into this issue while doing CI runs on the flask 2.x releases, I was able to lock the flask and werkzeug version in my tox.ini like such. Putting it here cause it took me a minute to figure out how to accomplish this in the tox.ini file, so maybe it will save someone else some time:\r\n\r\n```ini\r\ndeps =\r\n  flask2: Flask<3\r\n  flask2: Werkzeug<3\r\n  ...\r\n```\r\n"
    ]
  },
  {
    "title": "Got error using flak Flask==2.0.2",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\n<!--\r\n-->\r\n\r\nEnvironment: My application works fine previously, but after 2023/09/30, it deployed failed\r\n\r\n- Python version: Python3\r\n- Flask version:\r\n- Flask==2.0.2\r\ngunicorn==20.0.4\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5278",
    "comments": [
      "Do not crosspost your issues, even less so if they still lack even the slightest amount of details.\r\n\r\nhttps://github.com/pallets/flask/discussions/5277"
    ]
  },
  {
    "title": "Pallets",
    "body": "<!--\nReplace this comment with a description of what the feature should do.\nInclude details such as links to relevant specs or previous discussions.\n-->\n\n<!--\nReplace this comment with an example of the problem which this feature\nwould resolve. Is this problem solvable without changes to Flask, such\nas by subclassing or using an extension?\n-->",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5275",
    "comments": []
  },
  {
    "title": "FYI, bad documentation link",
    "body": "I was looking at the github release page, which links to https://flask.palletsprojects.com/en/3.0.x/changes/#version-3-0-0\r\n\r\nThis page gives me a page not found error.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5269",
    "comments": [
      "Fixed."
    ]
  },
  {
    "title": "When was 'Blueprint.before_app_first_request' deprecated and what replaces it?",
    "body": "I have resumed work on a Flask 1.x-based project after some time has passed, and sorting through deprecations and removals that have happened in the interim. The first place I got stuck was the `@bp.before_app_first_request` decorator.\r\n\r\nExcept to note that <q>`app.before_first_request` and `bp.before_app_first_request` decorators are removed</q> in 2.3.0, [the changelog](https://flask.palletsprojects.com/en/2.3.x/changes/#version-2-3-0) doesn't mention when these were deprecated, why, or what replaced them.\r\n\r\nPerusing previous versions of the docs, I discover that `Blueprint.before_app_first_request` was deprecated in 2.2, with this note:\r\n\r\n> Deprecated since version 2.2: Will be removed in Flask 2.3. Run setup code when creating the application instead.\r\n\r\nSomething in my gut tells me that I'm going to be writing a kind of hook handler that will iterate through all the blueprints to run their \"before first request\" initialization routines. Effectively, an amateurish reimplementation of what `Blueprint.before_app_first_request` already did.\r\n\r\nThat leaves me wondering about the context for this deprecation. Can someone enlighten me as to why it was removed?\r\n\r\n_To be clear, I intend to document whatever workaround I come up with (for the benefit of others in this situation) and close this issue myself. I'm not asking for tech support or \"homework help\" from the Flask maintainers, or to resurrect the feature from the grave. `:)`_\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5268",
    "comments": [
      "Duplicate of https://github.com/pallets/flask/discussions/5166\n\nUse `@bp.record_once` to register a callback that is called the first time the blueprint is registered on an app, which would happen during your setup code. "
    ]
  },
  {
    "title": "Flask subdomain parameter doesn't work at version 2.3.3",
    "body": "Bug:\r\n\r\nSince Flask version 2.3.3 the subdomain parameter when defining a new route doesn't work only with blueprint.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug:\r\n\r\nAn example route which will return 404 Not Found even it should:\r\n\r\n```\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__, template_folder='templates', static_folder='static')\r\n\r\n\r\n@app.route('/logout', subdomain='panel', methods=['POST', 'GET'])\r\ndef logout():\r\n\r\n    return \"ok\"\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(host=\"0.0.0.0\", port=80, threaded=True, debug=True)\r\n```\r\n\r\nDescribe the expected behavior that should have happened but didn't:\r\nNormally when using the subdomain parameter when defining a new route, the route would've work on that specified subdomain.\r\nWith the 2.3.3 version this is only works with Flask Blueprint, the downside of this is that I cannot define multiple subdomains.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.12\r\n- Flask version: 2.3.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5266",
    "comments": [
      "I think you need to set the `SERVER_NAME` configuration value, see [docs](https://flask.palletsprojects.com/en/2.3.x/config/#SERVER_NAME).\r\n\r\nI can't reproduce any clear different between 2.3.2 and 2.3.3 - please reopen if you can with a reproducible example."
    ]
  },
  {
    "title": "Bug in Flask docs",
    "body": "Hi, flask seems very well done.  The docs are well organized, with quick links to other sections.\r\n\r\nHowever there's one bug I have encountered in the docs.  Specifically [this page](https://flask.palletsprojects.com/en/2.3.x/) has the following content:\r\n\r\n> Welcome to Flask\u2019s documentation. Get started with [Installation](https://flask.palletsprojects.com/en/2.3.x/installation/) and then get an overview with the [Quickstart](https://flask.palletsprojects.com/en/2.3.x/quickstart/). \r\n\r\nBeautiful, prominent links to install and quick start.\r\n\r\n> There is also a more detailed [Tutorial](https://flask.palletsprojects.com/en/2.3.x/tutorial/) that shows how to create a small but complete application with Flask. Common patterns are described in the [Patterns for Flask](https://flask.palletsprojects.com/en/2.3.x/patterns/) section. The rest of the docs describe each component of Flask in detail, with a full reference in the [API](https://flask.palletsprojects.com/en/2.3.x/api/) section.\r\n\r\nTutorial, patterns, reference API.  Fantastic!\r\n\r\n> Flask depends on the [Werkzeug](https://werkzeug.palletsprojects.com/) WSGI toolkit, the [Jinja](https://jinja.palletsprojects.com/) template engine, and the [Click](https://click.palletsprojects.com/) CLI toolkit. Be sure to check their documentation as well as Flask\u2019s when looking for information.\r\n\r\nA bit off the rails with minutia here, we can recover...\r\n\r\n> ## User\u2019s Guide\r\n> Flask provides configuration and conventions, with sensible defaults, to get started. \r\n\r\nGood to know.\r\n\r\n> This section of the documentation explains the different parts of the Flask framework and how they can be used, customized, and extended. \r\n\r\nGreat!\r\n\r\n> Beyond Flask itself, look for community-maintained extensions to add even more functionality.\r\n\r\nOk...\r\nHere's where the bug is.  In all that great intro information, there was not one single sentence telling me what in god's name Flask is.  Is it a cocktail app?  Is it for powder horn management?  Is it a movement tracker for minutemen militia?  Who knows?  You wouldn't have any earthly idea.\r\n\r\nObviously I or anyone can google it.  But we shouldn't have to.  You did such a great job with the rest of the intro.  You already have great explanatory text on the github readme:\r\n> Flask is a lightweight [WSGI](https://wsgi.readthedocs.io/) web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications.\r\n\r\nJust put that at the top of the docs landing page and you're golden!",
    "labels": [
      "docs"
    ],
    "url": "https://github.com/pallets/flask/issues/5263",
    "comments": [
      "I would like work on editing this document and contribute to this project. I agree with Edward that we should have a few lines explaining what Flask does exactly. \r\nCan this issue be assigned to me if there is a consensus about this? Thanks.",
      "Ok @ed2050",
      "@its-joseph-230606 please stop those noisy comments ",
      "@ed2050 Could you assign this issue to me? I have been blogging so I know how to put words together in a way that makes sense.",
      "I don't seem to have permission for that.  No way to assign things from this account as far as I can see...",
      "Just send a PR. No need for assignment\r\n\r\nPS: @ed2050, wouldn't it have taken less (or just as much) time to open a PR to fix this instead of writing this - very verbose - issue? ;)"
    ]
  },
  {
    "title": "Blueprints and import into gunicorn.conf.py results in gunicorn reload bug",
    "body": "This is a very interesting bug.\r\n\r\nWhen using Blueprints with flask, and importing something into gunicorn.conf.py from the same top level module in which the flask application resides, Gunicorn's --reload functionality breaks. Specifically, the reloading functionality appears to work- gunicorn informs us that the application has been reloaded; but the run time code is actually cached, and the application in effect does not reload.\r\n\r\nThis bug is an issue because it makes development inconvenient, and it is time consuming to isolate.\r\n\r\nThis bug cannot be replicated if: \r\n * you don't use blueprints, \r\n * or if you use blueprints but do not import into gunicorn.conf.py from a module that exists inside the application module\r\n * or if you use blueprints, and lazy import into gunicorn.conf.py\r\n\r\nThe reason I believe this is a flask bug, instead of a gunicorn bug, is that this bug only exists when using blueprints. \r\n\r\nI've replicated this on Python 3.11.5, Flask 2.3.3 and 2.0.0, Gunicorn 21.2.0 and 21.0.0, and RHEL and Ubuntu.\r\n\r\n\r\n# Docker\r\nI've uploaded a [repo](https://github.com/mkmoisen/blueprintbug/tree/master) with a Dockerfile and docker-compose.yaml that can be used to quickly reproduce the bug. The application runs on port 8080.\r\n\r\n```\r\ngit clone https://github.com/mkmoisen/blueprintbug.git\r\ndocker compose up --build\r\n```\r\n\r\n\r\n# Directory Structure\r\n```\r\nblueprintbug/\r\n    app/\r\n        __init__.py\r\n    gunicorn.conf.py\r\n    requirements.txt\r\n```\r\n\r\n# blueprintbug/app/__init__.py\r\n\r\n```\r\nfrom flask import Flask, Blueprint\r\n\r\ndef init_application():\r\n    print(\"Application initialized.\")\r\n\r\n\r\ndef cleanup_application():\r\n    print(\"Application cleaned up.\")\r\n\r\n\r\ndef create_app():\r\n    \"\"\"\r\n    Creates & initializes a Flask application instance.\r\n    :return:\r\n    \"\"\"\r\n    app = Flask(__name__, static_folder=None, template_folder=None)\r\n\r\n    app.register_blueprint(bp)\r\n\r\n    return app\r\n\r\n\r\nbp = Blueprint('home', __name__)\r\n\r\n@bp.get('/')\r\ndef home():\r\n    raise Exception(\"foo\")\r\n\r\n```\r\n\r\n# blueprintbug/gunicorn.conf.py\r\n\r\n```\r\n# The root cause of this bug is these imports\r\n# Moving these imports to inside of post_worker_init and worker_exit eliminates the bug\r\nfrom app import init_application\r\nfrom app import cleanup_application\r\n\r\nbind = '0.0.0.0:8080'\r\n\r\npreload_app = False\r\n\r\nworker_class = 'gthread'\r\nworkers = 1\r\nthreads = 1\r\n\r\n\r\ndef post_worker_init(worker):\r\n    init_application()\r\n\r\n\r\ndef worker_exit(server, worker):\r\n    cleanup_application()\r\n\r\n```\r\n\r\n# blueprintbug/requirements.txt\r\n\r\n```\r\nFlask==2.3.3\r\ngunicorn==21.2.0\r\n```\r\n\r\n# Running the application\r\n\r\nRun the application with the reload option:\r\n\r\n```\r\ngunicorn -c gunicorn.conf.py \"app:create_app()\" --reload\r\n```\r\n\r\nWith the above code, if we call GET /, we can see the following exception, which we expect:\r\n\r\n    curl http://localhost:8080/\r\n\r\n```\r\nblueprintbug  |   File \"/usr/src/app/app/__init__.py\", line 27, in home\r\nblueprintbug  |     raise Exception(\"foo\")\r\nblueprintbug  | Exception: foo\r\n```\r\n\r\nNow let's change `blueprintbug/app/__init__.py` to raise `bar` instead of `foo`:\r\n\r\n```\r\n@bp.get('/')\r\ndef home():\r\n    raise Exception(\"bar\")\r\n```\r\n\r\nAnd we can confirm that gunicorn appears to have reloaded the application:\r\n\r\n```\r\nblueprintbug  | [2023-09-20 17:08:29 +0000] [7] [INFO] Worker reloading: /usr/src/app/app/__init__.py modified\r\nblueprintbug  | [2023-09-20 17:08:30 +0000] [7] [INFO] Worker exiting (pid: 7)\r\nblueprintbug  | Application initialized.\r\nblueprintbug  | Application cleaned up.\r\nblueprintbug  | [2023-09-20 17:08:30 +0000] [10] [INFO] Booting worker with pid: 10\r\n```\r\n\r\n\r\nNext we can call  `GET /` which will result in this strange result:\r\n\r\n    curl http://localhost:8080/\r\n\r\n```\r\nblueprintbug  |   File \"/usr/src/app/app/__init__.py\", line 27, in home\r\nblueprintbug  |     raise Exception(\"bar\")\r\nblueprintbug  | Exception: foo\r\n```\r\n\r\nNotice how the stack trace says `raise Exception(\"bar\")`, but how the actual run time exception raised is `foo`.\r\n\r\nThis implies that gunicorn is caching the run time code, even though it recognizes that the code has changed.\r\n\r\nWe would have expected the following console output, which does not happen:\r\n\r\n```\r\nblueprintbug  |   File \"/usr/src/app/app/__init__.py\", line 27, in home\r\nblueprintbug  |     raise Exception(\"bar\")\r\nblueprintbug  | Exception: bar\r\n```\r\n\r\n\r\n-------\r\n\r\nThe quickest workaround appears to be using lazy loading inside of `gunicorn.conf.py`.\r\n\r\n```\r\n# Do not import here, instead import inside the functions\r\n\r\ndef post_worker_init(worker):\r\n    from app import init_application\r\n    init_application()\r\n\r\n\r\ndef worker_exit(server, worker):\r\n    from app import cleanup_application\r\n    cleanup_application()\r\n\r\n```\r\n\r\nAlternatively, you can move the `init_application` and `cleanup_application` to a separate directory from `/app`.\r\n\r\nOr you can not use blueprints.\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5259",
    "comments": []
  },
  {
    "title": "TypeError: Flask.url_for() got multiple values for argument 'self'",
    "body": "[Official documentation](https://flask.palletsprojects.com/en/2.3.x/api/#flask.url_for) doesn't mention any preconditions for values argument, but `self=1` raises an exception.\r\n\r\nCan be replicated with the following test case:\r\n\r\n```python\r\nfrom unittest import TestCase\r\n\r\nfrom flask import Flask, url_for\r\n\r\n\r\nclass UrlForTests(TestCase):\r\n    def setUp(self) -> None:\r\n        self.app = Flask(__name__)\r\n\r\n    def test_with_self_argument(self) -> None:\r\n        with (\r\n            self.app.app_context(),\r\n            self.assertRaisesRegex(\r\n                TypeError, \"got multiple values for argument 'self'\"\r\n            ),\r\n        ):\r\n            url_for(\"doesnotmatter\", self=1)\r\n```\r\n\r\nTraceback example:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/dmitry/git/github.com/minetest/contentdb/tests.py\", line 6, in <module>\r\n    url_for(\"doesnotmatter\", self=1)\r\n  File \"/home/dmitry/.cache/pypoetry/virtualenvs/contentdb-MK2UWkId-py3.10/lib/python3.10/site-packages/flask/helpers.py\", line 256, in url_for\r\n    return current_app.url_for(\r\nTypeError: Flask.url_for() got multiple values for argument 'self'\r\n```\r\n\r\nThe expected behavior is the returned URL has query string like '?self=1'.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.6\r\n- Flask version: 2.3.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5258",
    "comments": [
      "Probably `self` of that method should be made positional-only (unless we still support a Python version that does not support positional-only arguments). As a workaround we could possibly rename it to something like `___self` that is almost certainly never used in a real URL param...",
      "Let's get this into 3.0 and use a position only arg. "
    ]
  },
  {
    "title": "AsyncToSync error with Flask Async, Gunicorn and Gevent",
    "body": "When using the Async options for Flask, running an application with an asynchronous teardown_request function, using Gunicorn with Gevent as the WSGI server, there is a race condition where a lot of simultaneous requests results in the error \"You cannot use AsyncToSync in the same thread as an async event loop - just await the async function directly.\".\r\n\r\nI've [attached a reproduction](https://github.com/pallets/flask/files/12614087/reproduction.zip). To reproduce the bug:\r\n\r\n* Unzip the zip to a directory.\r\n* Install the requirements using `pip install -r requirements.txt`.\r\n* Run the application using `gunicorn -b 0.0.0.0:8080 app:app --worker-class=gevent -w 2 --threads 2`.\r\n* In another shell, run `./lots-of-curls.sh`.\r\n\r\nThe stack trace I see is\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/sam/.pyenv/versions/3.9.7/envs/flask-test-3.9.7/lib/python3.9/site-packages/gunicorn/workers/base_async.py\", line 55, in handle\r\n    self.handle_request(listener_name, req, client, addr)\r\n  File \"/home/sam/.pyenv/versions/3.9.7/envs/flask-test-3.9.7/lib/python3.9/site-packages/gunicorn/workers/ggevent.py\", line 128, in handle_request\r\n    super().handle_request(listener_name, req, sock, addr)\r\n  File \"/home/sam/.pyenv/versions/3.9.7/envs/flask-test-3.9.7/lib/python3.9/site-packages/gunicorn/workers/base_async.py\", line 108, in handle_request\r\n    respiter = self.wsgi(environ, resp.start_response)\r\n  File \"/home/sam/.pyenv/versions/3.9.7/envs/flask-test-3.9.7/lib/python3.9/site-packages/flask/app.py\", line 2213, in __call__\r\n    return self.wsgi_app(environ, start_response)\r\n  File \"/home/sam/.pyenv/versions/3.9.7/envs/flask-test-3.9.7/lib/python3.9/site-packages/flask/app.py\", line 2206, in wsgi_app\r\n    ctx.pop(error)\r\n  File \"/home/sam/.pyenv/versions/3.9.7/envs/flask-test-3.9.7/lib/python3.9/site-packages/flask/ctx.py\", line 401, in pop\r\n    self.app.do_teardown_request(exc)\r\n  File \"/home/sam/.pyenv/versions/3.9.7/envs/flask-test-3.9.7/lib/python3.9/site-packages/flask/app.py\", line 2038, in do_teardown_request\r\n    self.ensure_sync(func)(exc)\r\n  File \"/home/sam/.pyenv/versions/3.9.7/envs/flask-test-3.9.7/lib/python3.9/site-packages/asgiref/sync.py\", line 209, in __call__\r\n    raise RuntimeError(\r\nRuntimeError: You cannot use AsyncToSync in the same thread as an async event loop - just await the async function directly.\r\n```\r\n\r\nIf you run without gevent, using the command line `gunicorn -b 0.0.0.0:8080 app:app -w 2 --threads 2` the issue does not manifest.\r\n\r\nIf you remove all the ` &` characters from the end of the lines in `lots-of-curls.sh`, so the curl statements run serially rather than in parallel, no issue shows up so this appears to definitely be a race condition of some sort.\r\n\r\nIt is possible this is a bug in another component in the stack, but I just don't have clear enough knowledge of how the responsibilities are assigned to know which component is at fault, apologies if the bug is not in Flask itself.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.9.7\r\n- Flask version: 2.3.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5256",
    "comments": [
      "Thanks for the detailed report. However, that's an issue with Gevent, Gunicorn, or `asgiref.AsyncToSync`, not Flask. The application layer of WSGI has no control over this. "
    ]
  },
  {
    "title": "Add passthrough_errors to flask run options",
    "body": "I'm building an API using Flask, and have an `@app.errorhandler(HTTPException)` to catch all HTTPExceptions in order to format them as JSON. This is working great via `flask run`, but when I add the `--debug` flag to get auto-reloading, the Werkzeug default error handler catches exceptions before my error handler has a chance to respond with JSON.\r\n\r\nI noticed the `passthrough_errors` option to `werkzeug.run_simple()`, and when I run my app via a simple script, the error handler works as I'd expect, along with the reloader:\r\n\r\n```\r\nfrom my_app import create_app\r\nfrom werkzeug import run_simple\r\n\r\napp = create_app()\r\nrun_simple(\"0.0.0.0\", 8170, app, use_reloader=True, use_debugger=False, passthrough_errors=True, threaded=True)\r\n```\r\n\r\nTherefore, it would be helpful if we could add something like `--passthrough-errors` to the `flask run` CLI command. Alternately, let me know if there's another recommended way to use `flask run --debug` but disable the Werkzeug default error handler page. Thanks!\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5255",
    "comments": [
      "Duplicate of https://github.com/pallets/flask/issues/4729\r\nSee also https://github.com/pallets/flask/issues/5046 "
    ]
  },
  {
    "title": "Problems with using flask as dependency for other libraries",
    "body": "Hello!\r\n\r\nI started writing a library whose tasks include starting and stopping the flask server. I have added flask to the [list of dependencies](https://github.com/pomponchik/flask_fixture/blob/d2a640407b611a8b72dfcb1c9f71aabef890d449/setup.py#L7) of this library. \r\n\r\nWhen installing my library on macOS, I see the [following](https://github.com/pomponchik/flask_fixture/actions/runs/6162817875/job/16725168014#step:4:157):\r\n\r\n```\r\nInstalled /Users/runner/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/zipp-3.16.2-py3.9.egg\r\nSearching for MarkupSafe>=2.1.1\r\nReading https://pypi.org/simple/MarkupSafe/\r\nDownloading https://files.pythonhosted.org/packages/6d/7c/59a3248f411813f8ccba92a55feaac4bf360d29e2ff05ee7d8e1ef2d7dbf/MarkupSafe-2.1.3.tar.gz#sha256=af598ed32d6ae86f1b747b82783958b1a4ab8f617b06fe68795c7f026abbdcad\r\nBest match: MarkupSafe 2.1.3\r\nProcessing MarkupSafe-2.1.3.tar.gz\r\nWriting /var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/easy_install-rho3rw1f/MarkupSafe-2.1.3/setup.cfg\r\nRunning MarkupSafe-2.1.3/setup.py -q bdist_egg --dist-dir /var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/easy_install-rho3rw1f/MarkupSafe-2.1.3/egg-dist-tmp-hjznlbbi\r\nno previously-included directories found matching 'docs/_build'\r\nwarning: no previously-included files matching '*.pyc' found anywhere in distribution\r\nzip_safe flag not set; analyzing archive contents...\r\nmarkupsafe.__pycache__._speedups.cpython-39: module references __file__\r\nNo eggs found in /var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/easy_install-rho3rw1f/MarkupSafe-2.1.3/egg-dist-tmp-hjznlbbi (setup script problem?)\r\nerror: The 'MarkupSafe>=2.1.1' distribution was not found and is required by Werkzeug\r\nError: Process completed with exit code 1.\r\n```\r\n\r\nThis situation is reproduced in [my GitHub Actions](https://github.com/pomponchik/flask_fixture/actions/runs/6162817875), you can familiarize yourself with the situation in more detail. The installation of my library is terminated when the following command is executed:\r\n\r\n```bash\r\npython setup.py install\r\n```\r\n\r\nI also tried older versions of flask, including 1.X.X, the situation was reproduced there as well. On some operating systems with some versions of Python everything works, on some it doesn't.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.9\r\n- Flask version: latest and more\r\n- OS: macOS latest\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5253",
    "comments": [
      "Setup.py install is discouraged since years,does the issue replicate with pip install?",
      "You are using old versions of either pip or setuptools. Use `pip install -U pip setuptools` to get the most recent versions. I suggest avoid setuptools for new projects, and using modern project metadata in `pyproject.toml`, with a modern build backend such as Hatch or Flit. See the Flask repo itself as an example of this."
    ]
  },
  {
    "title": "when use copy_current_request_context and ThreadPoolExecutor, I got error.",
    "body": "I want to use the main thread's request context in the sub-thread. So I use the decorator copy_current_request_context. But I got an error that **<Token var=<ContextVar name='flask.request_ctx' at 0x1067aef90> at 0x106c71280> was created in a different Context**. \r\n\r\n**The weirdest thing is when I debug the code one by one, I will get the expected results sometimes.**\r\n\r\nThis is a simple code. \r\n\r\n```\r\nimport random\r\nimport string\r\nimport requests\r\n\r\nfrom flask import Flask, copy_current_request_context\r\nfrom concurrent.futures import ThreadPoolExecutor\r\n\r\napp = Flask(__name__)\r\n\r\ndef get_trace_id(number):\r\n    trace_id =  \"\".join(random.sample(string.ascii_letters, number))\r\n    print(requests.get(\"https://www.google.com\").text)\r\n    return trace_id\r\n\r\n\r\n@app.route(\"/\")\r\ndef hello():\r\n    @copy_current_request_context\r\n    def inner_func(number):\r\n        return get_trace_id(number)\r\n\r\n    with ThreadPoolExecutor(20) as executor:\r\n        res_iter = executor.map(inner_func, [1, 2, 3, 4, 5])\r\n    return list(res_iter)\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run()\r\n```\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.8.17\r\n- Flask version: 2.3.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5252",
    "comments": []
  },
  {
    "title": "SO_REUSEADDR set server",
    "body": "There needs to give users to set app listening socket to be SO_REUSEADDR, so that an unexpected server failure does not block immediate restart due to \"Address already in use\". \r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5249",
    "comments": [
      "This is already used."
    ]
  },
  {
    "title": "NameError: name 'Response' is not defined",
    "body": "I have a view like this:\r\n```\r\n@pydantic.validate_arguments(config={\"arbitrary_types_allowed\": True})\r\ndef my_view(\r\n)-> flask.typing.ResponseReturnValue:\r\n    ...\r\n```\r\n\r\nThis view is failing during tests:\r\n```\r\n    @pd.validate_arguments(config={\"arbitrary_types_allowed\": True})\r\npydantic/decorator.py:36: in pydantic.decorator.validate_arguments.validate\r\n    ???\r\npydantic/decorator.py:78: in pydantic.decorator.ValidatedFunction.__init__\r\n    ???\r\npydantic/typing.py:78: in pydantic.typing.get_all_type_hints\r\n    ???\r\n/nix/store/yk7nrvvz4hjgzzlhr3mg8wl2hn56h187-python3-3.11.4/lib/python3.11/typing.py:2373: in get_type_hints\r\n    hints[name] = _eval_type(value, globalns, localns)\r\n/nix/store/yk7nrvvz4hjgzzlhr3mg8wl2hn56h187-python3-3.11.4/lib/python3.11/typing.py:371: in _eval_type\r\n    return t._evaluate(globalns, localns, recursive_guard)\r\n/nix/store/yk7nrvvz4hjgzzlhr3mg8wl2hn56h187-python3-3.11.4/lib/python3.11/typing.py:882: in _evaluate\r\n    self.__forward_value__ = _eval_type(\r\n/nix/store/yk7nrvvz4hjgzzlhr3mg8wl2hn56h187-python3-3.11.4/lib/python3.11/typing.py:385: in _eval_type\r\n    ev_args = tuple(_eval_type(a, globalns, localns, recursive_guard) for a in t.__args__)\r\n/nix/store/yk7nrvvz4hjgzzlhr3mg8wl2hn56h187-python3-3.11.4/lib/python3.11/typing.py:385: in <genexpr>\r\n    ev_args = tuple(_eval_type(a, globalns, localns, recursive_guard) for a in t.__args__)\r\n/nix/store/yk7nrvvz4hjgzzlhr3mg8wl2hn56h187-python3-3.11.4/lib/python3.11/typing.py:371: in _eval_type\r\n    return t._evaluate(globalns, localns, recursive_guard)\r\n/nix/store/yk7nrvvz4hjgzzlhr3mg8wl2hn56h187-python3-3.11.4/lib/python3.11/typing.py:877: in _evaluate\r\n    eval(self.__forward_code__, globalns, localns),\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\n>   ???\r\nE   NameError: name 'Response' is not defined\r\n```\r\n\r\nLooks like the problem is in flask.typing:\r\n\r\n```\r\nif t.TYPE_CHECKING:  # pragma: no cover\r\n    from _typeshed.wsgi import WSGIApplication  # noqa: F401\r\n    from werkzeug.datastructures import Headers  # noqa: F401\r\n    from werkzeug.wrappers import Response  # noqa: F401\r\n```\r\n\r\nFlask imports Response only during type checking, but pydantic tries to get the type hints at runtime...\r\n\r\n\r\n<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version: Python 3.11.4\r\n- Flask version: Flask==2.3.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5245",
    "comments": [
      "This is one for Pydantic, rather than Flask.",
      "So you are cutting off users of Flask who want to use `typing.get_type_hints()` in production? \r\nIs there a consensus that it's prohibited to use `get_type_hints` in places other than static checks?",
      "I believe it's normal to import stuff only used for type annotations only during TYPE_CHECKING - also because often it'd lead to circular dependencies between modules if you didn't do that (I don't know it's the case here, maybe or maybe not)",
      "I think more and more tools will use type hints for business logic, not just Pydantic as in this case. So I wouldn't dismiss this issue so quickly with something like \"This is one for Pydantic, rather than Flask.\"."
    ]
  },
  {
    "title": "Jinja2 Templating render_block to support HTMX",
    "body": "Hi! I would like to suggest adding a `render_block` function to [templating.py](https://github.com/pallets/flask/blob/main/src/flask/templating.py) to support rendering a defined Jinja2 template block. This would work like:\r\n\r\n```html\r\n<body>\r\n    <h1>This is a header</h1>\r\n    {% block content %}\r\n    <p>This is the magic number: {{ magic_number }}.</p>\r\n    {% endblock %}\r\n</body>\r\n```\r\n\r\n```python\r\nfrom flask import Flask, render_template, render_block\r\n\r\napp = Flask(__name__)\r\n\r\n@app.get(\"/full_page\")\r\ndef full_page():\r\n    return render_template(\"page.html.jinja2\", magic_number=42)\r\n\r\n@app.get(\"/only_content\")\r\ndef only_content():\r\n    return render_block(\"page.html.jinja2\", \"content\", magic_number=42)\r\n```\r\n\r\nThe purpose of this change is to support HTMX-style templates where you are returning partial HTML pages in Flask responses. Flask-native way to accomplish this is with multiple files (page.html and partial.html) and render_template('partial.html').\r\n\r\nI then discovered [jinja2-fragment](https://github.com/sponsfreixes/jinja2-fragments#usage-with-flask) which has a Flask function that simplifies this by adding the above-suggested functionality as a separate library (albeit small).\r\n\r\nBut this change is pretty small - one function - and so I would suggest upstreaming it here into Flask itself since I think this would offer a clear and simple solution to a common issue when working with HTMX. I'm happy to work on the PR if this issue is accepted.\r\n\r\nThis functionality is similar to Go's [Template.ExecuteTemplate](https://pkg.go.dev/text/template#Template.ExecuteTemplate) function which operates on named `{{ block \"name-here\" .}}` elements embedded in html templates.\r\n\r\nRelated Jinja2 ticket https://github.com/pallets/jinja/issues/1808\r\n\r\nrender_block code exists [in the jinja2-fragments](https://github.com/sponsfreixes/jinja2-fragments/blob/main/src/jinja2_fragments/flask.py) repo as well as the Jinja2 ticket.\r\n\r\n## Community Scope\r\n\r\nHundreds of Flask devs have starred https://github.com/mikeckennedy/jinja_partials and https://github.com/sponsfreixes/jinja2-fragments\r\nFlask is a popular choice for HTMX since it has first-rate Jinja2 integration. So I think supporting this change would be very welcome.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5243",
    "comments": [
      "jinja-partials and jinja2-fragments already cover this, no need to add it to Flask at this time."
    ]
  },
  {
    "title": "Separated frontend and backend",
    "body": "Hi,\r\nAccording to flask documentation, now flask combines frontend and backend together by using jinja2 template, then how to separate them so as to customize the frontend UI using vue or other tools ?\r\nCould you recommend some estensions or flask skills ?",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5241",
    "comments": [
      "You write your frontend however you like, and make api calls to the backend. Helping with this is outside the scope of this issue tracker. "
    ]
  },
  {
    "title": "cannot install `dependencies = [ \"flask>=2.3.2\", ]` in toml file ",
    "body": "This is happening in google colab environment. Causes:\r\n\r\n```\r\nERROR: Cannot uninstall 'blinker'. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.\r\n```\r\n\r\nThis is my toml file: https://github.com/anarchy-ai/LLM-VM/blob/main/pyproject.toml",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5240",
    "comments": [
      "That error is clearly something related to your environment and not related to Flask...\r\n\r\nBut my guess would be that you are not installing in a virtualenv and have a system-wide `python-blinker` (or similar) package installed, so installing the `blinker` dependency of flask fails."
    ]
  },
  {
    "title": "Boolean return value should result in JSON response",
    "body": "Currently only dicts and lists are converted to JSON responses. However, it is also quite common for APIs to return a boolean scalar. For now this will result in an exception and if one wants to do this, they have to use `jsonify`.\r\n\r\nI think allowing boolean return value to be converted into JSON responses is therefore a nice QoL improvement. And because it is currently prohibited, there is no backwards incompatible change.\r\n\r\n```python\r\n@app.get(\"/test-registration-state\")\r\ndef registration_state():\r\n    return quart.json.jsonify(some_check()) # old\r\n    return some_check() # new\r\n```",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5239",
    "comments": [
      "I don't want to add shortcuts for the primitive types. Return a JSON object or list of objects is common in APIs. But automatically handling bools and ints seems easy to hide programming errors unintentionally. It's easy enough to either return `jsonify(True)` or `{\"done\": True}` instead."
    ]
  },
  {
    "title": "Documentation inconsistency",
    "body": "The tutorial file flaskr/blog.py does not check if the body is empty, but the body must be not null according to flaskr/schema.sql.\r\n\r\nThe following methods in flaskr/blog.py and their respective views are affected by this:\r\n- create\r\n- update\r\n\r\nTo replicate, create a blog post with an empty body.\r\n\r\nThe expected behavior shouldn't let the user create the post with an empty body.\r\n\r\nI vision two possible solutions:\r\n- Add verification for an empty body in necessary parts of the code.\r\n- Let the body be NULL in the flaskr/schema.sql.\r\n\r\nEnvironment: Ubuntu 20.04.6 LTS\r\n\r\n- Python version: 3.8.10\r\n- Flask version: 2.3.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5235",
    "comments": [
      "The empty string is not the same as `NULL`. The value must not be null. It may be empty."
    ]
  },
  {
    "title": "Wrong request's 'Host' Header Value Due to Duplicate Server Names in' X-Forwarded-Server' Header",
    "body": "When you send a request to a Flask server through Apache using a reverse proxy and include the X-Forwarded-Server header with values like \"servername1, servername1\", a problem occurs. On the Flask server's side, when trying to read the request headers, the 'Host' header appears incorrect, showing the value as \"servername1, servername1\" instead of the expected \"servername1\". The issue is that the X-Forwarded-Server header value is affecting the Host value, even though these headers should be separate. This situation is likely to happen when multiple reverse proxies are used in Apache before reaching the Flask server.\r\n\r\nFor example, if you examine the Apache configurations below, the Flask server listens on port 9966 and can be accessed via \"restV2\". This setup leads to duplicate server names in the X-Forwarded-Server header.\r\n\r\n\r\nApache Configurations:\r\n\r\n```\r\n<Location /restInternal>\r\n    ProxyPass http://127.0.0.1:9966 retry=1 Keepalive=On timeout=300\r\n    ProxyPassReverse http://127.0.0.1:9966\r\n</Location>\r\n\r\n<Location /restV2>\r\n    ProxyPass http://127.0.0.1/restInternal retry=1 Keepalive=On timeout=300\r\n    ProxyPassReverse http://127.0.0.1:restInternal\r\n</Location>\r\n```\r\n\r\nThis issue arises due to the interaction between Apache, the reverse proxy, and the Flask server\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.6.8\r\n- Flask version: 2.3.2\r\n- Apache version: 2.4.6\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5233",
    "comments": [
      "I've found the root cause, it's not related to the flask\r\nso this is not a flask bug"
    ]
  },
  {
    "title": "deprecate `__version__`",
    "body": "The `__version__` attribute is an old pattern from early in Python packaging. Setuptools eventually made it easier to use the pattern by allowing reading the value from the attribute at build time, and some other build backends have done the same.\r\n\r\nHowever, there's no reason to expose this directly in code anymore. It's usually easier to use feature detection (`hasattr`, `try/except`) instead. `importlib.metadata.version(\"werkzeug\")` can be used to get the version at runtime in a standard way, if it's really needed.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5230",
    "comments": [
      "Reported to Sentry here: https://github.com/getsentry/sentry-python/issues/2316",
      "Hello @davidism ,\r\n\r\nI'm new to contributing to this repo & worked on addressin deprecation of __version__ as per this issue. After removing __version__ attribute, I tried to install Flask in editable mode with pip install -e . but faced an error. Below is  snippet of the error for reference, build tool is expecting a version string.  I'm unsure about how to proceed to smooth packaging and installation processes without the __version__ attribute. Any suggestions on the best approach to take? \r\n\r\n```\r\nFile \"/private/var/folders/s0/7jlcj_t57vz0r3bnk_wz3jx40000gq/T/pip-build-env-x3a6o9q7/overlay/lib/python3.11/site-packages/flit_core/common.py\", line 251, in check_version\r\n          raise NoVersionError('Cannot package module without a version string. '\r\n      flit_core.common.NoVersionError: Cannot package module without a version string. Please define a `__version__ = \"x.y.z\"` in your module.\r\n      [end of output]\r\n```",
      "I guess this wasn't clear, but this isn't an issue we we looking for a contributor for. For one thing, this didn't say remove, this says deprecate, which is a different process. I've already done this, just haven't made a PR yet. ",
      "Thanks for the clarification. I misunderstood the goal of the issue. The phrasing \"there's no reason to expose this directly in code anymore\" thought me to believe that it might be a good idea to remove __version__. I see now that intention was to deprecate it rather than remove it outright.\r\n\r\nI am eager to learn, contribute more effectively to the project. If there are other areas or issues where I can help, please let me know @davidism "
    ]
  },
  {
    "title": "flask out of memory",
    "body": "1. use Flask create an app in manage.py and register blueprint.\r\n2. In back_controller, ping_test return a simple dict and memory_test show memory usage with pyhon gc module.\r\n3. In test_interface, for loop request multiple times, and memory out happed. \r\n\r\n- [structure](https://i.stack.imgur.com/1JL5T.png) \r\n- [manage.py](https://i.stack.imgur.com/s85oI.png) \r\n- [common.py](https://i.stack.imgur.com/wHDNz.png) \r\n- [back_controller.py](https://i.stack.imgur.com/9Ef5A.png) \r\n- [test_interface.py](https://i.stack.imgur.com/opOnc.png) \r\n- [first memory usage detail](https://i.stack.imgur.com/EUOqr.png) \r\n- [last memory usage detail](https://i.stack.imgur.com/cNieJ.png) \r\n- [pip list](https://i.stack.imgur.com/SepEx.png)",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5221",
    "comments": [
      "Posting code as images is rude. If there's an actual issue, create a minimal reproducer repo. WITHOUT your data science stack."
    ]
  },
  {
    "title": "flask debug (auto reload) feature not working",
    "body": "\r\nthe issue when i create docker container for the app with dockerfile\r\nENTRYPOINT [ \"python3\", \"-m\", \"flask\", \"run\", \"--debug\", \"--host=0.0.0.0\"]\r\neverything works fine but when i change anything in the code i don't see anything change if i wanna see the changes\r\ni have to rebuild the container\r\n\r\nnote: i am using correct volume\r\nand when i exec the container i can see the changes in the file\r\n\r\n\r\n![hsdf](https://github.com/pallets/flask/assets/129284063/962ffd93-f077-45ce-837b-ef05d48f6ced)\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10\r\n- Flask version: 2.2.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5219",
    "comments": []
  },
  {
    "title": "Resource leaking in http-stream-request",
    "body": "If I stop a stream request before it's finished, the stream function will never finish, without any exception or warning.\r\nSo, if I want to release something (such as threading.Lock) in the end of the function, I will never be able to release it.\r\n\r\nHere's an example.\r\n\r\n```\r\n# flask server\r\nimport time\r\nfrom flask import *\r\n\r\n\r\ndef stream():\r\n    print(\"acquire something\")\r\n    for i in range(5):\r\n        yield str(i)\r\n        time.sleep(1)\r\n    print(\"release something\")\r\n\r\n\r\napp = Flask(__name__)\r\n\r\n\r\n@app.route(\"/\")\r\ndef _():\r\n    return Response(stream())\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(\"0.0.0.0\", 45678)\r\n```\r\n\r\nwhen I request it and stop it early (for example, I'm timeout)\r\n\r\n```\r\n>>> curl http://localhost:45678 --max-time 2\r\n01curl: (28) Operation timed out after 2002 milliseconds with 2 bytes received\r\n```\r\n\r\nthen, the function stream() will never stopped, here's the log.\r\n\r\n```\r\nacquire something\r\n127.0.0.1 - - [13/Aug/2023 18:17:01] \"GET / HTTP/1.1\" 200 -\r\n```\r\n\r\nI wish, flask will do like one of these:\r\n\r\n* throw a ResourceWarning when the request has stopped\r\n* run stream() to the end, whatever the request stop or not\r\n* if stream() is an AsyncIterator(Coroutine), send an Exception into it when the request has stopped\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.9\r\n- Flask version: 2.2.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5218",
    "comments": [
      "It would be up to the WSGI server to close the response or destroy the worker. It's not something the WSGI application (Flask) can control. There's no way to do the things you suggest from our end.",
      "I see, it's a bug from werkzeug, not from Flask. Thanks.",
      "Werkzeug is also the application side. If you're referring to the dev server, it won't be fixed there. Use a production WSGI server. "
    ]
  },
  {
    "title": "Application Dispatching Docs Reference Removed `werkzeug` Function",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\nThe [\"Dispatch by Path\" section of app dispatching docs](https://github.com/pallets/flask/blob/main/docs/patterns/appdispatch.rst#dispatch-by-path) reference now-removed functions, `werkzeug.wsgi.peek_path_info` and `werkzeug.wsgi.pop_path_info`.\r\n\r\nThese functions were [deprecated in Werkzeug 2.2.0](https://github.com/pallets/werkzeug/pull/2461) and [removed in Werkzeug 2.3.0](https://github.com/pallets/werkzeug/pull/2592).\r\n\r\nUsing the documented example as-is produces `ImportError`s.\r\n\r\nSince Flask 2.3 requires Werkzeug 2.3.6 or later, the documentation contain an example that works with Werkzeug's updated API. \r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.9\r\n- Flask version: 2.3.2\r\n",
    "labels": [
      "docs"
    ],
    "url": "https://github.com/pallets/flask/issues/5214",
    "comments": [
      "Happy to review a PR.",
      "I'm not familiar enough with `Werkzeug` and these more advanced patterns to know what the proper solution would be.",
      "Thank you @pavithra-m13 and @davidism!"
    ]
  },
  {
    "title": "After initialization/before run hook",
    "body": "I'm writing a Flask extension with non trivial setup and the need to do consistency checks before allowing it to run.\r\nI have not found a hook/signal which would tell me that Flask is ready to run, before any request has arrived, so that I could plug these checks. Such a hook would be appreciated. Waiting for the first request is too late to report a configuration error.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5209",
    "comments": [
      "why can't you do it during `init_app()`?",
      "I assume that you suggest that the user code should invoke some method to tell that the setup is done so that checks can be performed.\r\nIf the user has to do it, they could do it at the wrong time (eg some initialization may depend on import ordering), or even forget it.\r\nI do not think that the user should have to bother about that, it is no their problem, it belongs to the framework which should probably known when it is ready to run or running. Hopefully.\r\nIf I want to check that the user has not forgotten, it means clobbering every entry point with a check, which is a pain and a loss of cpu time.",
      "Note that there is an *internal* `_check_setup_finished` thingy in `Flask`, which suggest that it knows about this event, but is not exposed to extensions or users.",
      "My point was that if you want to use a flask extension, you eventually need to do `your_ext = YourExtension(app)` or `your_ext = YourExtension()` and later (again once the configuration has been fully loaded) call `your_ext.init_app(app)`.\r\n\r\nSo there's already a well-defined initialization flow someone using Flask and Flask extensions needs to follow. There should not be a need for additional initialization beyond that.\r\n\r\nThen again, if you do something \"special\", you'll have to come up with something more something concrete... \"*a Flask extension* with non trivial setup\" makes it really hard to explain what you *should* do in case of any special requirements.",
      "Hmmm\u2026 it seems that you do not need to really understand the issue to close it\u2026 If I may add something on the closed issue:\r\n\r\n> My point was that if you want to use a flask extension, you eventually need to do `your_ext = YourExtension(app)` or `your_ext = YourExtension()` and later (again once the configuration has been fully loaded) call `your_ext.init_app(app)`.\r\n\r\nNo, I do not *need* that. I need that **only** if I do not have the appropriate hooks. Calling both the constructor and then some `init_app` looks like stammering and is best avoided if not strictly necessary, which is the case here.\r\n\r\n> So there's already a well-defined initialization flow someone using Flask and Flask extensions needs to follow.\r\n\r\nNo, it does not *need* to, at least in this case. The extension overrides some Flask features to extend them so the pattern is *not* to use it with the usual extension pattern, but to use Flask simple direct pattern, which is must simpler for the user:\r\n\r\n```python\r\nfrom TheExtension import Flask\r\napp = Flask(...)\r\napp.config.from_envvar(\"APP_CONF\")\r\n\r\n@app.get(\"/foo\", authorize=\"READER\", auth=\"basic\", realm=\"whatever\")\r\ndef get_foo(...):\r\n    # users authentified with a basic scheme in realm whatever and in group READER can get here\r\n    \u2026\r\n```\r\n\r\n> There should not be a need for additional initialization beyond that.\r\n\r\nYes and no. I want not to *need* the second initialization call because it may be placed or executed at the wrong time\r\nquite easily. To avoid that, I wish I had a hook. I do without but with stupid code that I could move if I had a hook.\r\n \r\n> Then again, if you do something \"special\", you'll have to come up with something more something concrete... \"_a Flask extension_ with non trivial setup\" makes it really hard to explain what you _should_ do in case of any special requirements.\r\n\r\nI do not know if I do something *special*. If you are interested to understand what it does, the extension [FlaskSimpleAuth](https://github.com/zx80/flask-simple-auth). Note that it already works with stupid code which performs the checks at the last possible moment, currently when adding a route so I can assume that all configuration setup have been managed by then. If I had an appropriate hook I could remove the stupid code.\r\n\r\nISTM that other extensions could benefit from this kind of additional hooks/signals as well.\r\n",
      "I have the feeling you misunderstand what flask extensions are / how they work... Flask extensions do not subclass the original Flask class (even though doing so is perfectly fine, but typically not in an extension). They are registered on a Flask instance, by one of the two methods I explained.",
      "> I have the feeling you misunderstand what flask extensions are / how they work... Flask extensions do not subclass the original Flask class (even though doing so is perfectly fine, but typically not in an extension). They are registered on a Flask instance, by one of the two methods I explained.\r\n\r\nOk, the stuff I wrote may not a Flask *extension* per-se as it subclasses (not really, but in appearance yes) Flask.\r\nNote that it can be used as an extension as well, but I prefer not to advertise it because using it as an extension weakens the security guaranties the framework wants to provide.\r\n\r\nNow, this *not-really-a-Flask-extension* but *kind-of-wrapper-around* flask would benefit from a hook or signal which would tell when the configuration is done so that configuration consistency checks could be performed. If these checks are not performed, some route will fail miserably when invoked by a client, so they are somehow performed, but too late.\r\n\r\nThe underlying software engineering issue is that the extension provide hooks so that the user can change some features, eg how to check a password, if they do not like the very reasonable default provided, or really need something else (eg LDAP or whatever). Because these changes or additions can be declared here and there, possibly with decorators, in different files imported in pseudo-random orders, the code cannot know easily when these initialization are done and consistency checks can be performed, eg it is not obvious that a custom authentication scheme registration is performed *before* a route requires it. In order to circumvent this ordering issue, some checks are deferred to *later*, and this later would be nicely implemented if there was an *after initialization* hook where the framework knows that settings will not change further. I suspect that this already exists *inside* flask, but is not accessible.",
      "WSGI has no hook into the application lifecycle, no way to distinguish \"server started, app ready\" from each worker creating the app while handling requests. What you're asking for is not possible. If you're subclassing Flask, you're already telling users to do something custom. It's ok to tell them to call `app.finalize_setup()` or something at the end of their app factory function.",
      "Ok, WSGI does not cooperate:-(\r\n\r\nMy current work around is to do the checks when adding a route, i.e. I assume that all initializations (configuration, hook registering, ...) are done when `app.route` is called. This means that some checks which can change because they also depend on route settings are done over and over again\u2026 So I was na\u00efvely hoping for a miraculous hook. I'll keep my stupid code and chicken and egg issue instead. I do not want to do that in some finalize setup function, because the user may/will certainly forget to call it.\r\n\r\nThanks for the answer.",
      "Glad we could clear it up. Just a heads up for next time, telling maintainers \"it seems that you do not need to really understand the issue to close it\" isn't a good way to interact in the future. Clearly, we are deeply experienced with what is possible and what we want in the library, assuming otherwise isn't productive and came off as rude.",
      "Please accept my apology for my occasional rudeness in expressing myself.\r\n\r\nNote that closing an issue while the discussion is not yet fully concluded for some participant can feel a little bit like a \"shut up\". However, providing a clear answer is very nice, so thanks again.\r\n\r\nHave a nice day/night/whatever!"
    ]
  },
  {
    "title": "Non-string anchors no longer work",
    "body": "Passing non-string values to `url_for` no longer works. For example,\r\n\r\n```py\r\nurl_for('my_endpoint', _anchor=5)\r\n```\r\n\r\nIt now fails with `TypeError: quote_from_bytes() expected bytes`.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5206",
    "comments": [
      "Werkzeug is deprecating and removing bytes support, so this would be fixed there if necessary. But it was never intended to accept non-strings, that was just a side effect of the extra checks that were required to support bytes. I don't really see the value in changing this back.",
      "> But it was never intended to accept non-strings, that was just a side effect of the extra checks that were required to support bytes\r\n\r\nThe effect was that you could pass non-strings to this function and they would be converted automatically. Many other parameters to this function work this way. For example, if you have an `int` parameter on your endpoint, it will be converted to `str` automatically.\r\n\r\nThe intention doesn't really matter. This is a regression in behavior.",
      "Where was the deprecation period? You should also have something in the release notes about changing the behavior...",
      "https://flask.palletsprojects.com/en/2.3.x/changes/#version-2-3-0\r\n\r\n> Update minimum requirements to the latest versions: Werkzeug>=2.3.0\r\n\r\nhttps://werkzeug.palletsprojects.com/en/2.3.x/changes/#version-2-3-0\r\n\r\n> Deprecate the `werkzeug.urls` module, except for the `uri_to_iri` and `iri_to_uri` functions. Use the `urllib.parse` library instead.\r\n\r\n> Passing bytes where strings are expected is deprecated ... Anywhere that was annotated, documented, or tested to accept bytes shows a warning.\r\n\r\nPassing a non-string as an anchor was never intentionally supported, you were relying on undefined behavior. I don't plan to add a warning back in just to then remove it again. It's the same result either way here: you need to pass a string."
    ]
  },
  {
    "title": "Give possibility to change the MAX_FORM_PARTS of werkzeug",
    "body": "## Adding  MAX_FORM_PARTS to the config of flask\r\nThis feature allows for the customization of the maximum number of form parts when reading a request. The max_form_parts parameter has been introduced in Werkzeug version 2.2.3 - https://github.com/pallets/werkzeug/blob/4048509fb24196df67f944a24aaa4ce1afcba92f/src/werkzeug/wrappers/request.py#L90.\r\n\r\n\r\nReal use case: Apache Superset uses Flask-AppBuilder for editing user roles in the application. Currently, when there are roles with 1000+ users, the editing process fails with a 413 error due to the max_form_parts limit, which cannot be changed in the current version of Flask.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5203",
    "comments": [
      "You can already do that. Subclass the Request class and set `max_form_parts = ...` on it. And set `request_class = YourRequestClass` on your Flask instance (or a custom subclass thereof).\r\n\r\nAlso IIRC we reverted this to only apply to multipart requests (you typically only use those if you also have a file upload field), so if it's just normal form fields, then it should usually be fine."
    ]
  },
  {
    "title": "Wrong Behavior in Blueprints",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\nWhen the `import_name` of my blueprint is set to `__name__`, if the name of my python file is different from that of the upper-level folder, other loaded blueprints will become invalid.\r\n\r\njust like it:\r\n![image](https://github.com/pallets/flask/assets/63963655/25a5757c-a264-492e-9576-02111f7e74c6)\r\n\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n```py\r\nfrom flask import Flask\r\nfrom gevent import pywsgi\r\nimport logging\r\nimport os\r\nimport importlib\r\n\r\n\r\nclass Server:\r\n    def __init__(self):\r\n        self.app = Flask(__name__, static_folder='./RKR', static_url_path='/')\r\n        ...\r\n\r\n    def start(self, debug: bool, port: int):\r\n        if debug:\r\n            logging.info(\"DEBUG IS TRUE.Using Flask.App.Run .\")\r\n            self.app.run(host='0.0.0.0', debug=True, port=port)\r\n        else:\r\n            logging.info(\"Using WSGI .\")\r\n            server = pywsgi.WSGIServer(('0.0.0.0', port), self.app)\r\n            server.serve_forever()\r\n\r\n    def load_blueprint(self):\r\n        liss = list()\r\n        modules = {}\r\n        directory = \".\\\\src\\\\pages\"\r\n        lis = list()\r\n        for root, dirs, files in os.walk(directory):\r\n            for file in files:\r\n                if file.endswith(\".py\"):\r\n                    file_path = os.path.join(root, file)\r\n\r\n                    file_path = file_path.replace(\".\\\\\", \"\").replace(\".py\", \"\").split(\"\\\\\")\r\n                    lis.append(file_path)\r\n        for i in lis:\r\n            m = \"\"\r\n            for j in range(0, len(i)):\r\n                if j == 0:\r\n                    m = i[0]\r\n                else:\r\n                    m = m + \".\" + str(i[j])\r\n            liss.append(m)\r\n        for i in liss:\r\n            logging.info(f\"Load {i} .\")\r\n            module = importlib.import_module(i)\r\n            modules[i] = module\r\n        for i in liss:\r\n            self.app.register_blueprint(modules[i].page)\r\n\r\n    def run_server(self, debug: bool, port: int):\r\n        self.load_blueprint()\r\n        self.start(debug, port)\r\n\r\n# Server1 = Server()\r\n# Server1.run_server(True, 5000)\r\n```\r\n\r\nit import\r\n\r\n ```\r\nsrc.pages.shelf.bookshelf.bookshelf\r\nsrc.pages.shelf.bookinfo.book_info #if it is src.pages.shelf.book_info.book_info it will be normal\r\n```\r\n\r\nbookshelf:\r\n```py\r\nfrom flask import Blueprint\r\nfrom flask import render_template as template\r\nimport src.book as book\r\n\r\nname = \"bookshelf\"\r\npage = Blueprint(name, __name__, template_folder=\".\\\\files\")\r\n\r\n@page.route(\"/\", methods=['GET', 'POST'])\r\ndef bookshelf():\r\n    book_info = book.get_book_shelf()\r\n    return template(\"index.html\", book_info=book_info)\r\n\r\n```\r\n\r\nbook_info:\r\n```py\r\nfrom flask import Blueprint, request\r\nfrom flask import render_template as template\r\nimport src.book as book\r\n\r\nname = \"book_info\"\r\npage = Blueprint(name, __name__, template_folder=\".\\\\files\")\r\n\r\n\r\n@page.route(\"/shelf/book_info\", methods=['GET', 'POST'])\r\ndef bookshelf():\r\n    data = request.args\r\n    return data\r\n\r\n```\r\n\r\ntree:\r\n```\r\n\u251c\u2500src\r\n\u2502  \u251c\u2500pages\r\n\u2502  \u2502  \u251c\u2500search\r\n\u2502  \u2502  \u251c\u2500shelf\r\n\u2502  \u2502  \u2502  \u251c\u2500bookinfo\r\n\u2502  \u2502  \u2502  \u2502  \u251c\u2500files\r\n\u2502  \u2502  \u2502  \u2502  \u2514\u2500__pycache__\r\n\u2502  \u2502  \u2502  \u251c\u2500bookshelf\r\n\u2502  \u2502  \u2502  \u2502  \u251c\u2500files\r\n\u2502  \u2502  \u2502  \u2502  \u2514\u2500__pycache__\r\n\u2502  \u2502  \u2502  \u2514\u2500__pycache__\r\n\u2502  \u2502  \u2514\u2500viewer\r\n\u2502  \u251c\u2500RKR\r\n\u2502  \u2502  \u2514\u2500asset\r\n\u2502  \u2502      \u2514\u2500img\r\n\u2502  \u2514\u2500__pycache__\r\n\u2514\u2500__pycache__\r\n```\r\nfull_file:\r\nhttps://github.com/Suto-Commune/Re-Kindle-Reader/tree/8a7169364779feb722197b0c42b8cbf7a346d5b7\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\nnormal behavior\r\n![image](https://github.com/pallets/flask/assets/63963655/d2529d66-0a98-4c75-8611-863df0477572)\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version: Python 3.11.4\r\n- Flask version: Flask==2.3.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5201",
    "comments": [
      "Please use Stack Overflow for questions about your own code. This tracker is for issues related to the project itself. Be sure to include a [minimal, complete, and verifiable example](https://stackoverflow.com/help/mcve)."
    ]
  },
  {
    "title": "class-based endpoints do not accept positional arguments",
    "body": "There are some Flask extensions that have decorators that inject positional arguments into decorated view functions. The one that comes to mind is [webargs](https://webargs.readthedocs.io/en/latest/), in particular its [use_args](https://webargs.readthedocs.io/en/latest/framework_support.html#decorator-usage) decorator. Here is an example based on their documentation:\r\n\r\n```python\r\nfrom flask import Flask\r\nfrom webargs import fields\r\nfrom webargs.flaskparser import use_args\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\"/user/<int:uid>\")\r\n@use_args({\"per_page\": fields.Int()}, location=\"query\")\r\ndef user_detail(args, uid):\r\n    return (\"The user page for user {uid}, showing {per_page} posts.\").format(\r\n        uid=uid, per_page=args[\"per_page\"]\r\n    )\r\n```\r\n\r\nThis is how the endpoint is invoked using `curl`:\r\n\r\n```bash\r\n$ curl -X GET http://localhost:5000/user/1\\?per_page=20\r\nThe user page for user 1, showing 20 posts.%\r\n```\r\n\r\nAfter adapting this example to a `MethodView`, this is what we end up with:\r\n\r\n```python\r\nfrom flask import Flask\r\nfrom flask.views import MethodView\r\nfrom webargs import fields\r\nfrom webargs.flaskparser import use_args\r\n\r\napp = Flask(__name__)\r\n\r\nclass UserEndpoint(MethodView):\r\n    decorators = [use_args({\"per_page\": fields.Int()}, location=\"query\")]\r\n\r\n    def get(self, args, uid):\r\n        return (\"The user page for user {uid}, showing {per_page} posts.\").format(\r\n            uid=uid, per_page=args[\"per_page\"]\r\n        )\r\n\r\napp.add_url_rule(\"/user/<int:uid>\", view_func=UserEndpoint.as_view('get_user'))\r\n```\r\n\r\nSending the same `curl` request as above to the MethodView app causes the following exception:\r\n\r\n```\r\n[2023-07-15 23:32:57,473] ERROR in app: Exception on /user/1 [GET]\r\nTraceback (most recent call last):\r\n  File \"/home/miguel/Documents/dev/flask/src/flask/app.py\", line 2190, in wsgi_app\r\n    response = self.full_dispatch_request()\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/miguel/Documents/dev/flask/src/flask/app.py\", line 1486, in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/miguel/Documents/dev/flask/src/flask/app.py\", line 1484, in full_dispatch_request\r\n    rv = self.dispatch_request()\r\n         ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/miguel/Documents/dev/flask/src/flask/app.py\", line 1469, in dispatch_request\r\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/miguel/Documents/dev/flask/venv/lib/python3.11/site-packages/webargs/core.py\", line 649, in wrapper\r\n    return func(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^\r\nTypeError: View.as_view.<locals>.view() takes 0 positional arguments but 1 was given\r\n127.0.0.1 - - [15/Jul/2023 23:32:57] \"GET /user/1?per_page=20 HTTP/1.1\" 500 -\r\n```\r\n\r\nThe reason of this failure is that the positional argument(s) injected by the `use_args` decorator are not accepted by the view function returned by `View.as_view()`. My expectation is that any positional arguments passed into the view function generated from the View or MethodView instance would be accepted by its `dispatch_request()` method, which in turn would pass them on to the `get()`, `post()`, etc. when `MethodView` is used.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11\r\n- Flask version: 2.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5199",
    "comments": [
      "I don't know if #5200 should be merged. But I have some related info to share.\r\n\r\nFrom webargs 9, the arguments passed to the view function will always be keyword arguments ([docs](https://webargs.readthedocs.io/en/latest/advanced.html#argument-passing-and-arg-name)).\r\n\r\nI tried to do the same thing with #4776. Then I request to support keyword argument for webargs's `use_args` in https://github.com/marshmallow-code/webargs/issues/830, which is implemented in https://github.com/marshmallow-code/webargs/pull/833 and released with 8.3.0. For webargs 8, you could set the config  `USE_ARGS_POSITIONAL` to enable this feature:\r\n\r\n```py\r\nclass KeywordOnlyParser(FlaskParser):\r\n    USE_ARGS_POSITIONAL = False\r\n```\r\n",
      "Thanks for reporting it to webargs too, I hadn't seen that. I was going to link to your previous issue as well, since it's the same answer. I don't think accepting `*args` was intentional in the past, view functions are only passed `**kwargs`. WebArgs, APIFlask, and Quart-Schema all support passing by kwargs.",
      "This does not affect me in any way as I'm not a fan of class-based views, but it is noneless a disapointing decision. You may not like positional args, but injecting args into functions through decorators is a well established practice that trascends Flask views.\r\n\r\nHere you had two options. One option would have been to say I'll just allow decorators for class-based views to work exactly like the do for regular function-based views, and if someone wants to inject positional args it is their business. Instead you have chosen to restrict some decorators that work fine for function-based views from being used with class-based views, causing an obscure error that requires people like myself to spend time debugging to be able to figure out, and forcing developers to adopt your own views of how a Flask view function should be constructed.\r\n\r\nAs I said, I don't need this myself and I personally do not care, but you have made a bad design decision here."
    ]
  },
  {
    "title": "Running tox -e style with docker causes \"An error has occurred: FatalError: git failed. Is it installed, and are you in a Git repository directory?\"",
    "body": "Using the tox docker image to run the pre-commit check causes git error.\r\n\r\nSteps to reproduce:\r\n\r\ndocker run -v `pwd`:/tests -it --rm 31z4/tox tox -e style\r\n\r\n\r\n```\r\n ~/newgit/github/flask \ue0b0 \ue0a0 main \ue0b0 docker run -v `pwd`:/tests -it --rm 31z4/tox tox -e style\r\nstyle: commands[0]> pre-commit run --all-files\r\nAn error has occurred: FatalError: git failed. Is it installed, and are you in a Git repository directory?\r\nCheck the log at /home/tox/.cache/pre-commit/pre-commit.log\r\nstyle: exit 1 (0.97 seconds) /tests> pre-commit run --all-files pid=15\r\n  style: FAIL code 1 (1.11=setup[0.14]+cmd[0.97] seconds)\r\n  evaluation failed :( (1.36 seconds)\r\n \u2718 \ue0b0 ~/newgit/github/flask \ue0b0 \ue0a0 main \ue0b0\r\n\r\n```\r\n\r\nlog file Inside the container \r\n```\r\n\r\n\r\n tox@04e24a2a1e66:/tests$ cat  /home/tox/.cache/pre-commit/pre-commit.log\r\n### version information\r\n\r\npre-commit version: 3.3.3\r\ngit --version: git version 2.34.1\r\nsys.version:\r\n    3.11.4 (main, Jun  7 2023, 12:45:48) [GCC 11.3.0]\r\nsys.executable: /tests/.tox/style/bin/python\r\nos.name: posix\r\nsys.platform: linux\r\n\r\n### error information\r\n\r\nAn error has occurred: FatalError: git failed. Is it installed, and are you in a Git repository directory?\r\n\r\nTraceback (most recent call last):\r\n  File \"/tests/.tox/style/lib/python3.11/site-packages/pre_commit/git.py\", line 58, in get_root\r\n    cmd_output('git', 'rev-parse', '--show-cdup')[1].strip(),\r\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/tests/.tox/style/lib/python3.11/site-packages/pre_commit/util.py\", line 116, in cmd_output\r\n    returncode, stdout_b, stderr_b = cmd_output_b(*cmd, **kwargs)\r\n                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/tests/.tox/style/lib/python3.11/site-packages/pre_commit/util.py\", line 110, in cmd_output_b\r\n    raise CalledProcessError(returncode, cmd, stdout_b, stderr_b)\r\npre_commit.util.CalledProcessError: command: ('/usr/bin/git', 'rev-parse', '--show-cdup')\r\nreturn code: 128\r\nstdout: (none)\r\nstderr:\r\n    fatal: detected dubious ownership in repository at '/tests'\r\n    To add an exception for this directory, call:\r\n\r\n    \tgit config --global --add safe.directory /tests\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/tests/.tox/style/lib/python3.11/site-packages/pre_commit/error_handler.py\", line 73, in error_handler\r\n    yield\r\n  File \"/tests/.tox/style/lib/python3.11/site-packages/pre_commit/main.py\", line 370, in main\r\n    _adjust_args_and_chdir(args)\r\n  File \"/tests/.tox/style/lib/python3.11/site-packages/pre_commit/main.py\", line 180, in _adjust_args_and_chdir\r\n    toplevel = git.get_root()\r\n               ^^^^^^^^^^^^^^\r\n  File \"/tests/.tox/style/lib/python3.11/site-packages/pre_commit/git.py\", line 64, in get_root\r\n    raise FatalError(\r\npre_commit.errors.FatalError: git failed. Is it installed, and are you in a Git repository directory?\r\n```\r\n\r\n\r\n\r\n\r\nExpected result:\r\npre-commit should run without any git issue. \r\n\r\nMore information\r\nhttps://weblog.west-wind.com/posts/2023/Jan/05/Fix-that-damn-Git-Unsafe-Repository\r\n\r\n\r\nEnvironment:\r\n\r\n- Python version:\r\n- Flask version:\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5197",
    "comments": [
      "closing this PR to fix this in the docker image \r\nhttps://github.com/31z4/tox-docker/pull/1"
    ]
  },
  {
    "title": "flask don't reload if a filename is changed.",
    "body": "Flask will reload if I change some lines in the file. But it won't reload if I changed a filename. ",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5193",
    "comments": [
      "The stat reloader only detects changes within files, not creates/moves/deletes on their own. Save a file after moving it and it will work. The watchdog reloader detects those events."
    ]
  },
  {
    "title": "Flask server doesn't reload when templates modifies",
    "body": "Flask server doesn't reload when templates modifies\r\n\r\nFirst I created a Flask server with a virtual environment with venv  and I installed python-dotenv and libsass following the instructions of their respective official websites.\r\n\r\nAfter that I created a package called 'store' in a folder with the same name.\r\n\r\nThen I created a 'store/templates/home.html' and a 'store/static/scss/style.scss' \r\n\r\nAll works right but I need to reload the browser manually every time I have to modify  either *.html or *.scss files of the templates.\r\n\r\nI expected browser reloads automatically every time I need to modify a template or css style.\r\n\r\nEnvironment & modules:\r\n- Windows 10\r\n- Git Bash terminal\r\n- VS Code\r\n- Chrome 114\r\n\r\n- Python version: 3.10\r\n- Flask version: 2.3.2\r\n- python-dotenv 1.0.0\r\n- libsass 0.22.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5192",
    "comments": [
      "We don't implement hot reloading within the browser window, only reloading the server itself on code changes. I'm fairly sure there's some extension that provides this.",
      "Thanks for the answer @davidism\r\n\r\nThe issue is that the Flask server doesn't reload when the template code changes either.",
      "Yes it does. But it doesn't reload the rendered output in the current browser page. That's what I meant before with \"hot reloading within the browser\"."
    ]
  },
  {
    "title": "Confusing usage of `app.json_provider_class` and `app.json`",
    "body": "- Python version: 3.10.4\r\n- Flask version: 2.3.2 \r\n\r\nRecently I updated to Flask 2.3.2 and found that `JSONEncoder`  is removed, so I tried to find the new way to change the default json formatter. By searching the code, I found the class `DefaultJSONProvider` and wrote my own. And after I set `app.json_provider_class = CustomJsonProvider`, I found it does not work as expected. After a long time reading the source code and debugging, I realized that the `app.json` variable was not changed.\r\n\r\nJust like what #5052 has discussed, I also think it's better to improve this API. Whether making `app.json_provider_class`  both `getter` and `setter` or making the API private might be better. I mean, not everyone will read the document of every framework, and when I want to modify the json formatter, I would like to just type `app.json` and see what the IDE will show.  Moreover, when using flask, it's rarely to see someone extends the class `Flask` to reset the `json_provider_class`, they just change the property of the global variable `app` instead.\r\n\r\nIf needed, I'm glad to PR.\r\n\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5190",
    "comments": [
      "Plus a million to this. This costed me 2h of debugging because I could not understand what was going on. I think the easiest fix it to allow `json_provider_class` to be set in the constructor of the `Flask` object.\r\n\r\nI really like flask and I am really gratefully for all the effort the maintainers are putting into this. But, I am sorry to say that this is a very pointless footgun, I am absolutely open to the idea that there is a good reason to design it like this but I really cannot understand what it would be."
    ]
  },
  {
    "title": "Uberweb: An idea for flask web-app generator",
    "body": "Hello, there!\r\nThank you for this great project.\r\n\r\nI've an idea for flask project : A Flask Web-app generator, just for fun ! (Like 'Django', 'Express.js', or something these)\r\nIt's call 'Uberweb'.\r\nFor more information, you can visit its git repository -> [UberWeb](https://github.com/Paradoxer32/uberweb)\r\nTell me your ideas about that.\r\nIf you liked, develop it or introduce it in flask docs !\r\n\r\nHave a nice time !\r\n-Ahoora",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5181",
    "comments": [
      "We don't plan to add projects like this to Flask itself. You'll also want to check out projects like https://github.com/cookiecutter-flask/cookiecutter-flask amd other project templates. "
    ]
  },
  {
    "title": "Seemingly Flask \"cached\" HTML page never loads updated version -- not using Flask Cache (or any cache)",
    "body": "I've got an HTML file being served from Flask as an iframe that is set to reload every 3 seconds. This is because I modify the file externally to Flask, but from the same python file that initiates Flask. I had what I thought was a great working program. I've finally squashed every bug and undesired function in my code that I've come across, so I figured lets make sure it works without debug mode. I turned it off, and started to use the program. Everything seemed ok for a little while, so I promptly forgot that it was no longer in debug mode. Then I started noticing strange things. Certain functions were being called via manual browser reloads that had not been previously called due to browser reloads. Then the big one: Somewhere, Flask has an undocumented cache. That file that reloads every 3 seconds keeps loading the same version of the file despite being changed. The file that I can open and inspect on my computer shows the expected changes to the file. The file that Flask sends to my browser does not. I tried other browsers. I cleared browser and Windows caches. I tried changes to the code. I tried restarting the program. I tried closing the command line. I googled, I overflowed my stacks. I checked my system processes for multiple copies of Python and flask running when I thought they were closed, etc. Nothing. I go back to debug mode and suddenly, it works again.\r\n\r\nTLDR; Flask serves old versions of updated HTML files repeatedly if debug mode is turned off. No amount of reloading or cache clearing will get the updated file.\r\n\r\nI'm not exactly sure how to replicate the bug, but I presume the circumstances involve having an \"externally\" modified HTML file inside the template folder, turn off debugging mode, reload the browser a few times and look for changes to the browser processed HTML output compared to the source of the actual file. Looking at page source from within the browser will of course show the cached version's source. Use Notepad++ or something to look at the actual file that should be served.\r\n\r\nWhen I have every single cache disabled or cleared, I expect the new version of the HTML file to be served to my browser. \r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.3\r\n- Flask version: 2.3.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5174",
    "comments": []
  },
  {
    "title": "make_response(\u2026) won't accept a MappingProxyType object as a view's return-value",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n# `make_response(\u2026)` Won't Accept a `MappingProxyType` Object As a View's Return-Value\r\n\r\n# Replicative Demonstration\r\n\r\n## app.py\r\n\r\n```python\r\nfrom types import MappingProxyType\r\n\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\nresponse_body_dict         = dict(            { 'spam': 'eggs' })\r\nresponse_body_mappingproxy = MappingProxyType({ 'spam': 'eggs' })\r\n\r\nassert response_body_dict == response_body_mappingproxy\r\n\r\n@app.route(\"/with-dict\")\r\ndef with_dict():\r\n    return response_body_dict\r\n\r\n@app.route(\"/with-mappingproxytype\")\r\ndef with_mappingproxytype():\r\n    return response_body_mappingproxy\r\n```\r\n\r\n## Shell (*Tab A*)\r\n\r\n```bash\r\nflask --debug run\r\n```\r\n\r\n## Shell (*Tab B*)\r\n\r\n```bash\r\n$ curl localhost:5000/with-dict\r\n{\r\n  \"spam\": \"eggs\"\r\n}\r\n```\r\n\r\n```bash\r\n$ curl localhost:5000/with-mappingproxytype\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/j/.local/share/virtualenvs/flask-mappingproxy-814v2y5D/lib/python3.11/site-packages/flask/app.py\", line 2213, in __call__\r\n    return self.wsgi_app(environ, start_response)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/j/.local/share/virtualenvs/flask-mappingproxy-814v2y5D/lib/python3.11/site-packages/flask/app.py\", line 2193, in wsgi_app\r\n    response = self.handle_exception(e)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/j/.local/share/virtualenvs/flask-mappingproxy-814v2y5D/lib/python3.11/site-packages/flask/app.py\", line 2190, in wsgi_app\r\n    response = self.full_dispatch_request()\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/j/.local/share/virtualenvs/flask-mappingproxy-814v2y5D/lib/python3.11/site-packages/flask/app.py\", line 1487, in full_dispatch_request\r\n    return self.finalize_request(rv)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/j/.local/share/virtualenvs/flask-mappingproxy-814v2y5D/lib/python3.11/site-packages/flask/app.py\", line 1506, in finalize_request\r\n    response = self.make_response(rv)\r\n               ^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/j/.local/share/virtualenvs/flask-mappingproxy-814v2y5D/lib/python3.11/site-packages/flask/app.py\", line 1837, in make_response\r\n    raise TypeError(\r\nTypeError: The view function did not return a valid response. The return type must be a string, dict, list, tuple with headers or status, Response instance, or WSGI callable, but it was a mappingproxy.\r\n```\r\n*(above response is abridged)*\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\n# Environment\r\n\r\n- Python version: CPython 3.11.4\r\n- Flask version: 2.3.2\r\n\r\n# Cf.\r\n\r\n> **See also:** `types.MappingProxyType` can be used to create a read-only view of a `dict`.\r\n\r\n[https://docs.python.org/3/library/stdtypes.html#mapping-types-dict](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)\r\n\r\n>  **class `types.MappingProxyType(mapping)`**\r\n>\r\n>    Read-only proxy of a mapping. It provides a dynamic view on the mapping\u2019s entries, which means that when the mapping changes, the view reflects these changes.\r\n\r\n[https://docs.python.org/3/library/types.html#types.MappingProxyType](https://docs.python.org/3/library/types.html#types.MappingProxyType)",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5172",
    "comments": [
      "That's right, it specifically accepts a dict. I don't plan to change this. You can override Flask.make_response to handle whatever you need. "
    ]
  },
  {
    "title": "usage of sqlalchemy in patterns documentation",
    "body": "If you are using SQLAlchemy version 2.0.0 or above and are following the Flask documentation on creating a base class for models using the `declarative_base()` function, you should be aware that this function is now deprecated and will be removed in a future release.\r\n\r\nTo address this issue, you can replace the use of `declarative_base()` with the new `orm.declarative_base()` function, which is available in SQLAlchemy 2.0.0 and above. This new function provides the same functionality as the old `declarative_base()` function but is not deprecated.\r\n\r\nalert of SQLAlchemy:\r\n`MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\r\n`\r\n\r\n\r\nEnvironment:\r\n- Python version: 3.10.6\r\n- Flask version: 2.3.2\r\n- SQLAlchemy: 2.0.16\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5169",
    "comments": [
      "Happy to review a PR "
    ]
  },
  {
    "title": "Flask not handling POST data in some circumstances",
    "body": "I am trying to use Flask as a lightweight webserver to accept data from a WiFi-enabled weather station, which makes an HTTP POST request every 60 seconds. I captured the request using an http echo server:\r\n\r\n```json\r\n{\r\n    \"path\": \"/report\",\r\n    \"headers\": {\r\n        \"host\": \"192.168.0.65\",\r\n        \"connection\": \"Close\",\r\n        \"content-type\": \"application/x-www-form-urlencoded\",\r\n        \"content-length\": \"493\"\r\n    },\r\n    \"method\": \"POST\",\r\n    \"body\": \"PASSKEY=573AF40DB42C66057D20631F706CD585&stationtype=EasyWeatherPro_V5.1.1&runtime=1&dateutc=2023-06-20+14:56:02&tempinf=73.4&humidityin=49&baromrelin=29.917&baromabsin=29.536&tempf=72.5&humidity=58&winddir=251&windspeedmph=1.12&windgustmph=2.24&maxdailygust=9.17&solarradiation=293.99&uv=2&rainratein=0.000&eventrainin=0.638&hourlyrainin=0.000&dailyrainin=0.638&weeklyrainin=0.650&monthlyrainin=0.650&yearlyrainin=0.650&totalrainin=0.650&wh65batt=0&freq=868M&model=WS2900_V2.01.18&interval=60\",\r\n    \"fresh\": false,\r\n    \"hostname\": \"192.168.0.65\",\r\n    \"ip\": \"::ffff:10.1.199.64\",\r\n    \"ips\": [],\r\n    \"protocol\": \"http\",\r\n    \"query\": {},\r\n    \"subdomains\": [],\r\n    \"xhr\": false,\r\n    \"os\": {\r\n        \"hostname\": \"http-webhook-6675856576-j2jzb\"\r\n    },\r\n    \"connection\": {}\r\n}\r\n```\r\n\r\nI made a `curl` command so I could simulate these POST requests for development & testing:\r\n\r\n```\r\ncurl -d \"PASSKEY=573AF40DB42C66057D20631F706CD585&stationtype=EasyWeatherPro_V5.1.1&runtime=1&dateutc=2023-06-20+14:56:02&tempinf=73.4&humidityin=49&baromrelin=29.917&baromabsin=29.536&tempf=72.5&humidity=58&winddir=251&windspeedmph=1.12&windgustmph=2.24&maxdailygust=9.17&solarradiation=293.99&uv=2&rainratein=0.000&eventrainin=0.638&hourlyrainin=0.000&dailyrainin=0.638&weeklyrainin=0.650&monthlyrainin=0.650&yearlyrainin=0.650&totalrainin=0.650&wh65batt=0&freq=868M&model=WS2900_V2.01.18&interval=60\" -X POST http://192.168.0.65:8080/report\r\n```\r\n\r\nUsing the `curl` command, I developed my simple application. The main part of the app grabs all the keys to process them.\r\n\r\n```py\r\n@app.route('/report', methods=['POST'])\r\ndef logEcowitt():\r\n\r\n    # Retrieve the POST body\r\n    data = request.form\r\n\r\n    for key in data:\r\n        value = data[key]\r\n```\r\n\r\nThis worked fine when I tested it with my `curl` command - all the keys and values were available. However, when I tested the app with the real data from the weather station, `request.form` had an empty value of `ImmutableMultiDict([])`. I double checked that the POST data was still there, and it was.\r\n\r\nSo I changed my app logic to parse the parameters manually:\r\n\r\n```py\r\n@app.route('/report', methods=['POST'])\r\ndef logEcowitt():\r\n\r\n    for field in request.get_data(as_text=True).split('&'):\r\n        [key, value] = field.split('=')\r\n```\r\n\r\nBut I found that `request.get_data(as_text=True)` was an empty string. Both of these methods of parsing POST data work normally \r\n\r\nI think this will be hard to replicate because the weather station is in my house and I haven't (yet) found a way of recreating the problem with `curl`. Is there a way I can turn up the debugging?I'm also going to experiment with other versions of Flask to see if this behaviour is a regression.\r\n\r\nThanks\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11\r\n- Flask version: 2.3.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5168",
    "comments": [
      "Duplicate of https://github.com/pallets/werkzeug/issues/2734. I have no way to reproduce the error, so I can't say what the issue is. It sounds like there's a problem with how this service is sending data.",
      "You can use a tool like https://smee.io/ to capture the webhook request and send/resend it to a local instance of your app. Use a debugger to set a breakpoint in `run_wsgi` and step through the code. Look at `environ` very early, try reading from `environ[\"wsgi.input\"]` to see if there's data before it gets to the request object, etc."
    ]
  },
  {
    "title": "Blueprint before_app_first_request vs record_once usage discrepancy",
    "body": "I'm working on upgrading from Flask 2.2.x to 2.3.x and I use the .before_app_first_request decorator in one of my blueprints. Following the deprecation warning, I replaced .before_app_first_request with .record_once and it was not a drop-in replacement. Not sure if this an issue in code implementation or unclear documentation.\r\n\r\n```\r\nfrom flask import Blueprint, Flask, current_app\r\n\r\nblueprint = Blueprint('my_blueprint', __name__)\r\n@blueprint.before_app_first_request\r\ndef my_test_function():\r\n    current_app.logger.info('testing')\r\n\r\napp = Flask(__name__)\r\napp.register_blueprint(blueprint)\r\napp.run()\r\n```\r\n\r\nreplace .before_app_first_request with .record_once and it will no longer run\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.11\r\n- Flask version: 2.2.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5165",
    "comments": []
  },
  {
    "title": "Config.from_file() feeds descriptor, not string to tomllib.loads()",
    "body": "**outline of what the bug is:**\r\n\r\nhttps://github.com/pallets/flask/blob/main/src/flask/config.py#L236 \r\n\r\n...has us loading from a .toml file path\r\n\r\n**Describe how to replicate the bug.**\r\n\r\nhttps://docs.python.org/3/library/tomllib.html provides `load()` for `rb` files, and `loads()` for .toml strings.\r\n\r\n**Describe the expected behavior that should have happened but didn't.**\r\n\r\nTo get to desired behavior, I added another function to read in the .toml and provide it to tomllib.loads()\r\n\r\n```\r\nimport tomllib\r\nfrom flask import Flask\r\n\r\n\r\ndef tomllib_loads(fp):\r\n    return tomllib.loads(fp.read())\r\n\r\n\r\ndef create_app(config_filename):\r\n    app = Flask(__name__)\r\n    app.config.from_file(config_filename, load=tomllib_loads, silent=False, text=True)\r\n\r\n    @app.route(\"/hello\")\r\n    def hello():\r\n        return \"Hello, World!\"\r\n\r\n    return app\r\n\r\n```\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.3\r\n- Flask version: 2.3.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5164",
    "comments": [
      "I don't understand what you're reporting. Please show the code that's not working. ",
      "Instead of \r\n\r\n`app.config.from_file(config_filename, load=tomllib.load, silent=False, text=True)`\r\n\r\n... as in the documentation, I needed a helper:\r\n\r\n```\r\ntomllib_loads(fs):\r\n    return tomllib.loads(fp.read())\r\n```\r\n\r\nSo that I could say\r\n\r\n`app.config.from_file(config_filename, load=tomllib_load, silent=False, text=True)`\r\n\r\nto provide the .toml content string to `from_file()` instead of the .toml file path.\r\n\r\nRegret the lack of clarity. ",
      "You didn't follow the documentation, you put `text=True` where the documentation shows `text=False`."
    ]
  },
  {
    "title": "Switch to importlib breaks scripts with `app.run()`",
    "body": "With a trivial script [using `app.run()`](https://flask.palletsprojects.com/en/2.3.x/server/#in-code) such as:\r\n\r\n```python3\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug=True)\r\n```\r\n\r\nThe current git `main` breaks with:\r\n\r\n```pytb\r\nTraceback (most recent call last):\r\n  File \"/home/florian/tmp/flask/app.py\", line 3, in <module>\r\n    app = Flask(__name__)\r\n          ^^^^^^^^^^^^^^^\r\n  File \"/home/florian/tmp/flask/src/flask/app.py\", line 376, in __init__\r\n    instance_path = self.auto_find_instance_path()\r\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/florian/tmp/flask/src/flask/app.py\", line 630, in auto_find_instance_path\r\n    prefix, package_path = find_package(self.import_name)\r\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/florian/tmp/flask/src/flask/scaffold.py\", line 898, in find_package\r\n    package_path = _find_package_path(import_name)\r\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/florian/tmp/flask/src/flask/scaffold.py\", line 858, in _find_package_path\r\n    spec = importlib.util.find_spec(root_mod_name)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"<frozen importlib.util>\", line 114, in find_spec\r\nValueError: __main__.__spec__ is None\r\n```\r\n\r\nThis seems to be a regression due to 84e11a1e827c0f55f9b9ee15952eddcf8a6492e0 from #5157.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.4\r\n- Flask version: git main\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5160",
    "comments": [
      "Thanks for catching this before it got released.",
      "The second half of the code in `_find_package_path` seems redundant now that we can only use `importllib.util.find_spec` and not `pkgutil.get_loader`. I'm not entirely clear how it was doing much even before that.",
      "Looking great now, thanks!\r\n\r\n> Thanks for catching this before it got released.\r\n\r\nI run a [nightly CI workflow](https://github.com/qutebrowser/qutebrowser/blob/master/.github/workflows/bleeding.yml) which [installs all dependencies from VCS](https://github.com/qutebrowser/qutebrowser/blob/master/misc/requirements/requirements-tests-bleeding.txt) - I can only recommend more projects to do so, it's a great way to catch and report problems before they turn into bigger problems :)\r\n"
    ]
  },
  {
    "title": "FLASK_APP is unavailable when FlaskGroup is not used",
    "body": "When cli group created with [flask.cli.AppGroup](https://github.com/pallets/flask/blob/main/src/flask/cli.py#L362) and returned to cli instead of default [flask.cli.FlaskGroup](https://github.com/pallets/flask/blob/main/src/flask/cli.py#L481) [flask.cli.ScriptInfo](https://github.com/pallets/flask/blob/main/src/flask/cli.py#L266) failing to locate application with `FLASK_APP` environment variable with this error message:\r\n```\r\nError: Could not locate a Flask application. Use the 'flask --app' option, 'FLASK_APP' environment variable, or a 'wsgi.py' or 'app.py' file in the current directory.\r\n```\r\n\r\nHere is a simple example of executable file `main.py`:\r\n```python\r\n#!/usr/bin/env python\r\nfrom os import environ\r\n\r\nimport click\r\nfrom flask import Flask\r\nfrom flask.cli import AppGroup\r\n\r\ncli = AppGroup(\"main\")\r\n\r\n\r\n@cli.command()\r\ndef test():\r\n    click.echo(\"Test command\")\r\n\r\n\r\ndef create_app() -> Flask:\r\n    app = Flask(__name__)\r\n    app.cli.add_command(cli)\r\n    return app\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    environ.setdefault(\"FLASK_APP\", \"main:create_app\")\r\n    cli()\r\n```\r\n\r\nIf run this file with flask<2.2.0:\r\n```\r\n$ ./main.py test\r\nTest command\r\n```\r\nAnd with flask>=2.2.0:\r\n```\r\n$ ./main.py test\r\nUsage: main.py test [OPTIONS]\r\nTry 'main.py test --help' for help.\r\n\r\nError: Could not locate a Flask application. Use the 'flask --app' option, 'FLASK_APP' environment variable, or a 'wsgi.py' or 'app.py' file in the current directory.\r\n```\r\n\r\nI think this error is caused by [this](https://github.com/pallets/flask/commit/99fa3c36abc03cd5b3407df34dce74e879ea377a) commit. Before 2.2.0 ScriptInfo locates `app_import_path` automatically from environment variable `FLASK_APP`, after 2.2.0 it expects that this value will be provided by `--app` of option FlaskGroup that can get it from `FLASK_APP` environment variable.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11\r\n- Flask version: >=2.2.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5155",
    "comments": [
      "You still need to run commands with the `flask` command, that's why you register them with `app.cli.add_command`.\r\n\r\n```\r\n$ flask main test\r\n```",
      "I don't want to expand flask commands, so I don't use FlaskGroup, and use main.py script instead. This worked fine before 2.2.0.",
      "Then you need to create the `ScriptInfo`, which is what `FlaskGroup` does for you.\r\n\r\n```python\r\nif __name__ == \"__main__\":\r\n    info = ScriptInfo(create_app=create_app)\r\n    cli(obj=info)\r\n```",
      "> https://flask.palletsprojects.com/en/2.3.x/cli/#custom-scripts\r\n\r\nThis won't disable `--app`, `--debug` and `--env-file` options..."
    ]
  },
  {
    "title": "Python3.12.0b1 test_max_cookie_size error",
    "body": "`test_max_cookie_size` fails with python3.12, see the following error:\r\n```\r\n====================================================== FAILURES =======================================================\r\n________________________________________________ test_max_cookie_size _________________________________________________\r\n\r\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>, recwarn = WarningsRecorder(record=True)\r\n\r\n    def test_max_cookie_size(app, client, recwarn):\r\n        app.config[\"MAX_COOKIE_SIZE\"] = 100\r\n\r\n        # outside app context, default to Werkzeug static value,\r\n        # which is also the default config\r\n        response = flask.Response()\r\n        default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\r\n        assert response.max_cookie_size == default\r\n\r\n        # inside app context, use app config\r\n        with app.app_context():\r\n            assert flask.Response().max_cookie_size == 100\r\n\r\n        @app.route(\"/\")\r\n        def index():\r\n            r = flask.Response(\"\", status=204)\r\n            r.set_cookie(\"foo\", \"bar\" * 100)\r\n            return r\r\n\r\n        client.get(\"/\")\r\n        for w in recwarn:\r\n            print('---')\r\n            print(w.message)\r\n>       assert len(recwarn) == 1\r\nE       assert 4 == 1\r\nE        +  where 4 = len(WarningsRecorder(record=True))\r\n\r\napp        = <Flask 'flask_test'>\r\nclient     = <FlaskClient <Flask 'flask_test'>>\r\ndefault    = 4093\r\nindex      = <function test_max_cookie_size.<locals>.index at 0x7f4d8a84dbc0>\r\nrecwarn    = WarningsRecorder(record=True)\r\nresponse   = <Response 0 bytes [200 OK]>\r\nw          = <warnings.WarningMessage object at 0x7f4d8a90c560>\r\n\r\ntests/test_basic.py:1868: AssertionError\r\n------------------------------------------------ Captured stdout call -------------------------------------------------\r\n---\r\nast.Str is deprecated and will be removed in Python 3.14; use ast.Constant instead\r\n---\r\nast.Str is deprecated and will be removed in Python 3.14; use ast.Constant instead\r\n---\r\nAttribute s is deprecated and will be removed in Python 3.14; use value instead\r\n---\r\nThe 'foo' cookie is too large: the value was 300 bytes but the header required 12 extra bytes. The final size was 312 bytes but the limit is 100 bytes. Browsers may silently ignore cookies larger than this.\r\n```\r\n\r\nI have only inserted \r\n```python\r\n        for w in recwarn:\r\n            print('---')\r\n            print(w.message)\r\n```\r\nbefore `assert` to print the warnings. The same happens with flask-2.2.5 as well.\r\n\r\n\r\n**Environment**:\r\n\r\n- Python version: 3.12.0b1\r\n- Flask version: 2.3.2 and 2.2.5\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5146",
    "comments": [
      "Duplicate of https://github.com/pallets/werkzeug/issues/2704"
    ]
  },
  {
    "title": "config from datafile docs",
    "body": "There is a small discrepancy in the docs related to configuration from datafiles.  \r\n\r\nSee [Config Docs](https://flask.palletsprojects.com/en/2.3.x/config/#configuring-from-data-files)\r\nand [from_file API](https://flask.palletsprojects.com/en/2.3.x/api/#flask.Config.from_file)\r\n\r\nIn order to keep consistency and minimize confusion, it should be similar. ",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5139",
    "comments": [
      "No need to open issues for simple documentation fixes.",
      "Just followed the instructions. Good to know next time. "
    ]
  },
  {
    "title": "Unexpected HTML in JSON",
    "body": "I work with a class like this:\r\n\r\n```python\r\nclass Reference:\r\n    def __init__(self, url):\r\n        self.url = url\r\n\r\n    def __str__(self):\r\n        return self.url\r\n\r\n    def __html__(self):\r\n        markup = Markup('<a href=\"%s\" class=\"ref\">%s</a>')\r\n        return markup % (self.url, self.url)\r\n```\r\n\r\nThis works well when I use this in a HTML template. However, when I include such an object in a JSON response, I get the HTML markup instead of the string version. I can think of very few cases in which that is useful.\r\n\r\nThis is a minor inconvenience because I can manually convert the object to a string before including it in the JSON response. But still, maybe this could be improved. I can think of different options:\r\n\r\n- Do not use `__html__()` in jsonify\r\n- Use `__str__()` in jsonify, with a higher priority than `__html__()`\r\n- Use a new method `__json__()` in jsonify, with highest priority\r\n\r\nThe last option has the benefit of being backwards-compatible.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5138",
    "comments": [
      "If you need specific control over the object-to-structure conversion before serialization, then you want a library such as marshmallow, cattrs, pydantic, etc.\r\n\r\nYou can also write a custom `JSONProvider` class to do whatever your specific application needs."
    ]
  },
  {
    "title": "Wrong syntax in JavaScript patterns documentation",
    "body": "In the section *Making a Request with fetch* the syntax of the `FormData.append` command is wrong:\r\n\r\nhttps://github.com/pallets/flask/blob/d0bf462866289ad8bfe29b6e4e1e0f531003ab34/docs/patterns/javascript.rst?plain=1#L128-L129\r\n\r\nSee [`FormData.append` syntax on MDN](https://developer.mozilla.org/en-US/docs/Web/API/FormData/append#syntax).\r\n\r\nEnvironment:\r\n\r\n- Python version: all\r\n- Flask version: 2.3.x\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5135",
    "comments": []
  },
  {
    "title": "Accept the same arguments as dict constructor for template rendering functions",
    "body": "The template rendering functions currently only accept named arguments to build the context dictionary passed to `jinja2.Template.render()`. While unpacking is easy enough, it would be nice to be able to use the same arguments as the dict constructor (like how [Jinja's render function works](https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.Template.render)).\r\n\r\nExamples:\r\n```\r\nflask.render_template(\"index.html\", {\"greeting\": \"Hello\", \"name\": \"World\"})\r\nflask.render_template(\"index.html\", {\"greeting\": \"Hello\"}, name=\"World\")\r\n```\r\n\r\nI'll link a PR in case this is something people would like.\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5133",
    "comments": [
      "Thanks, but I prefer keeping this API simple, as you say dict unpacking already handles this."
    ]
  },
  {
    "title": "After switching to latest flask, app timeouts on some requests",
    "body": "When I wanted to upgrade from 2.2.x to 2.3.x I encountered problem with timeouts on some requests, without any error log about it.\r\n\r\nAny ideas please ? What can cause it?\r\n\r\n- Python version: 3.10\r\n- Flask version: 2.3.2\r\n- gunicorn: 20.1.0\r\n- gevent: 22.10.2\r\n- nginx: 1.18.0",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5131",
    "comments": []
  },
  {
    "title": "AttributeError: 'Flask' object has no attribute 'before_first_request'",
    "body": "When I run code in [deepzoom](https://github.com/openslide/openslide-python/blob/main/examples/deepzoom/deepzoom_multiserver.py), it gives me **AttributeError: 'Flask' object has no attribute 'before_first_request'**\r\n<img width=\"659\" alt=\"\u622a\u5c4f2023-05-12 18 25 03\" src=\"https://github.com/pallets/flask/assets/48406770/fa211b95-b545-4fa0-be8b-94c8b98a85c8\">\r\nI don't known anything about flask. I'm just a student who want to view the image.\r\nCan I replace this line with something simple?",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5123",
    "comments": [
      "as per https://github.com/pallets/flask/blob/main/CHANGES.rst#version-230 - version 2.3.0 removed those\r\nso you need to use a older version of flask",
      "Version 2.2.5 works for me!\r\nThanks!",
      "For the record, this was fixed in OpenSlide Python in https://github.com/openslide/openslide-python/pull/200.",
      "@bgilbert I won't object super strongly, since using the factory pattern is good in general. But it doesn't look like you actually needed to do that, you should have been able to do whatever was in `before_first_request` right next to the other setup you were doing, without other restructuring.",
      "Thanks for looking!  The code is designed to be run either manually from the command line or via a WSGI wrapper.  I switched to a factory function because the WSGI wrapper needs to call a setup function that skips the command-line parsing."
    ]
  },
  {
    "title": "Flask 2.3.2 is not compatible with Flassger",
    "body": "Flask 2.3.2 is not compatible with Flassger\r\n\r\nDescription:\r\nAfter upgrading Flask to latest version we are getting below error.\r\n\r\n```\r\nfrom flasgger import Swagger\r\n  File \"C:\\Python310\\lib\\site-packages\\flasgger\\__init__.py\", line 10, in <module>\r\n    from .base import Swagger, Flasgger, NO_SANITIZER, BR_SANITIZER, MK_SANITIZER, LazyJSONEncoder  # noqa\r\n  File \"C:\\Python310\\lib\\site-packages\\flasgger\\base.py\", line 28, in <module>\r\n    from flask.json import JSONEncoder\r\nImportError: cannot import name 'JSONEncoder' from 'flask.json' (C:\\Python310\\lib\\site-packages\\flask\\json\\__init__.py)\r\n```\r\n\r\nAfter downgrading flask to 2.2.3, it works again!\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.10\r\n- Flask version: 2.3.2\r\n- Flassger: Latest\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5119",
    "comments": [
      "This is not for Flask but for Flassger. And it looks like they already have a PR to fix it: https://github.com/flasgger/flasgger/pull/564\r\nThey just need to release a version containing that fix."
    ]
  },
  {
    "title": "Cyclomatic complexity improvements",
    "body": "Hi, \r\n\r\nI found this hammer called \"cyclomatic complexity\" and a tool \"radon\" on pypi and I built my own tool on top of it. Now I'm looking for nails. In short it's a method to evaluate code quality and I could make small improvements to the code?\r\n\r\nE.g. \r\nhttps://github.com/pallets/flask/blob/main/src/flask/app.py#L867\r\n\r\nturning\r\n```\r\nif not host:\r\n    if sn_host:\r\n        host = sn_host\r\n    else:\r\n        host = \"127.0.0.1\"\r\n\r\nif port or port == 0:\r\n    port = int(port)\r\nelif sn_port:\r\n    port = int(sn_port)\r\nelse:\r\n    port = 5000\r\n```\r\ninto small functions like this \r\n```\r\ndef decide_on_default_host(self, host, sn_host)\r\n    if not host:\r\n        if sn_host:\r\n            host = sn_host\r\n        else:\r\n            host = \"127.0.0.1\"\r\n        return host\r\n\r\ndef decide_on_default_port(self, port, sn_port)\r\n    if port or port == 0:\r\n        port = int(port)\r\n    elif sn_port:\r\n        port = int(sn_port)\r\n    else:\r\n        port = 5000\r\n    return port\r\n```\r\nand then using them in place of the old blocks.\r\n\r\nHere are some links:\r\nhttps://pypi.org/project/radon/\r\nhttps://radon.readthedocs.io/en/latest/commandline.html#the-cc-command\r\nhttps://en.wikipedia.org/wiki/Cyclomatic_complexity\r\n\r\n\r\nAn example of the problem which this feature\r\nwould resolve. Is this problem solvable without changes to Flask, such\r\nas by subclassing or using an extension?\r\n\r\n\r\nIt's not a defect or shortcoming, Flask does not \"need\" changing. The aim is to make the source easier to read, that's all.\r\n\r\nFlask looks pretty good though, the only \"D\" is `Blueprint.register` https://github.com/pallets/flask/blob/main/src/flask/blueprints.py#L273\r\n\r\nLet me know if this kind of contribution is something you want.\r\n\r\nRegards\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5118",
    "comments": [
      "Thanks for looking at this, but we generally don't do these sorts of refactors."
    ]
  },
  {
    "title": "`config.from_file` can't read arbitrary toml structures",
    "body": "I like to use groups on my toml file to organize code. But flask does not seem to understand this. It will simply create config like this:\r\n\r\n```\r\nconfig = {\r\n   'flask': { 'debug': True, 'SECRET_KEY': ''}\r\n}\r\n```\r\n\r\n\r\n```\r\n[flask]\r\nDEBUG = true\r\nSECRET_KEY = \"\"\r\n\r\n[database]\r\nSQLALCHEMY_DATABASE_URI = 'sqlite:///db.sqlite'\r\nSQLALCHEMY_BINDS = {}\r\nSQLALCHEMY_TRACK_MODIFICATIONS = false\r\n```\r\n\r\n\r\nCan we add an argument on the `from_file` method so that I do not have to do any manual modification of my toml files, or any manual modification after loading from the toml file in my python code? I should not have to do this. This seems like a bug. \r\n\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5117",
    "comments": [
      "Having to write code like this:\r\n\r\n\r\n```\r\nimport toml\r\n\r\n# Load the config file using the toml package\r\nwith open('config.toml', 'r') as f:\r\n    config_dict = toml.load(f)\r\n\r\n# Extract the Flask config options from the dictionary\r\nflask_config = config_dict['flask']\r\n\r\n# Set the Flask config options on the app\r\nfor key, value in flask_config.items():\r\n    app.config[key.upper()] = value\r\n\r\n\r\n```\r\n\r\n\r\nDefeats the entire purpose of the from_file method",
      "In order to resolve the issue, you can create a custom method for loading the TOML file and setting the Flask app's configuration. This method will handle nested TOML groups and update the Flask app's configuration accordingly.\r\n\r\n1. First, you can create a helper function to flatten the nested TOML dictionary:\r\n\r\n```python\r\ndef flatten_config(config_dict, parent_key='', sep='_'):\r\n    flattened = {}\r\n    for key, value in config_dict.items():\r\n        new_key = f\"{parent_key}{sep}{key}\" if parent_key else key\r\n        if isinstance(value, dict):\r\n            flattened.update(flatten_config(value, new_key, sep=sep))\r\n        else:\r\n            flattened[new_key] = value\r\n    return flattened\r\n``` \r\n\r\n2. Then, create a custom from_toml_file method that loads the TOML file, flattens the nested configuration, and sets the Flask app's configuration:\r\n\r\n```python\r\nimport toml\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\ndef from_toml_file(app, toml_file):\r\n    # Load the config file using the toml package\r\n    with open(toml_file, 'r') as f:\r\n        config_dict = toml.load(f)\r\n\r\n    # Flatten the config dictionary\r\n    flattened_config = flatten_config(config_dict)\r\n\r\n    # Set the flattened config options on the app\r\n    for key, value in flattened_config.items():\r\n        app.config[key.upper()] = value\r\n\r\n# Usage:\r\nfrom_toml_file(app, 'config.toml')\r\n``` \r\n\r\nNow you can use the from_toml_file method to load your TOML configuration file without having to manually modify the file or the Python code. This will handle the nested TOML groups and update the Flask app's configuration accordingly.",
      "I'm pretty sure that TOML groups, like ini categories or yaml dict keys, are not arbitrary but result in nested data. But flask's config is flat. It would be really weird if you could randomly nest things. Maybe just use comments as \"category headers\" instead?\r\n\r\nOf course nothing stops you from writing your own config parsing logic where settings are categorized. But honestly, I would then handle those settings manually and simply populate flask settings where needed.",
      "> \r\n\r\n\r\n\r\n> In order to resolve the issue, you can create a custom method for loading the TOML file and setting the Flask app's configuration. This method will handle nested TOML groups and update the Flask app's configuration accordingly.\r\n> \r\n>     1. First, you can create a helper function to flatten the nested TOML dictionary:\r\n> \r\n> \r\n> ```python\r\n> def flatten_config(config_dict, parent_key='', sep='_'):\r\n>     flattened = {}\r\n>     for key, value in config_dict.items():\r\n>         new_key = f\"{parent_key}{sep}{key}\" if parent_key else key\r\n>         if isinstance(value, dict):\r\n>             flattened.update(flatten_config(value, new_key, sep=sep))\r\n>         else:\r\n>             flattened[new_key] = value\r\n>     return flattened\r\n> ```\r\n> \r\n>     2. Then, create a custom from_toml_file method that loads the TOML file, flattens the nested configuration, and sets the Flask app's configuration:\r\n> \r\n> \r\n> ```python\r\n> import toml\r\n> from flask import Flask\r\n> \r\n> app = Flask(__name__)\r\n> \r\n> def from_toml_file(app, toml_file):\r\n>     # Load the config file using the toml package\r\n>     with open(toml_file, 'r') as f:\r\n>         config_dict = toml.load(f)\r\n> \r\n>     # Flatten the config dictionary\r\n>     flattened_config = flatten_config(config_dict)\r\n> \r\n>     # Set the flattened config options on the app\r\n>     for key, value in flattened_config.items():\r\n>         app.config[key.upper()] = value\r\n> \r\n> # Usage:\r\n> from_toml_file(app, 'config.toml')\r\n> ```\r\n> \r\n> Now you can use the from_toml_file method to load your TOML configuration file without having to manually modify the file or the Python code. This will handle the nested TOML groups and update the Flask app's configuration accordingly.\r\n\r\n\r\n\r\nFlask's code should be updated so that users do not have to write additional code like this., \r\n\r\n",
      "Flask's top-level config is a flat namespace. If you have a config file with a different structure, you'll need to adapt it to the one that Flask and extensions use. Here's a much shorter adapter to remove the groups you've added:\r\n\r\n```python\r\napp.config.from_file(\r\n    \"config.toml\",\r\n    load=lambda f: {k: v for vs in tomllib.load(f).values() for k, v in vs.items()},\r\n    text=True\r\n)\r\n```"
    ]
  },
  {
    "title": "A Mojo compatible version of Flask",
    "body": "Hi all!\n\nIn case you haven't heard about it, a company called Modular is developing a superset for Python which adds types, low level stuff, and other awesome features. The name of this superset is [Mojo](https://www.modular.com/mojo). \n\nI think a version of the Flask framework with strong types would benefit developers and the framework maybe would get more adopters because of the types.\n\n_Of course this is just an idea and I'm aware of how big of a challange it would be to write and maintain a seperate version (though you could also just update the original code but that would lead to compatibility issues)._\n\nWhat do you think?",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5116",
    "comments": []
  },
  {
    "title": "Uploading a file adds blank line at top of the file.",
    "body": "<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\nWhen uploading or saving a file, a empty line is added at the top of the file.\r\n\r\nVersion impacted : at least 2.2.5\r\n\r\nWorking version : 2.2.2\r\n\r\n## Reproduction :\r\n\r\n```python\r\n@app.route(\"/\", methods=[\"POST\"])\r\ndef upload_files():\r\n    for file in request.files.getlist(\"files\"):\r\n        filepath = os.path.join(app.config.get(\"UPLOAD_FOLDER\"), secure_filename(file.filename))\r\n        file.save(filepath) \r\n```\r\n### Current behavior :\r\n\r\nThe file has a blank line at the top (new line)\r\n\r\n### Expected behavior :\r\n\r\nThe file is uploaded as is. (Working as expected on 2.2.2)\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.11\r\n- Flask version: 2.2.5\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5113",
    "comments": [
      "Ok i thinks it's related to https://github.com/pallets/werkzeug/issues/2675 .\r\n\r\nI let this open to have confirmation the issue is resolved.",
      "Yep, update Werkzeug"
    ]
  },
  {
    "title": "`session_transaction` fails because it's calling `_update_cookies_from_response` with missing arg `headers`",
    "body": "I'm re-creating the bug using flask and pytest.\r\n\r\n## tests/test_session_tx.py\r\n\r\n```py\r\nimport flask\r\n\r\n\r\ndef test_session_tx():\r\n    app = flask.Flask(\"test\")\r\n    app.config[\"SECRET_KEY\"] = \"foo\"\r\n    client = app.test_client()\r\n    with client.session_transaction() as session:\r\n        session[\"bar\"] = \"baz\"\r\n```\r\n\r\n- install flask, pytest: `pip install flask==2.2.4 pytest`\r\n- run `pytest tests/test_session_tx.py`\r\n\r\n```\r\n        if hasattr(self, \"_update_cookies_from_response\"):\r\n>           self._update_cookies_from_response(\r\n                ctx.request.host.partition(\":\")[0], resp.headers.getlist(\"Set-Cookie\")\r\n            )\r\nE           TypeError: Client._update_cookies_from_response() missing 1 required positional argument: 'headers'\r\n\r\nvenv/lib/python3.11/site-packages/flask/testing.py:171: TypeError\r\n```\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.2\r\n- Werkzeug version: 2.3.3\r\n- Flask: 2.2.4\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5107",
    "comments": [
      "I'll add compatibility back in a 2.2.5 release. However, note that you're on an unnsupported version of Flask. The best way to fix this is to upgrade to Flask>=2.3.2.",
      "Ok, this was a bit too fast for my brain. This is a bug in flask 2.2.4. Sorry about that!\r\n\r\nI will take a look at our dependencies later and see why we even get these incompatible packages."
    ]
  },
  {
    "title": "Cookie Expiry not working with Werkzeug upgrade",
    "body": "This looks like a regression in session expiry during testing I'm getting trying to upgrade Werkzeug to the latest version. But, I'm not sure which library to report between flask-login, werkzeug and flask. Happy to repost or restructure!\r\n\r\nI'm overriding session expiry to set a cookie with custom expiry times. My test for this broke although my manual testing seems to work fine. So, I simplified my code to build this small minimal working example. If Werkzeug is `2.3.2` the session won't be expired despite being in the past. If I downgrade back to `2.2.2` the test will pass showing the cookie is being rejected.\r\n\r\n\r\nmain.py\r\n```python\r\nfrom datetime import datetime\r\n\r\nfrom flask import Flask, jsonify\r\nfrom flask.sessions import SecureCookieSessionInterface, SessionMixin\r\nfrom flask_login import LoginManager, UserMixin, login_required, login_user\r\n\r\n\r\nclass CustomSessionInterface(SecureCookieSessionInterface):\r\n    def get_expiration_time(\r\n        self, app: \"Flask\", session: SessionMixin\r\n    ) -> datetime | None:\r\n        return datetime(2001, 1, 1, 12, 0, 0)\r\n\r\n\r\napp = Flask(__name__)\r\nlogin_manager = LoginManager(app=app)\r\n\r\napp.config[\"SERVER_NAME\"] = \"test.fakedomain\"\r\napp.config[\"DEBUG\"] = True\r\napp.config[\"PROPAGATE_EXCEPTIONS\"] = True\r\napp.config[\"SECRET_KEY\"] = \"mysecretkey\"\r\napp.session_interface = CustomSessionInterface()\r\n\r\n\r\nclass User(UserMixin):\r\n    def __init__(self, id):\r\n        self.id = id\r\n\r\n    def is_active(self):\r\n        return True\r\n\r\n\r\n@login_manager.user_loader\r\ndef load_user(user_id):\r\n    return User(user_id)\r\n\r\n\r\n@app.route(\"/login\")\r\ndef login():\r\n    user = User(1)\r\n    login_user(user)\r\n    return \"Logged in successfully!\"\r\n\r\n\r\n@app.route(\"/protected\")\r\n@login_required\r\ndef protected():\r\n    return jsonify({\"status\": \"success\"})\r\n```\r\n\r\ntest_app.py\r\n```python\r\nimport unittest\r\n\r\nfrom flask import url_for\r\nfrom flask_login import current_user\r\nfrom main import app\r\n\r\n\r\nclass TestApp(unittest.TestCase):\r\n    def setUp(self):\r\n        self.app = app.test_client()\r\n        self.app_context = app.app_context()\r\n        self.app_context.push()\r\n\r\n    def tearDown(self):\r\n        self.app_context.pop()\r\n\r\n    def test_login_and_access_protected_route(self):\r\n        with self.app:\r\n            with app.app_context():\r\n                response = self.app.get(url_for(\"login\"))\r\n                self.assertEqual(response.status_code, 200)\r\n                self.assertTrue(current_user.is_authenticated)\r\n\r\n        with self.app:\r\n            response = self.app.get(url_for(\"protected\"))\r\n            self.assertEqual(response.status_code, 401)\r\n ```\r\n\r\nEnvironment:\r\n\r\nPython 3.10.6\r\npip freeze:\r\n```\r\nclick==8.1.3\r\nFlask==2.2.4\r\nFlask-Login==0.6.2\r\nitsdangerous==2.1.2\r\nJinja2==3.1.2\r\nMarkupSafe==2.1.2\r\nWerkzeug==2.3.2\r\n```\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5103",
    "comments": [
      "The test client no longer takes cookie expiration/age into account except to delete cookies if the timestamp is set to 0. https://github.com/pallets/werkzeug/issues/1680#issuecomment-1483222185 Tests that depend on the current date are unreliable, and testing that cookies expire when they expire is testing that browsers work like browsers, not anything about your Flask application. If you need to test that a specific date was set, use `assert client.get_cookie(\"key\").expires == datetime(...)`.\r\n\r\n---\r\n\r\nUnrelated, but doing `with self.app` (which is misnamed, it's the client not the app), and `with app.app_context` around every request is incorrect. Neither of them are necessary. Only push an app context if you need to set something on `g` ahead of time, or to test something outside a request. Only push the client if you need to check something on `request` after the request is made.",
      "Thanks! That solves my issues!"
    ]
  },
  {
    "title": "Blueprint route changes mimetype from 'multipart/form-data' to 'application/x-www-form-urlencoded'",
    "body": "No sure if a bug, but I couldn't find anywhere else the reason for this behaviour of Blueprints.\r\n\r\nWhen send the same `multipart/form-data` request to `/foo` and `/bar` bellow, I get different mimetypes:\r\n\r\n```python\r\n# app.py\r\n\r\nfrom flask import Flask\r\nfrom foo_bp import foo_bp\r\n\r\napp = Flask(__name__)\r\n\r\napp.register_blueprint(foo_bp)\r\n\r\n@app.route(\"/bar\", methods=[\"POST\"])\r\ndef bar():\r\n    print(request.mimetype) # =>  multipart/form-data\r\n```\r\n\r\n```python\r\n# foo_bp.py\r\n\r\nfrom flask import Blueprint\r\n\r\nfoo_bp = Blueprint(\"foo_bp\", __name__, url_prefix=\"/foo\")\r\n\r\n@foo_bp.route(\"/\", methods=[\"POST\"])\r\ndef foo():\r\n    print(request.mimetype) # => application/x-www-form-urlencoded\r\n```\r\n\r\nFor `/foo` (a Blueprint) I get `application/x-www-form-urlencoded` while for `/bar` I get the expected `multipart/form-data`.\r\n\r\nAlso, `request.files` in the Blueprint has an empty list.\r\n\r\nAm I missing something? Thank you in advance.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.11\r\n- Flask version: 2.2.3\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5096",
    "comments": []
  },
  {
    "title": "module  'flask.json' has no attribute 'JSONEncoder'",
    "body": "I use connexion ver 2.14.2 which imports flask. Today my docker build picked up a new Flask version 2.3.1 and the tox tests fail.  I get similar results on startup when using Flask versions 2.3.0 and 2.3.1:\r\n```\r\nour_module/__init__.py:9: in <module>\r\n    import connexion\r\n.tox/code/lib/python3.9/site-packages/connexion/__init__.py:32: in <module>\r\n    from .apps.flask_app import FlaskApp\r\n.tox/code/lib/python3.9/site-packages/connexion/apps/flask_app.py:151: in <module>\r\n    class FlaskJSONEncoder(json.JSONEncoder):\r\nE   AttributeError: module 'flask.json' has no attribute 'JSONEncoder'\r\n```\r\n\r\nWhen I pinned Flask to version 2.2.4 it works fine. Of course this could be a problem over in *connexion*, or something I need to do differently to use the latest Flask. I'll go re-re-recheck your release notes. \r\n\r\nPlease comment, thanks in advance!\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.9\r\n- Flask version: 2.2.4 is ok, \r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5094",
    "comments": [
      "From the changelog:\r\n\r\n> Remove previously deprecated code. [#4995](https://github.com/pallets/flask/pull/4995)\r\n\r\nThis would be a bug in connexion, sounds like they have not updated to be compatible with Flask 2.3. If they had run their tests with warnings treated as errors, they would have seen this when 2.2 was released last year and been able to update proactively.",
      "Thank you for the instant answer!",
      "Looks like it was already fixed in connexion: https://github.com/spec-first/connexion/issues/1576"
    ]
  },
  {
    "title": "python3.7 flask2.2.3 webapi can be connected by Postman and browser but not c# Net6 HttpClient.PostAsync",
    "body": "Hi, \r\nI build a very simple web api by flask2.2.3 using python3.7.\r\nI can use Postman and browser to connect this webapi but not working in c# Net6 by HttpClient.PostAsync.\r\nPlease help me to pass this error.\r\nThank you.\r\n\r\n\r\n\r\nerror message in c#:\r\n****************************\r\n{System.Net.Sockets.SocketException (111): Connection refused\r\n   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)\r\n   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.System.Threading.Tasks.Sources.IValueTaskSource.GetResult(Int16 token)\r\n   at System.Net.Sockets.Socket.<ConnectAsync>g__WaitForConnectWithCancellation|277_0(AwaitableSocketAsyncEventArgs saea, ValueTask connectTask, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.ConnectToTcpHostAsync(String host, Int32 port, HttpRequestMessage initialRequest, Boolean async, CancellationToken cancellationToken)}\r\n*****************************\r\n\r\n\r\nhere is the code:\r\n*****************************\r\nfrom flask import Flask, jsonify, redirect, url_for, render_template,request, Response\r\nimport json\r\nfrom flask_cors import CORS\r\n\r\napp = Flask(__name__)\r\nCORS(app)\r\n\r\n@app.route('/qryData/', methods=['POST', 'GET'])\r\ndef qryData():\r\n\r\n    return jsonify(True);\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(host='0.0.0.0',port=58080,debug=True)   \r\n\r\n*****************************\r\n\r\n\r\n\r\nThanks for your help.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5089",
    "comments": []
  },
  {
    "title": "ImportError: cannot import name 'Markup' from 'flask'",
    "body": "I want to start by apologizing in advance if I make any mistakes in this bug report, I'm new to development and any mistakes are unintentional. That being said I appreciate any input as to how I can improve.\r\n\r\n# The issue: #\r\nCreating a class that inherits from FlaskForm causes an error with the following traceback\r\n```\r\nError: While importing 'app', an ImportError was raised:\r\n\r\nTraceback (most recent call last):\r\n  File \"/home/rburd/.local/share/virtualenvs/d5-9RMvys9g/lib/python3.11/site-packages/flask/cli.py\", line 218, in locate_app\r\n    __import__(module_name)\r\n  File \"/home/rburd/academy/Mod-6/w18/d5/app/__init__.py\", line 2, in <module>\r\n    from .form import Tweet\r\n  File \"/home/rburd/academy/Mod-6/w18/d5/app/form.py\", line 1, in <module>\r\n    from flask_wtf import FlaskForm\r\n  File \"/home/rburd/.local/share/virtualenvs/d5-9RMvys9g/lib/python3.11/site-packages/flask_wtf/__init__.py\", line 4, in <module>\r\n    from .recaptcha import Recaptcha\r\n  File \"/home/rburd/.local/share/virtualenvs/d5-9RMvys9g/lib/python3.11/site-packages/flask_wtf/recaptcha/__init__.py\", line 1, in <module>\r\n    from .fields import RecaptchaField\r\n  File \"/home/rburd/.local/share/virtualenvs/d5-9RMvys9g/lib/python3.11/site-packages/flask_wtf/recaptcha/fields.py\", line 3, in <module>\r\n    from . import widgets\r\n  File \"/home/rburd/.local/share/virtualenvs/d5-9RMvys9g/lib/python3.11/site-packages/flask_wtf/recaptcha/widgets.py\", line 2, in <module>\r\n    from flask import Markup\r\nImportError: cannot import name 'Markup' from 'flask' (/home/rburd/.local/share/virtualenvs/d5-9RMvys9g/lib/python3.11/site-packages/flask/__init__.py)\r\n```\r\nIf I switch to flask ver. 2.2.3 I receive no such error\r\n\r\n# How to reproduce: #\r\nStart a new project in an empty directory using the command `pipenv install flask flask-wtf python-dotenv`\r\nCreate a subfolder named 'app' with the following files\r\n```python\r\n# /app/__init__.py\r\nfrom flask import Flask\r\nfrom .form import Tweet\r\n\r\napp = Flask(__name__)\r\n\r\n```\r\n\r\nand\r\n\r\n```python\r\n# /app/form.py\r\nfrom flask_wtf import FlaskForm\r\nfrom wtforms import StringField, SubmitField\r\n\r\nclass Tweet(FlaskForm):\r\n    author = StringField(\"Author\")\r\n    submit = SubmitField(\"Create New Tweet\")\r\n```\r\n\r\nCreate a .flaskenv file with the following contents:\r\n```\r\nFLASK_APP=app\r\n```\r\n\r\nFinally try to start the app with the command `pipenv run flask run`\r\n\r\n# What I Expected: #\r\nWhen the `flask run` command is given no error should occur, which is the behavior observed when using flask ver. 2.2.3\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.3\r\n- Flask version: 2.3.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5088",
    "comments": [
      "Duplicate of https://github.com/pallets/flask/issues/5084"
    ]
  },
  {
    "title": "ImportError: cannot import name 'Markup' from 'flask'",
    "body": "First I want to apologize if I've done anything wrong with this bug report, I'm still new to development and any mistakes made are unintentional.\r\n<!--\r\nThis issue tracker is a tool to address bugs in Flask itself. Please use\r\nPallets Discord or Stack Overflow for questions about your own code.\r\n\r\nReplace this comment with a clear outline of what the bug is.\r\n-->\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.3\r\n- Flask version: 2.3.0\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5087",
    "comments": [
      "Duplicate of https://github.com/pallets/flask/issues/5084"
    ]
  },
  {
    "title": "Cannot import Markup from flask",
    "body": "`from flask import Markup` and `flask.Markup` both don\u2019t work. This is merely supposed to be deprecated, not broken, in Flask 2.3.0.\r\n\r\nExample A:\r\n```python\r\nimport flask\r\n\r\nprint(flask.Markup('hi'))\r\n```\r\n```\r\nTraceback (most recent call last):\r\n  File \"/tmp/flask230/1.py\", line 3, in <module>\r\n    print(flask.Markup('hi'))\r\n  File \"/tmp/flask230/venv/lib/python3.10/site-packages/flask/__init__.py\", line 102, in __getattr__\r\n    raise AttributeError(name)\r\nAttributeError: Markup\r\n```\r\n\r\nExample B:\r\n```python\r\nfrom flask import Markup\r\n\r\nprint(Markup('hi'))\r\n```\r\n```\r\nTraceback (most recent call last):\r\n  File \"/tmp/flask230/2.py\", line 1, in <module>\r\n    from flask import Markup\r\nImportError: cannot import name 'Markup' from 'flask' (/tmp/flask230/venv/lib/python3.10/site-packages/flask/__init__.py)\r\n```\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.10.10\r\n- Flask version: 2.3.0",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5084",
    "comments": [
      "PyPI's upload API is down at the moment, I will retry the release later. ",
      "Flask 2.3.1 is now available on PyPI. "
    ]
  },
  {
    "title": "Auto-reload triggered on file read",
    "body": "Summary:\r\nAuto-reload on the development server is triggered by requests (i.e. file reads) without a file modification happening.\r\n\r\n\r\nHow to reproduce:\r\nAny Flask project, having installed Watchdog version >= 2.3.0. Send a request to any endpoint.\r\n\r\nExpected behavior:\r\nWhen sending a request to the server, the server answers and doesn't get reloaded unless a file is modified.\r\n\r\nMy assumption is that the new event FileOpenedEvent added in 2.3.0 is being treated as a file modification and triggering auto-reload. Forcing watchdog version 2.2.1 fixed the problem.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.8\r\n- Flask version: 2.2.2\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5076",
    "comments": [
      "Duplicate of https://github.com/pallets/werkzeug/issues/2603"
    ]
  },
  {
    "title": "pip install flask-sqlalchemy  Fails",
    "body": "<!--\r\nOn newest version of python (3.11). Using Pycharm. Venv environment.\r\nTrying to attach Sqlalchemy.\r\n\r\npip install flask-wtf      Works fine\r\npip install flask-sqlalchemy     Fails. \r\n\r\nFails to build greenlet.  Wheel does not run successfully.\r\n\r\nUsing the same steps in python (3.8), all works fine.\r\n\r\nIs it not compatible with version 3.11\r\n\r\nAny help is appreciated.\r\n\r\nThanks,\r\nDigdug\r\n\r\n-->\r\n\r\n<!--\r\nDescribe how to replicate the bug.\r\n\r\nInclude a minimal reproducible example that demonstrates the bug.\r\nInclude the full traceback if there was an exception.\r\n-->\r\n\r\n<!--\r\nDescribe the expected behavior that should have happened but didn't.\r\n-->\r\n\r\nEnvironment:\r\n\r\n- Python version:\r\n- Flask version:\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5070",
    "comments": [
      "Python version 3.8  - Worked.\r\nPython version 3.11 - Failed\r\n\r\nBelieve the Flask version is 2.2.3\r\nCreated from pip just a couple of days age.\r\n\r\nThanks",
      "Do I need to create a new issue with this info?",
      "No, you need to open a well written issue on the relevant project. This isn't an issue with Flask (or Flask-SQLAlchemy). It's an issue with your environment, something about pip or virtualenv probably. This tracker is for issues related to Flask itself."
    ]
  },
  {
    "title": "Unit testing a delete endpoint causes ValueError: Invalid location argument: args",
    "body": "I am trying to create a unit test for a DELETE endpoint. Here is simplified code:\r\n```\r\napp = Flask(__name__)\r\napp.config.update({\r\n    \"TESTING\": True,\r\n})\r\napi = Api(app)\r\napi.add_resource(ObjectiveInterface, \"/objectives\")\r\n\r\nclient = app.test_client()\r\nresponse = client.delete('/objectives?id=12') # also tried client.delete('/objectives', data={'id': '12'})\r\n```\r\n\r\nWhich fails with the following error. I followed the guide [here](https://flask.palletsprojects.com/en/2.2.x/testing/) to write my test, and I believe the code is correct. Is this a bug with Flask or am I doing something wrong?\r\n```\r\nError\r\nTraceback (most recent call last):\r\n  File \"test_objective_interface.py\", line 92, in test_delete\r\n    response = self.client.delete('/objectives?id=12')\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"werkzeug\\test.py\", line 1156, in delete\r\n    return self.open(*args, **kw)\r\n           ^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask\\testing.py\", line 223, in open\r\n    response = super().open(\r\n               ^^^^^^^^^^^^^\r\n  File \"werkzeug\\test.py\", line 1095, in open\r\n    response = self.run_wsgi_app(request.environ, buffered=buffered)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"werkzeug\\test.py\", line 962, in run_wsgi_app\r\n    rv = run_wsgi_app(self.application, environ, buffered=buffered)\r\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"werkzeug\\test.py\", line 1243, in run_wsgi_app\r\n    app_rv = app(environ, start_response)\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask\\app.py\", line 2551, in __call__\r\n    return self.wsgi_app(environ, start_response)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask\\app.py\", line 2531, in wsgi_app\r\n    response = self.handle_exception(e)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask_restful\\__init__.py\", line 271, in error_router\r\n    return original_handler(e)\r\n           ^^^^^^^^^^^^^^^^^^^\r\n  File \"flask_restful\\__init__.py\", line 268, in error_router\r\n    return self.handle_error(e)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask\\app.py\", line 2528, in wsgi_app\r\n    response = self.full_dispatch_request()\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask\\app.py\", line 1825, in full_dispatch_request\r\n    rv = self.handle_user_exception(e)\r\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask_restful\\__init__.py\", line 271, in error_router\r\n    return original_handler(e)\r\n           ^^^^^^^^^^^^^^^^^^^\r\n  File \"flask_restful\\__init__.py\", line 268, in error_router\r\n    return self.handle_error(e)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask\\app.py\", line 1823, in full_dispatch_request\r\n    rv = self.dispatch_request()\r\n         ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask\\app.py\", line 1799, in dispatch_request\r\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask_restful\\__init__.py\", line 467, in wrapper\r\n    resp = resource(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask\\views.py\", line 107, in view\r\n    return current_app.ensure_sync(self.dispatch_request)(**kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask\\views.py\", line 188, in dispatch_request\r\n    return current_app.ensure_sync(meth)(**kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask_apispec\\annotations.py\", line 122, in wrapped\r\n    return wrapper(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask_apispec\\wrapper.py\", line 29, in __call__\r\n    response = self.call_view(*args, **kwargs)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"flask_apispec\\wrapper.py\", line 44, in call_view\r\n    parsed = parser.parse(schema, location=option['kwargs']['location'])\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"webargs\\core.py\", line 405, in parse\r\n    location_data = self._load_location_data(\r\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"webargs\\core.py\", line 210, in _load_location_data\r\n    loader_func = self._get_loader(location)\r\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"webargs\\core.py\", line 193, in _get_loader\r\n    raise ValueError(f\"Invalid location argument: {location}\")\r\nValueError: Invalid location argument: args\r\n```\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11\r\n- Werkzeug version: 2.2.3\r\n- Flask version: 2.2.3\r\n- Flask restful: 0.3.9\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5069",
    "comments": [
      "Looks like that's coming from an extension, not Flask."
    ]
  },
  {
    "title": "CONTRIBUTING: Change from venv name \"env\" to \".venv\" for Windows as well?",
    "body": "https://github.com/pallets/flask/blob/182ce3dd15dfa3537391c3efaf9c3ff407d134d4/CONTRIBUTING.rst?plain=1#L123-L124\r\n\r\nI think in line 124 `env` should also be renamed to `.venv`",
    "labels": [
      "docs"
    ],
    "url": "https://github.com/pallets/flask/issues/5062",
    "comments": [
      "9a4d370e\r\n\r\nFor future reference, you don't need to report docs typos, it's faster to submit a PR."
    ]
  },
  {
    "title": "Allow to not trim prefixes on Config.from_prefixed_env",
    "body": "`Config.from_prefixed_env` is quite helpful to automatically import configuration from the environment variables. However, I ran into the issue that I want to use it together with the `Config.get_namespace` feature, which itself requires a certain prefix, to configure extensions to Flask (PonyORM in my case) using environment variables.\r\n\r\nI thought about using the prefix `PONY_` for the namespace, however with the current implementation, the environment variables must be called something like `FLASK_PONY_*` or `PONY_PONY_*` so they can be imported using `from_prefixed_env` to retain a prefix to then be correctly returned by `get_namespace`.\r\n\r\nI know that this is theoretically possible without changing Flask by implementing the required variant for from_prefixed_env in my own app, however, I think this feature might be helpful to other Flask users, especially together with `get_namespace`.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5060",
    "comments": [
      "> `FLASK_PONY_*`\r\n\r\nThis is deliberate, it keeps everything related to the Flask app in the same \"namespace\". You can even change the prefix so you can have different apps/instances without mixing their config."
    ]
  },
  {
    "title": "make blinker a required dependency",
    "body": "It's now part of the Pallets-Eco community, https://github.com/pallets-eco. Making it required will simplify Flask's support, it's a bit of a hack right now that typing doesn't like.",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5056",
    "comments": []
  },
  {
    "title": "Docs: chat assistant",
    "body": "Proposal:\r\nUse OpenAI (or other LLM) API to allow users to query the docs interactively with a chatbot assistant. For building it would involve chopping up the documentation into each section and storing them in a vector database like chroma, weviate, pinecone, supabase etc and using langchain as the back end to pre-prompt the LLM. The LLM would then query the vector database for the relevant section and return a nuanced answer to the user's question. It would look very similar to what supabase is working on with clippy for their docs: https://supabase.com/blog/chatgpt-supabase-docs . \r\n\r\nWhat it changes:\r\nThis would be a change to the doc site and not to Flask itself. It would also require an openAI api key (or another LLM or access to a self hosted LLM). I'm currently building out a version myself as part of a learning project but it will have a cap on the number of queries that can be asked since my spend limit on OpenAI is $30/month.\r\n",
    "labels": [],
    "url": "https://github.com/pallets/flask/issues/5055",
    "comments": [
      "Absolutely not. Normalizing the idea that LLMs can in any way give correct answers, rather than generate things that look like answers but don't contain any true verification or insight, does a disservice to developers."
    ]
  }
]